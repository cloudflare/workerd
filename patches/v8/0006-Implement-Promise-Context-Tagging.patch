From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: James M Snell <jasnell@gmail.com>
Date: Thu, 22 Jun 2023 15:29:26 -0700
Subject: Implement Promise Context Tagging


diff --git a/include/v8-callbacks.h b/include/v8-callbacks.h
index e5eba5a203b8bc4d0c05b1f0d6cbdffd352d4a06..cfba4bb26f865c0e38574f796200ffc5e0dc60fc 100644
--- a/include/v8-callbacks.h
+++ b/include/v8-callbacks.h
@@ -528,6 +528,14 @@ using FilterETWSessionByURL2Callback = FilterETWSessionByURLResult (*)(
     Local<Context> context, const std::string& etw_filter_payload);
 #endif  // V8_OS_WIN
 
+/**
+ * PromiseCrossContextCallback is called when following a promise and the
+ * promise's context tag is not strictly equal to the isolate's current
+ * promise context tag.
+ */
+using PromiseCrossContextCallback = MaybeLocal<Promise> (*)(
+    Local<Context> context, Local<Promise> promise, Local<Object> tag);
+
 }  // namespace v8
 
 #endif  // INCLUDE_V8_ISOLATE_CALLBACKS_H_
diff --git a/include/v8-isolate.h b/include/v8-isolate.h
index f929f13a4de8ffb5b1f1222aa5034d186a29963e..2346df282c5ec8661924b008aefb2f1854e4d54a 100644
--- a/include/v8-isolate.h
+++ b/include/v8-isolate.h
@@ -1873,6 +1873,9 @@ class V8_EXPORT Isolate {
    */
   uint64_t GetHashSeed();
 
+  class PromiseContextScope;
+  void SetPromiseCrossContextCallback(PromiseCrossContextCallback callback);
+
   Isolate() = delete;
   ~Isolate() = delete;
   Isolate(const Isolate&) = delete;
@@ -1920,6 +1923,19 @@ MaybeLocal<T> Isolate::GetDataFromSnapshotOnce(size_t index) {
   return {};
 }
 
+class Isolate::PromiseContextScope {
+ public:
+  PromiseContextScope(Isolate* isolate, v8::Local<v8::Object> tag);
+  ~PromiseContextScope();
+  PromiseContextScope(const PromiseContextScope&) = delete;
+  PromiseContextScope(PromiseContextScope&&) = delete;
+  PromiseContextScope& operator=(const PromiseContextScope&) = delete;
+  PromiseContextScope& operator=(PromiseContextScope&&) = delete;
+
+ private:
+  internal::Isolate* isolate_;
+};
+
 }  // namespace v8
 
 #endif  // INCLUDE_V8_ISOLATE_H_
diff --git a/src/api/api.cc b/src/api/api.cc
index 4689a9057392f463d50f56db4b559e719b81dda1..e7bced4320eededffbaa6bc31d3efac34b0f8471 100644
--- a/src/api/api.cc
+++ b/src/api/api.cc
@@ -12539,6 +12539,25 @@ std::string SourceLocation::ToString() const {
       .str();
 }
 
+void Isolate::SetPromiseCrossContextCallback(
+    PromiseCrossContextCallback callback) {
+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);
+  isolate->set_promise_cross_context_callback(callback);
+}
+
+Isolate::PromiseContextScope::PromiseContextScope(Isolate* isolate,
+                                                  v8::Local<v8::Object> tag)
+    : isolate_(reinterpret_cast<i::Isolate*>(isolate)) {
+  DCHECK(!isolate_->has_promise_context_tag());
+  DCHECK(!tag.IsEmpty());
+  i::Handle<i::Object> handle = Utils::OpenHandle(*tag);
+  isolate_->set_promise_context_tag(*handle);
+}
+
+Isolate::PromiseContextScope::~PromiseContextScope() {
+  isolate_->clear_promise_context_tag();
+}
+
 }  // namespace v8
 
 #ifdef ENABLE_SLOW_DCHECKS
diff --git a/src/builtins/promise-abstract-operations.tq b/src/builtins/promise-abstract-operations.tq
index f50b5b75a0f326656d73105774d5eaa4acb0e6f4..b7caf0137c5ff99d9ac990ec324a5f2c6e13b8bf 100644
--- a/src/builtins/promise-abstract-operations.tq
+++ b/src/builtins/promise-abstract-operations.tq
@@ -20,6 +20,9 @@ extern transitioning runtime PromiseResolveAfterResolved(
 
 extern transitioning runtime PromiseRejectEventFromStack(
     implicit context: Context)(JSPromise, JSAny): JSAny;
+
+extern transitioning runtime PromiseContextCheck(
+    implicit context: Context)(JSPromise): JSPromise;
 }
 
 // https://tc39.es/ecma262/#sec-promise-abstract-operations
@@ -457,12 +460,14 @@ transitioning macro PerformPromiseThenImpl(
     // PromiseReaction holding both the onFulfilled and onRejected callbacks.
     // Once the {promise} is resolved we decide on the concrete handler to
     // push onto the microtask queue.
+    const delegate = runtime::PromiseContextCheck(promise);
     const promiseReactions =
-        UnsafeCast<(Zero | PromiseReaction)>(promise.reactions_or_result);
+        UnsafeCast<(Zero | PromiseReaction)>(delegate.reactions_or_result);
 
     const reaction = NewPromiseReaction(
         promiseReactions, resultPromiseOrCapability, onFulfilled, onRejected);
-    promise.reactions_or_result = reaction;
+    delegate.reactions_or_result = reaction;
+    delegate.SetHasHandler();
   } else {
     const reactionsOrResult = promise.reactions_or_result;
     let microtask: PromiseReactionJobTask;
@@ -484,8 +489,8 @@ transitioning macro PerformPromiseThenImpl(
         }
       }
     EnqueueMicrotask(handlerContext, microtask);
+    promise.SetHasHandler();
   }
-  promise.SetHasHandler();
 }
 
 transitioning javascript builtin PerformPromiseThenFunction(
diff --git a/src/builtins/promise-constructor.tq b/src/builtins/promise-constructor.tq
index 50677631b5399453eebc6b149272431f74b1fce6..c652bd836b27805865e0a902ef9cf7c1ff254646 100644
--- a/src/builtins/promise-constructor.tq
+++ b/src/builtins/promise-constructor.tq
@@ -8,6 +8,9 @@
 namespace runtime {
 extern transitioning runtime PromiseHookInit(
     implicit context: Context)(Object, Object): JSAny;
+
+extern transitioning runtime PromiseContextInit(
+    implicit context: Context)(JSPromise): JSAny;
 }
 
 // https://tc39.es/ecma262/#sec-promise-constructor
@@ -62,6 +65,7 @@ transitioning javascript builtin PromiseConstructor(
     result = UnsafeCast<JSPromise>(
         FastNewObject(context, promiseFun, UnsafeCast<JSReceiver>(newTarget)));
     PromiseInit(result);
+    runtime::PromiseContextInit(result);
     RunAnyPromiseHookInit(result, Undefined);
   }
 
diff --git a/src/builtins/promise-misc.tq b/src/builtins/promise-misc.tq
index f3ece10afb659042fbb195a98cad8254cf1188c5..cd5261012bd9a2f16b2f3354b6c526ab3c58500f 100644
--- a/src/builtins/promise-misc.tq
+++ b/src/builtins/promise-misc.tq
@@ -55,6 +55,7 @@ macro PromiseInit(promise: JSPromise): void {
     is_silent: false,
     async_task_id: kInvalidAsyncTaskId
   });
+  promise.context_tag = kZero;
   promise_internal::ZeroOutEmbedderOffsets(promise);
 }
 
@@ -74,6 +75,7 @@ macro InnerNewJSPromise(implicit context: Context)(): JSPromise {
     is_silent: false,
     async_task_id: kInvalidAsyncTaskId
   });
+  promise.context_tag = kZero;
   return promise;
 }
 
@@ -273,6 +275,7 @@ transitioning macro NewJSPromise(implicit context: Context)(
                                  parent: Object): JSPromise {
   const instance = InnerNewJSPromise();
   PromiseInit(instance);
+  runtime::PromiseContextInit(instance);
   RunAnyPromiseHookInit(instance, parent);
   return instance;
 }
@@ -296,6 +299,7 @@ transitioning macro NewJSPromise(
   instance.reactions_or_result = result;
   instance.SetStatus(status);
   promise_internal::ZeroOutEmbedderOffsets(instance);
+  runtime::PromiseContextInit(instance);
   RunAnyPromiseHookInit(instance, Undefined);
   return instance;
 }
diff --git a/src/compiler/js-create-lowering.cc b/src/compiler/js-create-lowering.cc
index 919eb0e25a6347049d331c848921a0f78714233c..c74b887cbbf254adac8fcb443daa80406b849d9e 100644
--- a/src/compiler/js-create-lowering.cc
+++ b/src/compiler/js-create-lowering.cc
@@ -1124,10 +1124,12 @@ Reduction JSCreateLowering::ReduceJSCreatePromise(Node* node) {
           jsgraph()->EmptyFixedArrayConstant());
   a.Store(AccessBuilder::ForJSObjectOffset(JSPromise::kReactionsOrResultOffset),
           jsgraph()->ZeroConstant());
+  a.Store(AccessBuilder::ForJSObjectOffset(JSPromise::kContextTagOffset),
+          jsgraph()->ZeroConstant());
   static_assert(v8::Promise::kPending == 0);
   a.Store(AccessBuilder::ForJSObjectOffset(JSPromise::kFlagsOffset),
           jsgraph()->ZeroConstant());
-  static_assert(JSPromise::kHeaderSize == 5 * kTaggedSize);
+  static_assert(JSPromise::kHeaderSize == 6 * kTaggedSize);
   for (int offset = JSPromise::kHeaderSize;
        offset < JSPromise::kSizeWithEmbedderFields; offset += kTaggedSize) {
     a.Store(AccessBuilder::ForJSObjectOffset(offset),
diff --git a/src/diagnostics/objects-printer.cc b/src/diagnostics/objects-printer.cc
index b3caf8028784cbbc31b56d860b2fa3fb31dbd28c..a445ae0414b44f7bc89becb94d996d886bfcd447 100644
--- a/src/diagnostics/objects-printer.cc
+++ b/src/diagnostics/objects-printer.cc
@@ -971,6 +971,7 @@ void JSPromise::JSPromisePrint(std::ostream& os) {
   }
   os << "\n - has_handler: " << has_handler();
   os << "\n - is_silent: " << is_silent();
+  os << "\n - context_tag: " << Brief(context_tag());
   JSObjectPrintBody(os, *this);
 }
 
diff --git a/src/execution/isolate-inl.h b/src/execution/isolate-inl.h
index 393b3d611743c86e7760760a41bdd6a6c5216691..5e0c1c62b6168e12af1ad067cd57604c17b17ce2 100644
--- a/src/execution/isolate-inl.h
+++ b/src/execution/isolate-inl.h
@@ -133,6 +133,25 @@ bool Isolate::is_execution_terminating() {
          i::ReadOnlyRoots(this).termination_exception();
 }
 
+Tagged<Object> Isolate::promise_context_tag() { return promise_context_tag_; }
+
+bool Isolate::has_promise_context_tag() {
+  return promise_context_tag_ != ReadOnlyRoots(this).the_hole_value();
+}
+
+void Isolate::clear_promise_context_tag() {
+  set_promise_context_tag(ReadOnlyRoots(this).the_hole_value());
+}
+
+void Isolate::set_promise_context_tag(Tagged<Object> tag) {
+  promise_context_tag_ = tag;
+}
+
+void Isolate::set_promise_cross_context_callback(
+    PromiseCrossContextCallback callback) {
+  promise_cross_context_callback_ = callback;
+}
+
 #ifdef DEBUG
 Tagged<Object> Isolate::VerifyBuiltinsResult(Tagged<Object> result) {
   if (is_execution_terminating() && !v8_flags.strict_termination_checks) {
diff --git a/src/execution/isolate.cc b/src/execution/isolate.cc
index 7c1063f8bbaa9efdd6582e1a7230101e5fd06f5c..5dcd7446bed4fb70d140a9f34cbcbf0a1f630ef3 100644
--- a/src/execution/isolate.cc
+++ b/src/execution/isolate.cc
@@ -628,6 +628,8 @@ void Isolate::Iterate(RootVisitor* v, ThreadLocalTop* thread) {
                       FullObjectSlot(&thread->pending_message_));
   v->VisitRootPointer(Root::kStackRoots, nullptr,
                       FullObjectSlot(&thread->context_));
+  v->VisitRootPointer(Root::kStackRoots, nullptr,
+                      FullObjectSlot(&promise_context_tag_));
 
   for (v8::TryCatch* block = thread->try_catch_handler_; block != nullptr;
        block = block->next_) {
@@ -6003,6 +6005,7 @@ bool Isolate::Init(SnapshotData* startup_snapshot_data,
     shared_heap_object_cache_.push_back(ReadOnlyRoots(this).undefined_value());
   }
 
+  clear_promise_context_tag();
   InitializeThreadLocal();
 
   // Profiler has to be created after ThreadLocal is initialized
@@ -8174,5 +8177,40 @@ void Isolate::PrintNumberStringCacheStats(const char* comment,
   PrintF("\n");
 }
 
+class Isolate::PromiseCrossContextCallbackScope {
+ public:
+  PromiseCrossContextCallbackScope(Isolate& isolate) : isolate_(isolate) {
+    DCHECK(!isolate_.in_promise_cross_context_callback_);
+    isolate_.in_promise_cross_context_callback_ = true;
+  }
+  ~PromiseCrossContextCallbackScope() {
+    isolate_.in_promise_cross_context_callback_ = false;
+  }
+
+ private:
+  Isolate& isolate_;
+};
+
+MaybeHandle<JSPromise> Isolate::RunPromiseCrossContextCallback(
+    Handle<NativeContext> context, Handle<JSPromise> promise) {
+  if (promise_cross_context_callback_ == nullptr ||
+      in_promise_cross_context_callback_) {
+    return promise;
+  }
+  PromiseCrossContextCallbackScope callback_scope(*this);
+  CHECK(IsJSReceiver(promise->context_tag()));
+
+  Handle<JSObject> context_tag(Cast<JSObject>(promise->context_tag()), this);
+  v8::Local<v8::Promise> result;
+  API_ASSIGN_RETURN_ON_EXCEPTION_VALUE(
+      this, result,
+      promise_cross_context_callback_(Utils::ToLocal(context),
+                                      v8::Utils::ToLocal(promise),
+                                      v8::Utils::ToLocal(context_tag)),
+      MaybeHandle<JSPromise>());
+
+  return v8::Utils::OpenHandle(*result);
+}
+
 }  // namespace internal
 }  // namespace v8
diff --git a/src/execution/isolate.h b/src/execution/isolate.h
index 88062b1c255b3b567eac8690d443edbf91a1de54..d5fe657dea5df0237bee28935c230600ab26df4a 100644
--- a/src/execution/isolate.h
+++ b/src/execution/isolate.h
@@ -2414,6 +2414,15 @@ class V8_EXPORT_PRIVATE Isolate final : private HiddenFactory {
                                        v8::ExceptionContext callback_kind);
   void SetExceptionPropagationCallback(ExceptionPropagationCallback callback);
 
+  inline Tagged<Object> promise_context_tag();
+  inline bool has_promise_context_tag();
+  inline void clear_promise_context_tag();
+  inline void set_promise_context_tag(Tagged<Object> tag);
+  inline void set_promise_cross_context_callback(
+      PromiseCrossContextCallback callback);
+  MaybeHandle<JSPromise> RunPromiseCrossContextCallback(
+      Handle<NativeContext> context, Handle<JSPromise> promise);
+
 #ifdef V8_ENABLE_WASM_SIMD256_REVEC
   void set_wasm_revec_verifier_for_test(
       compiler::turboshaft::WasmRevecVerifier* verifier) {
@@ -2941,6 +2950,12 @@ class V8_EXPORT_PRIVATE Isolate final : private HiddenFactory {
 
   bool is_frozen_ = false;
 
+  Tagged<Object> promise_context_tag_;
+  PromiseCrossContextCallback promise_cross_context_callback_;
+  bool in_promise_cross_context_callback_ = false;
+
+  class PromiseCrossContextCallbackScope;
+
   friend class GlobalSafepoint;
   friend class heap::HeapTester;
   friend class IsolateForPointerCompression;
@@ -2948,6 +2963,7 @@ class V8_EXPORT_PRIVATE Isolate final : private HiddenFactory {
   friend class IsolateGroup;
   friend class TestSerializer;
   friend class SharedHeapNoClientsTest;
+  friend class PromiseCrossContextCallbackScope;
 };
 
 // The current entered Isolate and its thread data. Do not access these
diff --git a/src/heap/factory.cc b/src/heap/factory.cc
index d863d8c3bf97b56e986f4b3af65edb44940a6b91..d5df47f98082f74f5709a1b62c856f148540959f 100644
--- a/src/heap/factory.cc
+++ b/src/heap/factory.cc
@@ -4649,6 +4649,12 @@ Handle<JSPromise> Factory::NewJSPromiseWithoutHook() {
   DisallowGarbageCollection no_gc;
   Tagged<JSPromise> raw = *promise;
   raw->set_reactions_or_result(Smi::zero(), SKIP_WRITE_BARRIER);
+  if (!isolate()->has_promise_context_tag()) {
+    raw->set_context_tag(Smi::zero(), SKIP_WRITE_BARRIER);
+  } else {
+    raw->set_context_tag(isolate()->promise_context_tag());
+  }
+
   raw->set_flags(0);
   // TODO(v8) remove once embedder data slots are always zero-initialized.
   InitEmbedderFields(*promise, Smi::zero());
diff --git a/src/maglev/maglev-graph-builder.cc b/src/maglev/maglev-graph-builder.cc
index 7180c79b823ac653303787bc539f862fdf9be949..48bc489d85e497d8cb9c3ae49a5fe7f92ed49151 100644
--- a/src/maglev/maglev-graph-builder.cc
+++ b/src/maglev/maglev-graph-builder.cc
@@ -14615,9 +14615,10 @@ VirtualObject* MaglevGraphBuilder::CreateJSPromiseObject() {
   vobj->set(JSPromise::kElementsOffset,
             GetRootConstant(RootIndex::kEmptyFixedArray));
   vobj->set(JSPromise::kReactionsOrResultOffset, GetSmiConstant(0));
+  vobj->set(JSPromise::kContextTagOffset, GetSmiConstant(0));
   static_assert(v8::Promise::kPending == 0);
   vobj->set(JSPromise::kFlagsOffset, GetSmiConstant(0));
-  static_assert(JSPromise::kHeaderSize == 5 * kTaggedSize);
+  static_assert(JSPromise::kHeaderSize == 6 * kTaggedSize);
   for (int offset = JSPromise::kHeaderSize;
        offset < JSPromise::kSizeWithEmbedderFields; offset += kTaggedSize) {
     vobj->set(offset, GetSmiConstant(0));
diff --git a/src/objects/js-promise.tq b/src/objects/js-promise.tq
index 93a4a34f9f1f7fad40611d4b9432aaf944c9fbae..188619ea64c9e307f014898e4023ce796c52c7e2 100644
--- a/src/objects/js-promise.tq
+++ b/src/objects/js-promise.tq
@@ -32,6 +32,7 @@ extern class JSPromise extends JSObjectWithEmbedderSlots {
   // Smi 0 terminated list of PromiseReaction objects in case the JSPromise was
   // not settled yet, otherwise the result.
   reactions_or_result: Zero|PromiseReaction|JSAny;
+  context_tag: Object;
   flags: SmiTagged<JSPromiseFlags>;
 }
 
diff --git a/src/objects/value-serializer.cc b/src/objects/value-serializer.cc
index 6294e46b2a1d7b6b9e9fd57706d5cb4d72295f53..1eccb0c8c1af6d4abcb395447bf75dc4272034c4 100644
--- a/src/objects/value-serializer.cc
+++ b/src/objects/value-serializer.cc
@@ -1113,8 +1113,8 @@ Maybe<bool> ValueSerializer::WriteJSArrayBufferView(
   WriteVarint(static_cast<uint32_t>(view->byte_length()));
   if (version_ >= 14) {
     uint32_t flags =
-      JSArrayBufferViewIsLengthTracking::encode(view->is_length_tracking()) |
-      JSArrayBufferViewIsBackedByRab::encode(view->is_backed_by_rab());
+        JSArrayBufferViewIsLengthTracking::encode(view->is_length_tracking()) |
+        JSArrayBufferViewIsBackedByRab::encode(view->is_backed_by_rab());
     WriteVarint(flags);
   }
   return ThrowIfOutOfMemory();
diff --git a/src/profiler/heap-snapshot-generator.cc b/src/profiler/heap-snapshot-generator.cc
index 44f4535a8a358275f534cb854788f6bdeefe7688..a165cb8e88d41073d6a4cbc75c9edb39d5045879 100644
--- a/src/profiler/heap-snapshot-generator.cc
+++ b/src/profiler/heap-snapshot-generator.cc
@@ -2117,6 +2117,8 @@ void V8HeapExplorer::ExtractJSPromiseReferences(HeapEntry* entry,
   SetInternalReference(entry, "reactions_or_result",
                        promise->reactions_or_result(),
                        JSPromise::kReactionsOrResultOffset);
+  SetInternalReference(entry, "context_tag", promise->context_tag(),
+                       JSPromise::kContextTagOffset);
 }
 
 void V8HeapExplorer::ExtractJSGeneratorObjectReferences(
diff --git a/src/runtime/runtime-promise.cc b/src/runtime/runtime-promise.cc
index 262b9aa5aa6974a4628d0679ada91aff76567906..9730731cd42c0ea6ce0d96ec250a11fcc434ebf8 100644
--- a/src/runtime/runtime-promise.cc
+++ b/src/runtime/runtime-promise.cc
@@ -216,5 +216,41 @@ RUNTIME_FUNCTION(Runtime_ConstructSuppressedError) {
   return *result;
 }
 
+RUNTIME_FUNCTION(Runtime_PromiseContextInit) {
+  HandleScope scope(isolate);
+  DCHECK_EQ(1, args.length());
+  if (!isolate->has_promise_context_tag()) {
+    args.at<JSPromise>(0)->set_context_tag(Smi::zero());
+  } else {
+    CHECK(!IsUndefined(isolate->promise_context_tag()));
+    args.at<JSPromise>(0)->set_context_tag(isolate->promise_context_tag());
+  }
+  return ReadOnlyRoots(isolate).undefined_value();
+}
+
+RUNTIME_FUNCTION(Runtime_PromiseContextCheck) {
+  HandleScope scope(isolate);
+  DCHECK_EQ(1, args.length());
+
+  Handle<JSPromise> promise = args.at<JSPromise>(0);
+
+  // If promise.context_tag() is strict equal to isolate.promise_context_tag(),
+  // or if the promise being checked does not have a context tag, we'll just
+  // return promise directly.
+  Tagged<Object> obj = promise->context_tag();
+  if (obj == Smi::zero() || obj == isolate->promise_context_tag()) {
+    return *promise;
+  }
+
+  // Otherwise we defer to the PromiseCrossContextCallback. If the callback
+  // has not been set, then it should just return the same promise back here.
+  Handle<JSPromise> result;
+  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, result,
+                                     isolate->RunPromiseCrossContextCallback(
+                                         isolate->native_context(), promise));
+
+  return *result;
+}
+
 }  // namespace internal
 }  // namespace v8
diff --git a/src/runtime/runtime.h b/src/runtime/runtime.h
index 7fcf07139db9f78f58371c81828d4328d5d13536..ff2adcf6ea58398b21f16672b491f6860eee1ff3 100644
--- a/src/runtime/runtime.h
+++ b/src/runtime/runtime.h
@@ -424,20 +424,22 @@ constexpr bool CanTriggerGC(T... properties) {
   F(StrictNotEqual, 2, 1)                  \
   F(ReferenceEqual, 2, 1)
 
-#define FOR_EACH_INTRINSIC_PROMISE(F, I) \
-  F(EnqueueMicrotask, 1, 1)              \
-  F(PromiseHookAfter, 1, 1)              \
-  F(PromiseHookBefore, 1, 1)             \
-  F(PromiseHookInit, 2, 1)               \
-  F(PromiseRejectEventFromStack, 2, 1)   \
-  F(PromiseRevokeReject, 1, 1)           \
-  F(RejectPromise, 3, 1)                 \
-  F(ResolvePromise, 2, 1)                \
-  F(PromiseRejectAfterResolved, 2, 1)    \
-  F(PromiseResolveAfterResolved, 2, 1)   \
-  F(ConstructSuppressedError, 3, 1)      \
-  F(ConstructAggregateErrorHelper, 4, 1) \
-  F(ConstructInternalAggregateErrorHelper, -1 /* <= 5*/, 1)
+#define FOR_EACH_INTRINSIC_PROMISE(F, I)                    \
+  F(EnqueueMicrotask, 1, 1)                                 \
+  F(PromiseHookAfter, 1, 1)                                 \
+  F(PromiseHookBefore, 1, 1)                                \
+  F(PromiseHookInit, 2, 1)                                  \
+  F(PromiseRejectEventFromStack, 2, 1)                      \
+  F(PromiseRevokeReject, 1, 1)                              \
+  F(RejectPromise, 3, 1)                                    \
+  F(ResolvePromise, 2, 1)                                   \
+  F(PromiseRejectAfterResolved, 2, 1)                       \
+  F(PromiseResolveAfterResolved, 2, 1)                      \
+  F(ConstructSuppressedError, 3, 1)                         \
+  F(ConstructAggregateErrorHelper, 4, 1)                    \
+  F(ConstructInternalAggregateErrorHelper, -1 /* <= 5*/, 1) \
+  F(PromiseContextInit, 1, 1)                               \
+  F(PromiseContextCheck, 1, 1)
 
 #define FOR_EACH_INTRINSIC_PROXY(F, I) \
   F(CheckProxyGetSetTrapResult, 2, 1)  \
