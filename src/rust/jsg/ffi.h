#pragma once

#include <workerd/jsg/modules.capnp.h>

#include <cppgc/allocation.h>
#include <cppgc/garbage-collected.h>
#include <cppgc/member.h>
#include <cppgc/name-provider.h>
#include <cppgc/persistent.h>
#include <cppgc/visitor.h>
#include <kj-rs/kj-rs.h>
#include <rust/cxx.h>
#include <v8-cppgc.h>
#include <v8.h>

#include <kj/function.h>
#include <kj/memory.h>

// Forward declarations needed by v8.rs.h
namespace workerd::rust::jsg {
using Isolate = v8::Isolate;
using FunctionCallbackInfo = v8::FunctionCallbackInfo<v8::Value>;
struct ModuleRegistry;
struct Local;
struct Global;
struct Realm;
struct TracedReference;
struct CppgcVisitor;
enum class ExceptionType : ::std::uint8_t;
// ModuleType enum is generated by CXX in v8.rs.h - forward declare it here
enum class ModuleType : ::std::uint8_t;
using ModuleCallback = ::rust::Fn<Local(Isolate*)>;

// A cppgc-managed wrapper that allows Rust objects to live on V8's garbage-collected heap.
//
// We need this because cppgc can only trace C++ classes that inherit from GarbageCollected.
// RustResource acts as a bridge: cppgc sees a normal C++ GC object, but the actual data
// is a Rust object stored in cppgc's AdditionalBytes region right after this header.
//
// The data[] field stores a Rust fat pointer (data + vtable) to `dyn GarbageCollected`.
// This lets us call back into Rust for tracing and destruction without knowing the
// concrete type at compile time. When cppgc traces this object, we invoke the Rust
// trace method through the vtable. When cppgc collects it, the destructor calls Rust's drop.
class RustResource: public cppgc::GarbageCollected<RustResource>, public cppgc::NameProvider {
 public:
  ~RustResource();
  void Trace(cppgc::Visitor* visitor) const;
  const char* GetHumanReadableName() const final;

  uintptr_t data[2];  // Rust fat pointer: [data_ptr, vtable_ptr]
};

// Used when allocating Rust objects that require 16-byte alignment.
// cppgc's maximum supported alignment is 16 bytes. When the Rust type's alignment
// exceeds 8 bytes, we use this class to ensure the cppgc allocation is 16-byte aligned.
class alignas(16) RustResourceAlign16: public RustResource {};

using CppgcPersistent = cppgc::Persistent<RustResource>;
using CppgcWeakPersistent = cppgc::WeakPersistent<RustResource>;
using CppgcMember = cppgc::Member<RustResource>;
using CppgcWeakMember = cppgc::WeakMember<RustResource>;

struct ResourceDescriptor;

// Function declarations
void local_drop(Local value);
Local local_clone(const Local& value);
Global local_to_global(Isolate* isolate, Local value);
Local local_new_number(Isolate* isolate, double value);
Local local_new_string(Isolate* isolate, ::rust::Str value);
Local local_new_boolean(Isolate* isolate, bool value);
Local local_new_object(Isolate* isolate);
Local local_new_null(Isolate* isolate);
Local local_new_undefined(Isolate* isolate);
Local local_new_array(Isolate* isolate, size_t length);
Local local_new_uint8_array(Isolate* isolate, const uint8_t* data, size_t length);
Local local_new_uint16_array(Isolate* isolate, const uint16_t* data, size_t length);
Local local_new_uint32_array(Isolate* isolate, const uint32_t* data, size_t length);
Local local_new_int8_array(Isolate* isolate, const int8_t* data, size_t length);
Local local_new_int16_array(Isolate* isolate, const int16_t* data, size_t length);
Local local_new_int32_array(Isolate* isolate, const int32_t* data, size_t length);
Local local_new_float32_array(Isolate* isolate, const float* data, size_t length);
Local local_new_float64_array(Isolate* isolate, const double* data, size_t length);
Local local_new_bigint64_array(Isolate* isolate, const int64_t* data, size_t length);
Local local_new_biguint64_array(Isolate* isolate, const uint64_t* data, size_t length);
bool local_eq(const Local& lhs, const Local& rhs);
bool local_has_value(const Local& val);
bool local_is_string(const Local& val);
bool local_is_boolean(const Local& val);
bool local_is_number(const Local& val);
bool local_is_null(const Local& val);
bool local_is_undefined(const Local& val);
bool local_is_null_or_undefined(const Local& val);
bool local_is_object(const Local& val);
bool local_is_native_error(const Local& val);
bool local_is_array(const Local& val);
bool local_is_uint8_array(const Local& val);
bool local_is_uint16_array(const Local& val);
bool local_is_uint32_array(const Local& val);
bool local_is_int8_array(const Local& val);
bool local_is_int16_array(const Local& val);
bool local_is_int32_array(const Local& val);
bool local_is_float32_array(const Local& val);
bool local_is_float64_array(const Local& val);
bool local_is_bigint64_array(const Local& val);
bool local_is_biguint64_array(const Local& val);
bool local_is_array_buffer(const Local& val);
bool local_is_array_buffer_view(const Local& val);
::rust::String local_type_of(Isolate* isolate, const Local& val);

// Local<Object>
void local_object_set_property(Isolate* isolate, Local& object, ::rust::Str key, Local value);
bool local_object_has_property(Isolate* isolate, const Local& object, ::rust::Str key);
kj::Maybe<Local> local_object_get_property(Isolate* isolate, const Local& object, ::rust::Str key);

// Local<Array>
uint32_t local_array_length(Isolate* isolate, const Local& array);
Local local_array_get(Isolate* isolate, const Local& array, uint32_t index);
void local_array_set(Isolate* isolate, Local& array, uint32_t index, Local value);
::rust::Vec<Global> local_array_iterate(Isolate* isolate, Local value);

// Local<TypedArray>
size_t local_typed_array_length(Isolate* isolate, const Local& array);
uint8_t local_uint8_array_get(Isolate* isolate, const Local& array, size_t index);
uint16_t local_uint16_array_get(Isolate* isolate, const Local& array, size_t index);
uint32_t local_uint32_array_get(Isolate* isolate, const Local& array, size_t index);
int8_t local_int8_array_get(Isolate* isolate, const Local& array, size_t index);
int16_t local_int16_array_get(Isolate* isolate, const Local& array, size_t index);
int32_t local_int32_array_get(Isolate* isolate, const Local& array, size_t index);
float local_float32_array_get(Isolate* isolate, const Local& array, size_t index);
double local_float64_array_get(Isolate* isolate, const Local& array, size_t index);
int64_t local_bigint64_array_get(Isolate* isolate, const Local& array, size_t index);
uint64_t local_biguint64_array_get(Isolate* isolate, const Local& array, size_t index);

// Global<T>
void global_reset(Global* value);
Global global_clone(const Global& value);
Local global_to_local(Isolate* isolate, const Global& value);

// TracedReference (cppgc/Oilpan)
TracedReference traced_reference_from_local(Isolate* isolate, Local value);
Local traced_reference_to_local(Isolate* isolate, const TracedReference& value);
void traced_reference_reset(TracedReference* value);
bool traced_reference_is_empty(const TracedReference& value);

// Wrappers
Local wrap_resource(Isolate* isolate, size_t resource, const Global& tmpl);

// Unwrappers
::rust::String unwrap_string(Isolate* isolate, Local value);
bool unwrap_boolean(Isolate* isolate, Local value);
double unwrap_number(Isolate* isolate, Local value);
size_t unwrap_resource(Isolate* isolate, Local value);
::rust::Vec<uint8_t> unwrap_uint8_array(Isolate* isolate, Local value);
::rust::Vec<uint16_t> unwrap_uint16_array(Isolate* isolate, Local value);
::rust::Vec<uint32_t> unwrap_uint32_array(Isolate* isolate, Local value);
::rust::Vec<int8_t> unwrap_int8_array(Isolate* isolate, Local value);
::rust::Vec<int16_t> unwrap_int16_array(Isolate* isolate, Local value);
::rust::Vec<int32_t> unwrap_int32_array(Isolate* isolate, Local value);
::rust::Vec<float> unwrap_float32_array(Isolate* isolate, Local value);
::rust::Vec<double> unwrap_float64_array(Isolate* isolate, Local value);
::rust::Vec<int64_t> unwrap_bigint64_array(Isolate* isolate, Local value);
::rust::Vec<uint64_t> unwrap_biguint64_array(Isolate* isolate, Local value);

// FunctionCallbackInfo
Isolate* fci_get_isolate(FunctionCallbackInfo* args);
Local fci_get_this(FunctionCallbackInfo* args);
size_t fci_get_length(FunctionCallbackInfo* args);
Local fci_get_arg(FunctionCallbackInfo* args, size_t index);
void fci_set_return_value(FunctionCallbackInfo* args, Local value);

struct ModuleRegistry {
  virtual ~ModuleRegistry() = default;
  virtual void addBuiltinModule(
      ::rust::Str specifier, ModuleCallback moduleCallback, ModuleType moduleType) = 0;
};

inline void register_add_builtin_module(ModuleRegistry& registry,
    ::rust::Str specifier,
    ModuleCallback callback,
    ModuleType moduleType) {
  registry.addBuiltinModule(specifier, kj::mv(callback), moduleType);
}

Global create_resource_template(Isolate* isolate, const ResourceDescriptor& descriptor);

// Realm
Realm* realm_from_isolate(Isolate* isolate);

// Errors
Local exception_create(Isolate* isolate, ExceptionType exception_type, ::rust::Str message);

// Isolate
void isolate_throw_exception(Isolate* isolate, Local exception);
void isolate_throw_error(Isolate* isolate, ::rust::Str message);
bool isolate_is_locked(Isolate* isolate);

// Oilpan
RustResource* cppgc_make_garbage_collected(Isolate* isolate, size_t size, size_t alignment);
size_t cppgc_rust_resource_size();
uintptr_t* cppgc_rust_resource_data(RustResource* resource);
const uintptr_t* cppgc_rust_resource_data_const(const RustResource* resource);
void cppgc_visitor_trace(CppgcVisitor* visitor, const TracedReference& handle);
void cppgc_visitor_trace_member(CppgcVisitor* visitor, size_t member_storage);
void cppgc_visitor_trace_weak_member(CppgcVisitor* visitor, size_t weak_member_storage);

// cppgc - persistent
size_t cppgc_persistent_size();
void cppgc_persistent_construct(size_t storage, RustResource* resource);
void cppgc_persistent_destruct(size_t storage);
RustResource* cppgc_persistent_get(size_t storage);
void cppgc_persistent_assign(size_t storage, RustResource* resource);

// cppgc - weak persistent
size_t cppgc_weak_persistent_size();
void cppgc_weak_persistent_construct(size_t storage, RustResource* resource);
void cppgc_weak_persistent_destruct(size_t storage);
RustResource* cppgc_weak_persistent_get(size_t storage);
void cppgc_weak_persistent_assign(size_t storage, RustResource* resource);

// cppgc - member
size_t cppgc_member_size();
void cppgc_member_construct(size_t storage, RustResource* resource);
void cppgc_member_destruct(size_t storage);
RustResource* cppgc_member_get(size_t storage);
void cppgc_member_assign(size_t storage, RustResource* resource);

// cppgc - weak member
size_t cppgc_weak_member_size();
void cppgc_weak_member_construct(size_t storage, RustResource* resource);
void cppgc_weak_member_destruct(size_t storage);
RustResource* cppgc_weak_member_get(size_t storage);
void cppgc_weak_member_assign(size_t storage, RustResource* resource);

}  // namespace workerd::rust::jsg
