using Workerd = import "/workerd/workerd.capnp";

const unitTests :Workerd.Config = (
  services = [
    ( name = "new-module-registry-test",
      worker = (
        modules = [
          (name = "worker", esModule = embed "new-module-registry-test.js"),
          (name = "foo", esModule = "export const foo = 1; export default 2; export const bar = import.meta.url"),
          (name = "bar", esModule = "export const foo = 1; export default 2;"),
          (name = "node:fs", esModule = "export default 'abc'"),

          # Intentionally bad module to test error handling.
          # Evaluation will error because i/o is not permitted at top-level scope.
          (name = "bad", esModule = "export default 1; setTimeout(() => {}, 10)"),

          # Ensure that async context is propagated into a dynamic import.
          (name = "als", esModule = "export default globalThis.als.getStore()"),

          # Import attributes are not supported currently
          (name = "ia", esModule = "import * as def from 'foo' with { a: 'test' }"),

          # Errors on ESM eval should be reported properly in both static and
          # dynamic imports.
          (name = "esm-error", esModule = "export default 1; throw new Error('boom');"),
          (name = "esm-error-dynamic", esModule = "export * as d from 'esm-error'"),

          # CommonJS modules work
          (name = "cjs1",
           namedExports = ["foo", "bar"],
           commonJsModule = "module.exports = { foo: 1, bar: 2, filename: __filename, dirname: __dirname, assert: require('assert') }"),
          (name = "cjs2", commonJsModule = "module.exports = require('cjs1')"),
          (name = "cjs3", commonJsModule = "throw new Error('boom')"),
          # Intentional circular dependency
          (name = "cjs4", commonJsModule = "module.exports = require('cjs5')"),
          (name = "cjs5", commonJsModule = "module.exports = require('cjs4')"),

          # Other module types work
          (name = "text", text = "abc"),
          (name = "data", data = "abcdef"),
          (name = "json", json = "{ \"foo\": 1 }"),
          (name = "invalid-json", json = "1n"),

          (name = "wasm", wasm = embed "test.wasm"),

          (name = "complex", esModule = "import * as abc from '././././././complex/complex2'; export { abc };"),
          (name = "complex/complex2", esModule = "import * as def from '/bundle/complex/complex3'; export { def }; export const foo = 1;"),
          (name = "complex/complex3", esModule = "export const bar = 2;"),

          # When the user bundle name begins with a slash, it is stripped before
          # processing, ensuring that the module is still processed relative to
          # the bundle base URL. Query strings and fragments are ignored.
          (name = "/%61bc?abc#123", esModule = "export default import.meta.url"),

          # A module name should not be able to escape the bundle base URL,
          # and leading/trailing whitespace should be trimmed.
          (name = "    ..//////outside    ", esModule = "export default 1;"),

          # Should resolve to "abc123" after normalization.
          (name = "/foo/../bar/../../../../////abc123", esModule = "export default 1;"),

          # It should be possible to have a module whose name is a valid URL.
          (name = "https://example.com/mod", esModule = "export default 'example';"),

          # Percent-encoded characters in the path should be normalized, and absolute
          # file URLs are accepted as long as they are under the bundle base URL.
          (name = "file:///bundl%65/should/b%65/ok", esModule = "export default 1;"),

          # Unicode characters in the path should be handled as UTF-8 and supported.
          (name = "部品", esModule = "export default 1;"),
        ],
        compatibilityDate = "2025-05-01",
        compatibilityFlags = [
          "nodejs_compat",
          "new_module_registry",
          "experimental",
        ],
      ),
    ),
  ],
);
