import * as dgram from 'node:dgram';
import { strictEqual, deepStrictEqual, throws, ok } from 'node:assert';

export const dgramTest = {
  test() {
    // Note: test was generated by claude with manual tweaks

    // Test that required exports exist
    strictEqual(typeof dgram.createSocket, 'function');
    strictEqual(typeof dgram.Socket, 'function');

    // Test createSocket with string type - should return Socket instance
    const socket1 = dgram.createSocket('udp4');
    ok(socket1 instanceof dgram.Socket);

    const socket2 = dgram.createSocket('udp6');
    ok(socket2 instanceof dgram.Socket);

    // Test createSocket with object type - should return Socket instance
    const socket3 = dgram.createSocket({ type: 'udp4' });
    ok(socket3 instanceof dgram.Socket);

    const socket4 = dgram.createSocket({ type: 'udp6' });
    ok(socket4 instanceof dgram.Socket);

    // Test createSocket with callback - should return Socket instance and register callback
    const callback1 = () => {};
    const socket5 = dgram.createSocket('udp4', callback1);
    ok(socket5 instanceof dgram.Socket);

    const callback2 = () => {};
    const socket6 = dgram.createSocket({ type: 'udp4' }, callback2);
    ok(socket6 instanceof dgram.Socket);

    // Test createSocket argument validation - type must be valid object
    throws(
      () => {
        dgram.createSocket(null);
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    throws(
      () => {
        dgram.createSocket(123);
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    throws(
      () => {
        dgram.createSocket([]);
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    // Test createSocket callback validation - must be function if provided
    throws(
      () => {
        dgram.createSocket('udp4', 'invalid');
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    throws(
      () => {
        dgram.createSocket('udp4', 123);
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    throws(
      () => {
        dgram.createSocket('udp4', {});
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    // Test Socket constructor with string type - should return Socket instance
    const socket7 = new dgram.Socket('udp4');
    ok(socket7 instanceof dgram.Socket);

    const socket8 = new dgram.Socket('udp6');
    ok(socket8 instanceof dgram.Socket);

    // Test Socket constructor with object type - should return Socket instance
    const socket9 = new dgram.Socket({ type: 'udp4' });
    ok(socket9 instanceof dgram.Socket);

    // Test Socket constructor with callback - should return Socket instance and register callback
    const callback3 = () => {};
    const socket10 = new dgram.Socket('udp4', callback3);
    ok(socket10 instanceof dgram.Socket);

    // Test Socket constructor argument validation
    throws(
      () => {
        new dgram.Socket(null);
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    throws(
      () => {
        new dgram.Socket(123);
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    throws(
      () => {
        new dgram.Socket('udp4', 'invalid');
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    // Test Socket prototype methods exist
    strictEqual(typeof dgram.Socket.prototype.bind, 'function');
    strictEqual(typeof dgram.Socket.prototype.connect, 'function');
    strictEqual(typeof dgram.Socket.prototype.disconnect, 'function');
    strictEqual(typeof dgram.Socket.prototype.send, 'function');
    strictEqual(typeof dgram.Socket.prototype.sendto, 'function');
    strictEqual(typeof dgram.Socket.prototype.close, 'function');
    strictEqual(typeof dgram.Socket.prototype.address, 'function');
    strictEqual(typeof dgram.Socket.prototype.remoteAddress, 'function');
    strictEqual(typeof dgram.Socket.prototype.setBroadcast, 'function');
    strictEqual(typeof dgram.Socket.prototype.setTTL, 'function');
    strictEqual(typeof dgram.Socket.prototype.setMulticastTTL, 'function');
    strictEqual(typeof dgram.Socket.prototype.setMulticastLoopback, 'function');
    strictEqual(
      typeof dgram.Socket.prototype.setMulticastInterface,
      'function'
    );
    strictEqual(typeof dgram.Socket.prototype.addMembership, 'function');
    strictEqual(typeof dgram.Socket.prototype.dropMembership, 'function');
    strictEqual(
      typeof dgram.Socket.prototype.addSourceSpecificMembership,
      'function'
    );
    strictEqual(
      typeof dgram.Socket.prototype.dropSourceSpecificMembership,
      'function'
    );
    strictEqual(typeof dgram.Socket.prototype.ref, 'function');
    strictEqual(typeof dgram.Socket.prototype.unref, 'function');
    strictEqual(typeof dgram.Socket.prototype.setRecvBufferSize, 'function');
    strictEqual(typeof dgram.Socket.prototype.setSendBufferSize, 'function');
    strictEqual(typeof dgram.Socket.prototype.getRecvBufferSize, 'function');
    strictEqual(typeof dgram.Socket.prototype.getSendBufferSize, 'function');
    strictEqual(typeof dgram.Socket.prototype.getSendQueueSize, 'function');
    strictEqual(typeof dgram.Socket.prototype.getSendQueueCount, 'function');

    // Test methods that are chainable (return this)
    const testSocket = dgram.createSocket('udp4');

    const bindResult = testSocket.bind();
    strictEqual(bindResult, testSocket);

    const bindResult2 = testSocket.bind(8080);
    strictEqual(bindResult2, testSocket);

    const bindResult3 = testSocket.bind(8080, 'localhost');
    strictEqual(bindResult3, testSocket);

    // connect is a no-op, should not throw
    testSocket.connect(8080);
    testSocket.connect(8080, 'localhost');

    // disconnect is a no-op, should not throw
    testSocket.disconnect();

    // send is a no-op, should not throw
    testSocket.send(Buffer.from('test'));
    testSocket.send('test', 8080, 'localhost');

    // sendto is a no-op, should not throw
    testSocket.sendto(Buffer.from('test'));

    // close is chainable, should not throw
    const closeResult = testSocket.close();
    strictEqual(closeResult, testSocket);

    const closeResult2 = testSocket.close(() => {});
    strictEqual(closeResult2, testSocket);

    // Test methods that return empty objects
    const testSocket2 = dgram.createSocket('udp4');

    const address = testSocket2.address();
    strictEqual(typeof address, 'object');
    deepStrictEqual(address, {});

    const remoteAddress = testSocket2.remoteAddress();
    strictEqual(typeof remoteAddress, 'object');
    deepStrictEqual(remoteAddress, {});

    // Test methods that are no-ops (should not throw)
    const testSocket3 = dgram.createSocket('udp4');

    testSocket3.setBroadcast(true);
    testSocket3.setBroadcast(false);
    testSocket3.setBroadcast('invalid');

    testSocket3.setTTL(64);
    testSocket3.setTTL('invalid');

    testSocket3.setMulticastTTL(1);
    testSocket3.setMulticastTTL('invalid');

    testSocket3.setMulticastLoopback(true);
    testSocket3.setMulticastLoopback(false);
    testSocket3.setMulticastLoopback('invalid');

    testSocket3.setMulticastInterface('127.0.0.1');
    testSocket3.setMulticastInterface('invalid');

    testSocket3.addMembership('224.0.0.1');
    testSocket3.addMembership('224.0.0.1', '127.0.0.1');
    testSocket3.addMembership('invalid', 'invalid');

    testSocket3.dropMembership('224.0.0.1');
    testSocket3.dropMembership('224.0.0.1', '127.0.0.1');
    testSocket3.dropMembership('invalid', 'invalid');

    testSocket3.addSourceSpecificMembership('127.0.0.1', '224.0.0.1');
    testSocket3.addSourceSpecificMembership(
      '127.0.0.1',
      '224.0.0.1',
      '127.0.0.1'
    );
    testSocket3.addSourceSpecificMembership('invalid', 'invalid', 'invalid');

    testSocket3.dropSourceSpecificMembership('127.0.0.1', '224.0.0.1');
    testSocket3.dropSourceSpecificMembership(
      '127.0.0.1',
      '224.0.0.1',
      '127.0.0.1'
    );
    testSocket3.dropSourceSpecificMembership('invalid', 'invalid', 'invalid');

    testSocket3.setRecvBufferSize(1024);
    testSocket3.setRecvBufferSize('invalid');

    testSocket3.setSendBufferSize(1024);
    testSocket3.setSendBufferSize('invalid');

    // Test methods that return this
    const testSocket4 = dgram.createSocket('udp4');

    const refResult = testSocket4.ref();
    strictEqual(refResult, testSocket4);

    const unrefResult = testSocket4.unref();
    strictEqual(unrefResult, testSocket4);

    // Test methods that return numbers
    const testSocket5 = dgram.createSocket('udp4');

    const recvBufferSize = testSocket5.getRecvBufferSize();
    strictEqual(recvBufferSize, 0);

    const sendBufferSize = testSocket5.getSendBufferSize();
    strictEqual(sendBufferSize, 0);

    const sendQueueSize = testSocket5.getSendQueueSize();
    strictEqual(sendQueueSize, 0);

    const sendQueueCount = testSocket5.getSendQueueCount();
    strictEqual(sendQueueCount, 0);

    // Test Symbol.asyncDispose method exists and is a no-op
    strictEqual(typeof dgram.Socket.prototype[Symbol.asyncDispose], 'function');

    // Test asyncDispose returns a Promise
    const testSocket6 = dgram.createSocket('udp4');
    const disposeResult = testSocket6[Symbol.asyncDispose]();
    ok(disposeResult instanceof Promise);

    // Verify the promise resolves to undefined
    disposeResult.then((result) => {
      strictEqual(result, undefined);
    });

    // Test default export
    strictEqual(typeof dgram.default, 'object');
    strictEqual(dgram.default.createSocket, dgram.createSocket);
    strictEqual(dgram.default.Socket, dgram.Socket);

    // Test createSocket with more complex options
    const socket11 = dgram.createSocket({
      type: 'udp4',
      reuseAddr: true,
      ipv6Only: false,
      recvBufferSize: 1024,
      sendBufferSize: 1024,
    });
    ok(socket11 instanceof dgram.Socket);

    // Test edge cases with validation
    throws(
      () => {
        dgram.createSocket({ type: 'udp4' }, null);
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    // Test that Socket extends EventEmitter properly
    // Note: We can't test this directly since constructor throws, but we can check prototype chain
    const EventEmitter = dgram.Socket.prototype.constructor;
    strictEqual(typeof EventEmitter, 'function');
  },
};
