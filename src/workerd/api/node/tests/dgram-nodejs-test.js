import * as dgram from 'node:dgram';
import { strictEqual, deepStrictEqual, throws, ok } from 'node:assert';

export const dgramTest = {
  test() {
    // Note: test was generated by claude with manual tweaks

    // Test that required exports exist
    strictEqual(typeof dgram.createSocket, 'function');
    strictEqual(typeof dgram.Socket, 'function');

    // Test createSocket with string type - should throw ERR_METHOD_NOT_IMPLEMENTED after validation
    throws(
      () => {
        dgram.createSocket('udp4');
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    throws(
      () => {
        dgram.createSocket('udp6');
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    // Test createSocket with object type - should throw ERR_METHOD_NOT_IMPLEMENTED after validation
    throws(
      () => {
        dgram.createSocket({ type: 'udp4' });
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    throws(
      () => {
        dgram.createSocket({ type: 'udp6' });
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    // Test createSocket with callback - should throw ERR_METHOD_NOT_IMPLEMENTED after validation
    throws(
      () => {
        dgram.createSocket('udp4', () => {});
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    throws(
      () => {
        dgram.createSocket({ type: 'udp4' }, () => {});
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    // Test createSocket argument validation - type must be valid object
    throws(
      () => {
        dgram.createSocket(null);
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    throws(
      () => {
        dgram.createSocket(123);
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    throws(
      () => {
        dgram.createSocket([]);
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    // Test createSocket callback validation - must be function if provided
    throws(
      () => {
        dgram.createSocket('udp4', 'invalid');
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    throws(
      () => {
        dgram.createSocket('udp4', 123);
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    throws(
      () => {
        dgram.createSocket('udp4', {});
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    // Test Socket constructor with string type - should throw ERR_METHOD_NOT_IMPLEMENTED after validation
    throws(
      () => {
        new dgram.Socket('udp4');
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    throws(
      () => {
        new dgram.Socket('udp6');
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    // Test Socket constructor with object type - should throw ERR_METHOD_NOT_IMPLEMENTED after validation
    throws(
      () => {
        new dgram.Socket({ type: 'udp4' });
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    // Test Socket constructor with callback - should throw ERR_METHOD_NOT_IMPLEMENTED after validation
    throws(
      () => {
        new dgram.Socket('udp4', () => {});
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    // Test Socket constructor argument validation
    throws(
      () => {
        new dgram.Socket(null);
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    throws(
      () => {
        new dgram.Socket(123);
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    throws(
      () => {
        new dgram.Socket('udp4', 'invalid');
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    // Test Socket prototype methods exist
    strictEqual(typeof dgram.Socket.prototype.bind, 'function');
    strictEqual(typeof dgram.Socket.prototype.connect, 'function');
    strictEqual(typeof dgram.Socket.prototype.disconnect, 'function');
    strictEqual(typeof dgram.Socket.prototype.send, 'function');
    strictEqual(typeof dgram.Socket.prototype.sendto, 'function');
    strictEqual(typeof dgram.Socket.prototype.close, 'function');
    strictEqual(typeof dgram.Socket.prototype.address, 'function');
    strictEqual(typeof dgram.Socket.prototype.remoteAddress, 'function');
    strictEqual(typeof dgram.Socket.prototype.setBroadcast, 'function');
    strictEqual(typeof dgram.Socket.prototype.setTTL, 'function');
    strictEqual(typeof dgram.Socket.prototype.setMulticastTTL, 'function');
    strictEqual(typeof dgram.Socket.prototype.setMulticastLoopback, 'function');
    strictEqual(
      typeof dgram.Socket.prototype.setMulticastInterface,
      'function'
    );
    strictEqual(typeof dgram.Socket.prototype.addMembership, 'function');
    strictEqual(typeof dgram.Socket.prototype.dropMembership, 'function');
    strictEqual(
      typeof dgram.Socket.prototype.addSourceSpecificMembership,
      'function'
    );
    strictEqual(
      typeof dgram.Socket.prototype.dropSourceSpecificMembership,
      'function'
    );
    strictEqual(typeof dgram.Socket.prototype.ref, 'function');
    strictEqual(typeof dgram.Socket.prototype.unref, 'function');
    strictEqual(typeof dgram.Socket.prototype.setRecvBufferSize, 'function');
    strictEqual(typeof dgram.Socket.prototype.setSendBufferSize, 'function');
    strictEqual(typeof dgram.Socket.prototype.getRecvBufferSize, 'function');
    strictEqual(typeof dgram.Socket.prototype.getSendBufferSize, 'function');
    strictEqual(typeof dgram.Socket.prototype.getSendQueueSize, 'function');
    strictEqual(typeof dgram.Socket.prototype.getSendQueueCount, 'function');

    // Test methods that throw ERR_METHOD_NOT_IMPLEMENTED
    const mockThis = {};

    throws(
      () => {
        dgram.Socket.prototype.bind.call(mockThis);
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    throws(
      () => {
        dgram.Socket.prototype.bind.call(mockThis, 8080);
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    throws(
      () => {
        dgram.Socket.prototype.bind.call(mockThis, 8080, 'localhost');
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    throws(
      () => {
        dgram.Socket.prototype.connect.call(mockThis, 8080);
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    throws(
      () => {
        dgram.Socket.prototype.connect.call(mockThis, 8080, 'localhost');
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    throws(
      () => {
        dgram.Socket.prototype.disconnect.call(mockThis);
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    throws(
      () => {
        dgram.Socket.prototype.send.call(mockThis, Buffer.from('test'));
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    throws(
      () => {
        dgram.Socket.prototype.send.call(mockThis, 'test', 8080, 'localhost');
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    throws(
      () => {
        dgram.Socket.prototype.sendto.call(mockThis, Buffer.from('test'));
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    throws(
      () => {
        dgram.Socket.prototype.close.call(mockThis);
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    throws(
      () => {
        dgram.Socket.prototype.close.call(mockThis, () => {});
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    // Test methods that return empty objects
    const address = dgram.Socket.prototype.address.call(mockThis);
    strictEqual(typeof address, 'object');
    deepStrictEqual(address, {});

    const remoteAddress = dgram.Socket.prototype.remoteAddress.call(mockThis);
    strictEqual(typeof remoteAddress, 'object');
    deepStrictEqual(remoteAddress, {});

    // Test methods that are no-ops (should not throw)
    dgram.Socket.prototype.setBroadcast.call(mockThis, true);
    dgram.Socket.prototype.setBroadcast.call(mockThis, false);
    dgram.Socket.prototype.setBroadcast.call(mockThis, 'invalid');

    dgram.Socket.prototype.setTTL.call(mockThis, 64);
    dgram.Socket.prototype.setTTL.call(mockThis, 'invalid');

    dgram.Socket.prototype.setMulticastTTL.call(mockThis, 1);
    dgram.Socket.prototype.setMulticastTTL.call(mockThis, 'invalid');

    dgram.Socket.prototype.setMulticastLoopback.call(mockThis, true);
    dgram.Socket.prototype.setMulticastLoopback.call(mockThis, false);
    dgram.Socket.prototype.setMulticastLoopback.call(mockThis, 'invalid');

    dgram.Socket.prototype.setMulticastInterface.call(mockThis, '127.0.0.1');
    dgram.Socket.prototype.setMulticastInterface.call(mockThis, 'invalid');

    dgram.Socket.prototype.addMembership.call(mockThis, '224.0.0.1');
    dgram.Socket.prototype.addMembership.call(
      mockThis,
      '224.0.0.1',
      '127.0.0.1'
    );
    dgram.Socket.prototype.addMembership.call(mockThis, 'invalid', 'invalid');

    dgram.Socket.prototype.dropMembership.call(mockThis, '224.0.0.1');
    dgram.Socket.prototype.dropMembership.call(
      mockThis,
      '224.0.0.1',
      '127.0.0.1'
    );
    dgram.Socket.prototype.dropMembership.call(mockThis, 'invalid', 'invalid');

    dgram.Socket.prototype.addSourceSpecificMembership.call(
      mockThis,
      '127.0.0.1',
      '224.0.0.1'
    );
    dgram.Socket.prototype.addSourceSpecificMembership.call(
      mockThis,
      '127.0.0.1',
      '224.0.0.1',
      '127.0.0.1'
    );
    dgram.Socket.prototype.addSourceSpecificMembership.call(
      mockThis,
      'invalid',
      'invalid',
      'invalid'
    );

    dgram.Socket.prototype.dropSourceSpecificMembership.call(
      mockThis,
      '127.0.0.1',
      '224.0.0.1'
    );
    dgram.Socket.prototype.dropSourceSpecificMembership.call(
      mockThis,
      '127.0.0.1',
      '224.0.0.1',
      '127.0.0.1'
    );
    dgram.Socket.prototype.dropSourceSpecificMembership.call(
      mockThis,
      'invalid',
      'invalid',
      'invalid'
    );

    dgram.Socket.prototype.setRecvBufferSize.call(mockThis, 1024);
    dgram.Socket.prototype.setRecvBufferSize.call(mockThis, 'invalid');

    dgram.Socket.prototype.setSendBufferSize.call(mockThis, 1024);
    dgram.Socket.prototype.setSendBufferSize.call(mockThis, 'invalid');

    // Test methods that return this
    const refResult = dgram.Socket.prototype.ref.call(mockThis);
    strictEqual(refResult, mockThis);

    const unrefResult = dgram.Socket.prototype.unref.call(mockThis);
    strictEqual(unrefResult, mockThis);

    // Test methods that return numbers
    const recvBufferSize =
      dgram.Socket.prototype.getRecvBufferSize.call(mockThis);
    strictEqual(recvBufferSize, 0);

    const sendBufferSize =
      dgram.Socket.prototype.getSendBufferSize.call(mockThis);
    strictEqual(sendBufferSize, 0);

    const sendQueueSize =
      dgram.Socket.prototype.getSendQueueSize.call(mockThis);
    strictEqual(sendQueueSize, 0);

    const sendQueueCount =
      dgram.Socket.prototype.getSendQueueCount.call(mockThis);
    strictEqual(sendQueueCount, 0);

    // Test Symbol.asyncDispose method exists and is a no-op
    strictEqual(typeof dgram.Socket.prototype[Symbol.asyncDispose], 'function');

    // Test asyncDispose returns a Promise
    const disposeResult =
      dgram.Socket.prototype[Symbol.asyncDispose].call(mockThis);
    ok(disposeResult instanceof Promise);

    // Verify the promise resolves to undefined
    disposeResult.then((result) => {
      strictEqual(result, undefined);
    });

    // Test default export
    strictEqual(typeof dgram.default, 'object');
    strictEqual(dgram.default.createSocket, dgram.createSocket);
    strictEqual(dgram.default.Socket, dgram.Socket);

    // Test createSocket with more complex options
    throws(
      () => {
        dgram.createSocket({
          type: 'udp4',
          reuseAddr: true,
          ipv6Only: false,
          recvBufferSize: 1024,
          sendBufferSize: 1024,
        });
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    // Test edge cases with validation
    throws(
      () => {
        dgram.createSocket({ type: 'udp4' }, null);
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    // Test that Socket extends EventEmitter properly
    // Note: We can't test this directly since constructor throws, but we can check prototype chain
    const EventEmitter = dgram.Socket.prototype.constructor;
    strictEqual(typeof EventEmitter, 'function');
  },
};
