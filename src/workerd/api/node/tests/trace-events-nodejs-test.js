import * as trace_events from 'node:trace_events';
import { strictEqual, deepStrictEqual, throws, ok } from 'node:assert';

export const traceEventsTest = {
  test() {
    // Note: test was generated by claude with manual tweaks

    // Test that required exports exist
    strictEqual(typeof trace_events.createTracing, 'function');
    strictEqual(typeof trace_events.getEnabledCategories, 'function');

    // Test createTracing with valid categories - should throw ERR_METHOD_NOT_IMPLEMENTED after validation
    throws(
      () => {
        trace_events.createTracing({ categories: ['node'] });
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    throws(
      () => {
        trace_events.createTracing({ categories: ['node', 'v8'] });
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    throws(
      () => {
        trace_events.createTracing({ categories: [] });
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    // Test createTracing options validation - options must be an object
    throws(
      () => {
        trace_events.createTracing('invalid');
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    throws(
      () => {
        trace_events.createTracing(null);
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    throws(
      () => {
        trace_events.createTracing(123);
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    throws(
      () => {
        trace_events.createTracing([]);
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    // Test createTracing categories validation - must be array of strings if provided
    throws(
      () => {
        trace_events.createTracing({ categories: 'invalid' });
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    throws(
      () => {
        trace_events.createTracing({ categories: {} });
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    throws(
      () => {
        trace_events.createTracing({ categories: 123 });
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    throws(
      () => {
        trace_events.createTracing({ categories: [123] });
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    throws(
      () => {
        trace_events.createTracing({ categories: ['valid', 123] });
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    throws(
      () => {
        trace_events.createTracing({ categories: ['valid', null] });
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    throws(
      () => {
        trace_events.createTracing({ categories: ['valid', {}] });
      },
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    // Test getEnabledCategories - should return empty array
    const enabledCategories = trace_events.getEnabledCategories();
    ok(Array.isArray(enabledCategories));
    deepStrictEqual(enabledCategories, []);

    // Test getEnabledCategories with arguments (should ignore them)
    const enabledCategories2 = trace_events.getEnabledCategories('ignored');
    deepStrictEqual(enabledCategories2, []);

    const enabledCategories3 = trace_events.getEnabledCategories(123, {});
    deepStrictEqual(enabledCategories3, []);

    // Test Tracing class through prototype (can't instantiate due to constructor throwing)
    // We need to access the Tracing class through the internal module structure
    // Since we can't instantiate it, we'll test what we can access

    // Test that createTracing validates properly before throwing
    // Test with additional unknown properties (should be accepted)
    throws(
      () => {
        trace_events.createTracing({
          categories: ['node'],
          unknownProperty: 'should be ignored',
        });
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    // Test edge cases with categories array
    throws(
      () => {
        trace_events.createTracing({ categories: [''] }); // empty string should be valid
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    throws(
      () => {
        trace_events.createTracing({ categories: ['a'.repeat(1000)] }); // very long string
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    // Test that categories with special characters are accepted
    throws(
      () => {
        trace_events.createTracing({
          categories: ['node.fs', 'v8.gc', 'custom-category'],
        });
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    // Test with undefined categories (should pass validation)
    throws(
      () => {
        trace_events.createTracing({ categories: undefined });
      },
      {
        code: 'ERR_INVALID_ARG_TYPE', // undefined categories should fail validation
      }
    );

    // Test default export
    strictEqual(typeof trace_events.default, 'object');
    strictEqual(trace_events.default.createTracing, trace_events.createTracing);
    strictEqual(
      trace_events.default.getEnabledCategories,
      trace_events.getEnabledCategories
    );

    // Test that getEnabledCategories is consistent across calls
    const categories1 = trace_events.getEnabledCategories();
    const categories2 = trace_events.getEnabledCategories();
    deepStrictEqual(categories1, categories2);
    strictEqual(categories1.length, 0);
    strictEqual(categories2.length, 0);

    // Test that getEnabledCategories returns a new array each time (not the same reference)
    const categories3 = trace_events.getEnabledCategories();
    const categories4 = trace_events.getEnabledCategories();
    // Arrays should be equal but not the same reference
    deepStrictEqual(categories3, categories4);
    // Note: We can't test reference inequality without modifying the arrays

    // Test various valid category names
    const validCategoryNames = [
      'node',
      'v8',
      'node.fs',
      'node.http',
      'v8.gc',
      'custom',
      'my-category',
      'category_with_underscores',
      'category.with.dots',
      'category123',
      '123category',
      'a',
      'very_long_category_name_that_should_still_be_valid',
    ];

    for (const category of validCategoryNames) {
      throws(
        () => {
          trace_events.createTracing({ categories: [category] });
        },
        {
          code: 'ERR_METHOD_NOT_IMPLEMENTED',
        }
      );
    }

    // Test with multiple valid categories
    throws(
      () => {
        trace_events.createTracing({ categories: validCategoryNames });
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );

    // Test with duplicate categories (should be valid)
    throws(
      () => {
        trace_events.createTracing({
          categories: ['node', 'node', 'v8', 'v8'],
        });
      },
      {
        code: 'ERR_METHOD_NOT_IMPLEMENTED',
      }
    );
  },
};
