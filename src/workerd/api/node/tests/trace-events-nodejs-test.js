import * as trace_events from 'node:trace_events';
import {
  strictEqual,
  deepStrictEqual,
  throws,
  ok,
  doesNotThrow,
} from 'node:assert';

export const traceEventsTest = {
  test() {
    // Note: test was generated by claude with manual tweaks

    // Test that required exports exist
    strictEqual(typeof trace_events.createTracing, 'function');
    strictEqual(typeof trace_events.getEnabledCategories, 'function');

    doesNotThrow(() => {
      trace_events.createTracing({ categories: ['node'] });
    });

    doesNotThrow(() => {
      trace_events.createTracing({ categories: ['node', 'v8'] });
    });

    throws(
      () => {
        trace_events.createTracing({ categories: [] });
      },
      { code: 'ERR_TRACE_EVENTS_CATEGORY_REQUIRED' }
    );

    // Test createTracing options validation - options must be an object
    for (const input of [
      'invalid',
      null,
      123,
      [],
      { categories: 'invalid' },
      { categories: {} },
      { categories: 123 },
      { categories: [123] },
      { categories: ['valid', 123] },
      { categories: ['valid', null] },
      { categories: ['valid', {}] },
    ]) {
      throws(
        () => {
          trace_events.createTracing(input);
        },
        {
          code: 'ERR_INVALID_ARG_TYPE',
        }
      );
    }

    // Test getEnabledCategories - should return undefined
    const enabledCategories = trace_events.getEnabledCategories();
    strictEqual(enabledCategories, undefined);

    // Test getEnabledCategories with arguments (should ignore them)
    const enabledCategories2 = trace_events.getEnabledCategories('ignored');
    strictEqual(enabledCategories2, undefined);

    const enabledCategories3 = trace_events.getEnabledCategories(123, {});
    strictEqual(enabledCategories3, undefined);

    // Test Tracing class through prototype (can't instantiate due to constructor throwing)
    // We need to access the Tracing class through the internal module structure
    // Since we can't instantiate it, we'll test what we can access

    // Test that createTracing validates properly before throwing
    // Test with additional unknown properties (should be accepted)
    doesNotThrow(() => {
      trace_events.createTracing({
        categories: ['node'],
        unknownProperty: 'should be ignored',
      });
    });

    // Test edge cases with categories array
    doesNotThrow(() => {
      trace_events.createTracing({ categories: [''] }); // empty string should be valid
    });

    doesNotThrow(() => {
      trace_events.createTracing({ categories: ['a'.repeat(1000)] }); // very long string
    });

    // Test that categories with special characters are accepted
    doesNotThrow(() => {
      trace_events.createTracing({
        categories: ['node.fs', 'v8.gc', 'custom-category'],
      });
    });

    // Test with undefined categories (should pass validation)
    throws(
      () => {
        trace_events.createTracing({ categories: undefined });
      },
      {
        code: 'ERR_INVALID_ARG_TYPE', // undefined categories should fail validation
      }
    );

    // Test default export
    strictEqual(typeof trace_events.default, 'object');
    strictEqual(trace_events.default.createTracing, trace_events.createTracing);
    strictEqual(
      trace_events.default.getEnabledCategories,
      trace_events.getEnabledCategories
    );

    // Test that getEnabledCategories is consistent across calls
    const categories1 = trace_events.getEnabledCategories();
    const categories2 = trace_events.getEnabledCategories();
    strictEqual(categories1, undefined);
    strictEqual(categories2, undefined);
    strictEqual(categories1, categories2);

    // Test various valid category names
    const validCategoryNames = [
      'node',
      'v8',
      'node.fs',
      'node.http',
      'v8.gc',
      'custom',
      'my-category',
      'category_with_underscores',
      'category.with.dots',
      'category123',
      '123category',
      'a',
      'very_long_category_name_that_should_still_be_valid',
    ];

    for (const category of validCategoryNames) {
      doesNotThrow(() => {
        trace_events.createTracing({ categories: [category] });
      });
    }

    // Test with multiple valid categories
    doesNotThrow(() => {
      trace_events.createTracing({ categories: validCategoryNames });
    });

    // Test with duplicate categories (should be valid)
    doesNotThrow(() => {
      trace_events.createTracing({
        categories: ['node', 'node', 'v8', 'v8'],
      });
    });
  },
};
