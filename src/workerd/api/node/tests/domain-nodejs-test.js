import * as domain from 'node:domain';
import { strictEqual, throws, ok } from 'node:assert';
import { EventEmitter } from 'node:events';

export const domainTest = {
  test() {
    // Note: test was generated by claude with manual tweaks

    // Test that Domain class exists and is a constructor
    strictEqual(typeof domain.Domain, 'function');

    // Test that createDomain function exists
    strictEqual(typeof domain.createDomain, 'function');

    // Test that create export exists (should be a Domain instance)
    ok(domain.create instanceof domain.Domain);

    // Test that active is null (domains are non-operational)
    strictEqual(domain.active, null);

    // Test creating a new domain
    const d = domain.createDomain();
    ok(d instanceof domain.Domain);
    ok(d instanceof EventEmitter); // Domain extends EventEmitter

    // Test that Domain has expected properties
    strictEqual(d.members, undefined);

    // Test domain methods exist and are functions
    strictEqual(typeof d.enter, 'function');
    strictEqual(typeof d.exit, 'function');
    strictEqual(typeof d.add, 'function');
    strictEqual(typeof d.remove, 'function');
    strictEqual(typeof d.run, 'function');
    strictEqual(typeof d.intercept, 'function');
    strictEqual(typeof d.bind, 'function');
    strictEqual(typeof d._errorHandler, 'function');

    // Test enter() method - should be no-op (not throw)
    d.enter();

    // Test exit() method - should be no-op (not throw)
    d.exit();

    // Test add() method - should be no-op (not throw)
    const ee = new EventEmitter();
    d.add(ee);
    d.add(null);
    d.add(undefined);
    d.add('string');
    d.add(123);

    // Test remove() method - should be no-op (not throw)
    d.remove(ee);
    d.remove(null);
    d.remove(undefined);
    d.remove('string');
    d.remove(123);

    // Test run() method - should execute function and return result
    let callCount = 0;
    const testFn = function (...args) {
      callCount++;
      strictEqual(this, d); // this should be the domain
      return args.reduce((a, b) => a + b, 0);
    };

    const result = d.run(testFn, 1, 2, 3, 4);
    strictEqual(result, 10);
    strictEqual(callCount, 1);

    // Test run() with function that throws
    const errorFn = function () {
      throw new Error('test error');
    };
    throws(() => {
      d.run(errorFn);
    }, /test error/);

    // Test run() with no arguments
    const noArgFn = function () {
      return 'no args';
    };
    strictEqual(d.run(noArgFn), 'no args');

    // Test intercept() method - should return the callback directly
    const callback1 = function () {
      return 'callback1';
    };
    const intercepted = d.intercept(callback1);
    strictEqual(intercepted, callback1);
    strictEqual(intercepted(), 'callback1');

    // Test bind() method - should return the callback directly
    const callback2 = function () {
      return 'callback2';
    };
    const bound = d.bind(callback2);
    strictEqual(bound, callback2);
    strictEqual(bound(), 'callback2');

    // Test _errorHandler() method - should throw the error passed to it
    const testError = new Error('test error handler');
    throws(() => {
      d._errorHandler(testError);
    }, testError);

    throws(() => {
      d._errorHandler('string error');
    }, /string error/);

    throws(() => {
      d._errorHandler(null);
    });

    // Test that multiple domains can be created independently
    const d1 = domain.createDomain();
    const d2 = domain.createDomain();
    ok(d1 !== d2);
    ok(d1 instanceof domain.Domain);
    ok(d2 instanceof domain.Domain);

    // Test that domains inherit from EventEmitter properly
    let emitted = false;
    d1.on('test', () => {
      emitted = true;
    });
    d1.emit('test');
    strictEqual(emitted, true);

    // Test domain with async function (should work normally)
    let asyncResult = null;
    const asyncFn = async function (value) {
      return Promise.resolve(value * 2);
    };

    const asyncPromise = d.run(asyncFn, 5);
    ok(asyncPromise instanceof Promise);

    // Test that EventEmitter.usingDomains is set to false
    strictEqual(EventEmitter.usingDomains, false);

    // Test default export
    strictEqual(typeof domain.default, 'object');
    strictEqual(domain.default.Domain, domain.Domain);
    strictEqual(domain.default.active, domain.active);
    strictEqual(domain.default.createDomain, domain.createDomain);
    strictEqual(domain.default.create, domain.create);

    // Test edge cases with run()
    // Test with null function (should throw)
    throws(() => {
      d.run(null);
    });

    throws(() => {
      d.run(undefined);
    });

    throws(() => {
      d.run('not a function');
    });

    // Test intercept with non-function (should still return it)
    const nonFunction = 'not a function';
    strictEqual(d.intercept(nonFunction), nonFunction);

    // Test bind with non-function (should still return it)
    strictEqual(d.bind(nonFunction), nonFunction);

    // Test that domain methods can be called multiple times safely
    d.enter();
    d.enter();
    d.exit();
    d.exit();

    // Test members property remains undefined after operations
    d.add(new EventEmitter());
    d.remove(new EventEmitter());
    d.enter();
    d.exit();
    strictEqual(d.members, undefined);

    console.log('All domain module tests passed!');
  },
};
