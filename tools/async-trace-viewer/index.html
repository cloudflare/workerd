<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Async Trace Viewer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #eee;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
      background: #16213e;
      padding: 0.75rem 1.5rem;
      border-bottom: 1px solid #0f3460;
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    h1 { font-size: 1.1rem; color: #e94560; }

    .view-select {
      margin-left: 1rem;
      padding: 0.4rem 0.8rem;
      background: #0f3460;
      color: #e94560;
      border: 1px solid #e94560;
      border-radius: 4px;
      font-size: 0.85rem;
      cursor: pointer;
      min-width: 120px;
    }

    .view-select:focus {
      outline: none;
      box-shadow: 0 0 0 2px rgba(233, 69, 96, 0.3);
    }

    .view-select option {
      background: #16213e;
      color: #eee;
    }

    .view-help {
      display: none;
    }

    .view-help.active {
      display: block;
    }

    .controls {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      margin-left: auto;
    }

    .controls input[type="file"] { display: none; }

    .controls button, .controls .file-label, .controls select {
      background: #0f3460;
      color: white;
      border: 1px solid #e94560;
      padding: 0.35rem 0.6rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.75rem;
    }

    .controls button:hover, .controls .file-label:hover { background: #e94560; }

    /* Analysis dropdown menu */
    .dropdown {
      position: relative;
      display: inline-block;
    }

    .dropdown-btn {
      background: #0f3460;
      color: white;
      border: 1px solid #e94560;
      padding: 0.35rem 0.6rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.75rem;
    }

    .dropdown-btn:hover, .dropdown-btn.active {
      background: #e94560;
    }

    .dropdown-content {
      display: none;
      position: absolute;
      top: 100%;
      right: 0;
      background: #16213e;
      border: 1px solid #0f3460;
      border-radius: 4px;
      min-width: 200px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      z-index: 1001;
      padding: 0.25rem 0;
    }

    .dropdown-content.show {
      display: block;
    }

    .dropdown-item {
      display: flex;
      align-items: center;
      padding: 0.5rem 0.75rem;
      cursor: pointer;
      font-size: 0.8rem;
      color: #ccc;
      gap: 0.5rem;
    }

    .dropdown-item:hover {
      background: rgba(233, 69, 96, 0.2);
    }

    .dropdown-item input[type="checkbox"] {
      width: 14px;
      height: 14px;
      accent-color: #e94560;
    }

    .dropdown-item .hotkey {
      margin-left: auto;
      background: #0f3460;
      padding: 0.1rem 0.35rem;
      border-radius: 3px;
      font-size: 0.65rem;
      color: #888;
    }

    .dropdown-divider {
      height: 1px;
      background: #0f3460;
      margin: 0.25rem 0;
    }

    .threshold-section {
      padding: 0.5rem;
    }

    .threshold-header {
      font-size: 0.7rem;
      font-weight: bold;
      color: #e94560;
      margin-bottom: 0.4rem;
      text-transform: uppercase;
    }

    .threshold-item {
      display: flex;
      align-items: center;
      gap: 0.3rem;
      font-size: 0.7rem;
      color: #aaa;
      margin-bottom: 0.3rem;
    }

    .threshold-item span:first-child {
      flex: 0 0 90px;
    }

    .threshold-item input[type="range"] {
      flex: 1;
      height: 4px;
      -webkit-appearance: none;
      background: #0f3460;
      border-radius: 2px;
      cursor: pointer;
    }

    .threshold-item input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 12px;
      height: 12px;
      background: #e94560;
      border-radius: 50%;
      cursor: pointer;
    }

    .threshold-item span:last-child {
      flex: 0 0 40px;
      text-align: right;
      color: #7ec8e3;
    }

    .main-container {
      display: flex;
      flex: 1;
      overflow: hidden;
      margin-top: 52px; /* Account for fixed header */
      height: calc(100vh - 52px);
    }

    .view-container {
      flex: 1 1 0;
      overflow: auto;
      padding: 1rem;
      display: none;
      min-height: 0; /* Allow flex shrinking */
    }

    .view-container.active { display: block; }

    /* Waterfall styles */
    .waterfall { position: relative; min-height: 100%; }

    .time-axis {
      position: sticky;
      top: 0;
      background: #1a1a2e;
      z-index: 100;
      height: 28px;
      border-bottom: 1px solid #333;
      margin-bottom: 4px;
    }

    .time-tick {
      position: absolute;
      font-size: 9px;
      color: #666;
      transform: translateX(-50%);
    }

    .time-tick::after {
      content: '';
      position: absolute;
      left: 50%;
      top: 14px;
      width: 1px;
      height: 6px;
      background: #444;
    }

    .resource-row {
      display: flex;
      align-items: center;
      height: 22px;
      margin: 1px 0;
    }

    .resource-row:hover { background: rgba(233, 69, 96, 0.1); }
    .resource-row.selected { background: rgba(233, 69, 96, 0.2); }
    .resource-row.highlighted { background: rgba(126, 200, 227, 0.15); }
    .resource-row.critical-path {
      background: rgba(255, 100, 50, 0.25);
      border-left: 3px solid #ff6432;
    }
    .resource-row.critical-path .resource-bar {
      box-shadow: 0 0 8px rgba(255, 100, 50, 0.6);
    }
    .resource-row.internal { opacity: 0.4; }
    .resource-row.internal:hover { opacity: 0.7; }
    .resource-row.bottleneck {
      background: rgba(255, 200, 50, 0.25);
      border-left: 3px solid #ffc832;
    }
    .resource-row.bottleneck .resource-bar {
      box-shadow: 0 0 8px rgba(255, 200, 50, 0.6);
    }
    .resource-row.pattern-match {
      background: rgba(200, 100, 255, 0.25);
      border-left: 3px solid #c864ff;
    }
    .resource-row.pattern-match .resource-bar {
      box-shadow: 0 0 8px rgba(200, 100, 255, 0.6);
    }
    /* Severity-based pattern highlighting */
    .resource-row.pattern-high {
      background: rgba(255, 0, 255, 0.3);
      border-left: 4px solid #ff00ff;
    }
    .resource-row.pattern-high .resource-bar {
      box-shadow: 0 0 12px rgba(255, 0, 255, 0.8);
    }
    .resource-row.pattern-medium {
      background: rgba(204, 102, 255, 0.25);
      border-left: 3px solid #cc66ff;
    }
    .resource-row.pattern-medium .resource-bar {
      box-shadow: 0 0 8px rgba(204, 102, 255, 0.6);
    }
    .resource-row.pattern-low {
      background: rgba(153, 102, 204, 0.15);
      border-left: 2px solid #9966cc;
    }
    .resource-row.pattern-low .resource-bar {
      box-shadow: 0 0 5px rgba(153, 102, 204, 0.4);
    }

    #critical-path-btn.active {
      background: #ff6432 !important;
      border-color: #ff6432 !important;
    }

    .resource-label {
      width: 180px;
      min-width: 180px;
      padding-right: 8px;
      font-size: 10px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display: flex;
      align-items: center;
      gap: 3px;
    }

    .resource-label .indent {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-left: 1px solid #444;
      border-bottom: 1px solid #444;
    }

    .type-badge {
      padding: 1px 3px;
      border-radius: 2px;
      font-size: 8px;
      font-weight: bold;
    }

    .resource-timeline {
      flex: 1;
      position: relative;
      height: 100%;
    }

    .resource-bar {
      position: absolute;
      height: 14px;
      top: 4px;
      border-radius: 2px;
      cursor: pointer;
      display: flex;
      align-items: center;
      font-size: 8px;
      color: white;
      overflow: hidden;
    }

    .resource-bar .async-wait {
      height: 100%;
      opacity: 0.5;
    }

    .resource-bar .sync-time { height: 100%; }

    /* Accessibility mode styles */
    body.accessibility-mode .resource-bar .async-wait {
      opacity: 0.6;
      background-image: repeating-linear-gradient(
        45deg,
        transparent,
        transparent 3px,
        rgba(255,255,255,0.3) 3px,
        rgba(255,255,255,0.3) 6px
      ) !important;
    }

    body.accessibility-mode .resource-bar .sync-time {
      border: 2px solid rgba(255,255,255,0.5);
      box-sizing: border-box;
    }

    .resource-bar .bar-label {
      position: absolute;
      left: 3px;
      z-index: 1;
      text-shadow: 0 0 2px rgba(0,0,0,0.9);
    }

    /* Bubble view styles */
    #bubble-canvas, #parallelism-canvas, #dag-canvas, #breakdown-canvas, #latency-canvas, #gaps-canvas, #replay-canvas, #heatmap-canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    .tooltip {
      position: fixed;
      background: rgba(22, 33, 62, 0.95);
      border: 1px solid #e94560;
      border-radius: 4px;
      padding: 0.5rem;
      font-size: 0.75rem;
      pointer-events: none;
      z-index: 1000;
      max-width: 280px;
    }

    .tooltip-title {
      font-weight: bold;
      color: #e94560;
      margin-bottom: 0.3rem;
    }

    /* Sidebar styles */
    .sidebar {
      width: 300px;
      flex-shrink: 0;
      background: #16213e;
      border-left: 1px solid #0f3460;
      overflow-y: auto;
      padding: 0.75rem;
      font-size: 0.8rem;
    }

    .sidebar h2 { font-size: 0.9rem; margin-bottom: 0.5rem; color: #e94560; }

    .sidebar-section {
      margin-bottom: 0.5rem;
      border-bottom: 1px solid #0f3460;
      padding-bottom: 0.5rem;
    }

    .sidebar-section:last-child {
      border-bottom: none;
    }

    .sidebar-section h3 {
      font-size: 0.8rem;
      margin: 0.4rem 0;
      color: #aaa;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      user-select: none;
    }

    .sidebar-section h3:hover {
      color: #e94560;
    }

    .sidebar-section h3::after {
      content: '‚ñº';
      font-size: 0.6rem;
      transition: transform 0.2s;
    }

    .sidebar-section.collapsed h3::after {
      transform: rotate(-90deg);
    }

    .sidebar-section.collapsed .section-content {
      display: none;
    }

    .section-content {
      margin-top: 0.4rem;
    }

    .stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.4rem;
      margin-bottom: 0.75rem;
    }

    .stat-item {
      background: #0f3460;
      padding: 0.4rem;
      border-radius: 4px;
      text-align: center;
    }

    .stat-value { font-size: 1.1rem; color: #e94560; font-weight: bold; }
    .stat-label { font-size: 0.65rem; color: #aaa; }

    .detail-item {
      padding: 0.3rem 0.4rem;
      background: #0f3460;
      border-radius: 3px;
      margin-bottom: 0.3rem;
      font-size: 0.75rem;
    }

    .detail-item strong { color: #e94560; }

    .stack-trace-container {
      max-height: 150px;
      overflow-y: auto;
      background: #0a1628;
      border-radius: 4px;
      padding: 0.4rem;
    }

    .stack-frame {
      font-family: monospace;
      font-size: 0.7rem;
      color: #7ec8e3;
      padding: 0.2rem 0;
      border-bottom: 1px solid #1a1a2e;
      word-break: break-all;
    }

    .stack-frame:last-child {
      border-bottom: none;
    }

    .stack-empty {
      color: #666;
      font-style: italic;
      font-size: 0.7rem;
    }

    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      margin-bottom: 0.5rem;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      font-size: 0.65rem;
    }

    .legend-color {
      width: 10px;
      height: 10px;
      border-radius: 2px;
    }

    .chain-nav {
      display: flex;
      gap: 0.4rem;
      margin-bottom: 0.5rem;
    }

    .chain-nav button {
      flex: 1;
      padding: 0.3rem;
      background: #0f3460;
      border: 1px solid #e94560;
      color: white;
      border-radius: 3px;
      cursor: pointer;
      font-size: 0.7rem;
    }

    .chain-nav button:hover { background: #e94560; }
    .chain-nav button:disabled { opacity: 0.5; cursor: not-allowed; }

    .timing-bar {
      height: 18px;
      display: flex;
      border-radius: 3px;
      overflow: hidden;
      margin-bottom: 0.25rem;
    }

    .timing-bar .segment {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 8px;
      color: white;
    }

    .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #666;
    }

    .textarea-container {
      padding: 0.75rem;
      display: none;
      background: #16213e;
    }

    .textarea-container.show { display: block; }

    .textarea-container textarea {
      width: 100%;
      height: 120px;
      background: #0f3460;
      color: white;
      border: 1px solid #e94560;
      border-radius: 4px;
      padding: 0.5rem;
      font-family: monospace;
      font-size: 0.75rem;
    }

    /* Modal styles */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 2000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal-content {
      background: #16213e;
      border: 1px solid #e94560;
      border-radius: 8px;
      max-width: 800px;
      max-height: 85vh;
      width: 90%;
      display: flex;
      flex-direction: column;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      border-bottom: 1px solid #0f3460;
    }

    .modal-header h2 {
      margin: 0;
      font-size: 1.2rem;
      color: #e94560;
    }

    .modal-close {
      background: none;
      border: none;
      color: #888;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0;
      line-height: 1;
    }

    .modal-close:hover { color: #e94560; }

    .modal-body {
      padding: 1.5rem;
      overflow-y: auto;
      font-size: 0.85rem;
      line-height: 1.5;
    }

    .guide-section {
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid #0f3460;
    }

    .guide-section:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }

    .guide-section h3 {
      color: #7ec8e3;
      margin: 0 0 0.5rem 0;
      font-size: 1rem;
    }

    .guide-section p { margin: 0.4rem 0; }
    .guide-section ul, .guide-section ol {
      margin: 0.5rem 0;
      padding-left: 1.5rem;
    }
    .guide-section li { margin: 0.25rem 0; }
    .guide-section code {
      background: #0f3460;
      padding: 0.1rem 0.3rem;
      border-radius: 3px;
      font-size: 0.8rem;
    }

    .guide-example {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      margin: 0.75rem 0;
    }

    .guide-bad, .guide-good {
      padding: 0.5rem;
      border-radius: 4px;
      font-size: 0.8rem;
    }

    .guide-bad {
      background: rgba(233, 69, 96, 0.15);
      border: 1px solid rgba(233, 69, 96, 0.3);
    }

    .guide-good {
      background: rgba(80, 200, 120, 0.15);
      border: 1px solid rgba(80, 200, 120, 0.3);
    }

    .guide-bad pre, .guide-good pre {
      margin: 0.5rem 0 0 0;
      font-size: 0.75rem;
      white-space: pre-wrap;
      color: #ccc;
    }

    .guide-tip {
      background: rgba(255, 215, 0, 0.1);
      border-left: 3px solid #ffd700;
      padding: 0.4rem 0.6rem;
      margin: 0.5rem 0;
      font-size: 0.8rem;
    }

    .guide-table {
      width: 100%;
      border-collapse: collapse;
      margin: 0.5rem 0;
      font-size: 0.8rem;
    }

    .guide-table th, .guide-table td {
      padding: 0.4rem 0.6rem;
      text-align: left;
      border: 1px solid #0f3460;
    }

    .guide-table th {
      background: #0f3460;
      color: #7ec8e3;
    }

    .guide-table tr:nth-child(even) {
      background: rgba(15, 52, 96, 0.3);
    }

    @media (max-width: 600px) {
      .guide-example {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>üî¨ Async Trace Viewer</h1>
    <select id="view-select" class="view-select">
      <option value="waterfall">1: Waterfall</option>
      <option value="bubble">2: Bubble</option>
      <option value="dag">3: DAG</option>
      <option value="parallelism">4: Parallelism</option>
      <option value="breakdown">5: Breakdown</option>
      <option value="latency">6: Latency</option>
      <option value="gaps">7: Gaps</option>
      <option value="replay">8: Replay</option>
      <option value="heatmap">9: Heatmap</option>
    </select>
    <div class="controls">
      <label class="file-label" for="file-input">üìÅ Load</label>
      <input type="file" id="file-input" accept=".json">
      <button id="paste-btn">üìã Paste</button>
      <select id="demo-select">
        <option value="">Demo...</option>
        <option value="timer">Timer</option>
        <option value="async-patterns">Async Patterns</option>
        <option value="chat-room">Chat Room</option>
        <option value="good-parallel">Good: Parallel Fetches</option>
        <option value="bad-sequential">Bad: Sequential Fetches</option>
        <option value="bad-duplicates">Bad: Duplicate Fetches</option>
        <option value="waterfall-fetches">Bad: Waterfall Fetches</option>
        <option value="unresolved-promises">Bad: Unresolved Promises</option>
        <option value="long-async-gaps">Bad: Long Async Gaps</option>
        <option value="redundant-timers">Bad: Redundant Timers</option>
        <option value="cache-misses">Bad: Cache Misses</option>
        <option value="streams-pipeline">Streams Pipeline</option>
        <option value="pathological">üíÄ Pathological Streams</option>
        <option disabled>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</option>
        <option value="real-helloworld">Real: Hello World (ESM)</option>
        <option value="real-helloworld-sw">Real: Hello World (SW)</option>
        <option value="real-async-context">Real: Async Context</option>
        <option value="real-durable-objects">Real: Durable Objects</option>
        <option value="real-nodejs-compat-fs">Real: Node.js FS</option>
        <option value="real-nodejs-compat-streams">Real: Node.js Streams</option>
        <option value="real-tcp">Real: TCP Socket (Gopher)</option>
      </select>
      <select id="sort-mode">
        <option value="tree">Tree</option>
        <option value="creation">Time</option>
        <option value="duration">Duration</option>
      </select>
      <select id="filter-mode">
        <option value="all">All</option>
        <option value="user">User Only</option>
        <option value="typed">Typed Only</option>
      </select>
      <div class="dropdown" id="analysis-dropdown">
        <button class="dropdown-btn" id="analysis-btn">üî¨ Analysis ‚ñæ</button>
        <div class="dropdown-content" id="analysis-menu">
          <label class="dropdown-item" id="critical-path-item">
            <input type="checkbox" id="critical-path-check"> üî• Critical Path <span class="hotkey">C</span>
          </label>
          <label class="dropdown-item" id="bottleneck-item">
            <input type="checkbox" id="bottleneck-check"> üê¢ Bottlenecks <span class="hotkey">B</span>
          </label>
          <label class="dropdown-item" id="pattern-item">
            <input type="checkbox" id="pattern-check"> üîç Patterns <span class="hotkey">T</span>
          </label>
          <label class="dropdown-item" id="click-filter-item">
            <input type="checkbox" id="click-filter-check"> üéØ Click Filter <span class="hotkey">F</span>
          </label>
          <label class="dropdown-item" id="stack-group-item">
            <input type="checkbox" id="stack-group-check"> üìö Stack Group <span class="hotkey">G</span>
          </label>
          <label class="dropdown-item" id="temporal-edges-item">
            <input type="checkbox" id="temporal-edges-check"> ‚è±Ô∏è Temporal Edges <span class="hotkey">E</span>
          </label>
          <div class="dropdown-divider"></div>
          <label class="dropdown-item" id="accessibility-item">
            <input type="checkbox" id="accessibility-check"> ‚ôø High Contrast <span class="hotkey">A</span>
          </label>
          <div class="dropdown-divider"></div>
          <div class="threshold-section">
            <div class="threshold-header">Pattern Thresholds</div>
            <div class="threshold-item">
              <span>Sync block:</span>
              <input type="range" id="threshold-sync" min="10" max="200" value="50">
              <span id="threshold-sync-val">50ms</span>
            </div>
            <div class="threshold-item">
              <span>Long gap:</span>
              <input type="range" id="threshold-gap" min="100" max="2000" step="50" value="500">
              <span id="threshold-gap-val">500ms</span>
            </div>
            <div class="threshold-item">
              <span>Promise flood:</span>
              <input type="range" id="threshold-promise" min="5" max="50" value="20">
              <span id="threshold-promise-val">20</span>
            </div>
            <div class="threshold-item">
              <span>Callback storm:</span>
              <input type="range" id="threshold-callback" min="3" max="30" value="10">
              <span id="threshold-callback-val">10</span>
            </div>
            <div class="threshold-item">
              <span>Unbatched ops:</span>
              <input type="range" id="threshold-unbatched" min="2" max="10" value="3">
              <span id="threshold-unbatched-val">3</span>
            </div>
            <div class="threshold-item">
              <span>Fetch concurrency:</span>
              <input type="range" id="threshold-fetch" min="3" max="20" value="6">
              <span id="threshold-fetch-val">6</span>
            </div>
          </div>
        </div>
      </div>
      <button id="tutorial-btn" style="background: #e94560;">‚ùì Guide</button>
      <button id="ai-analyze-btn" style="background: #50c878;">ü§ñ Analyze</button>
    </div>
  </header>

  <div class="textarea-container" id="paste-container">
    <textarea id="json-input" placeholder="Paste async trace JSON..."></textarea>
    <button id="load-json-btn" style="margin-top: 0.4rem;">Load</button>
  </div>

  <div class="main-container">
    <div class="view-container active" id="waterfall-view">
      <div class="empty-state" id="waterfall-empty">
        <div style="font-size: 2rem; margin-bottom: 0.5rem;">üìä</div>
        <div>Load a trace to visualize</div>
      </div>
      <div class="waterfall" id="waterfall" style="display: none;"></div>
    </div>

    <div class="view-container" id="bubble-view" style="overflow: hidden; padding: 0;">
      <canvas id="bubble-canvas"></canvas>
    </div>

    <div class="view-container" id="dag-view" style="overflow: hidden; padding: 0;">
      <canvas id="dag-canvas"></canvas>
    </div>

    <div class="view-container" id="parallelism-view" style="overflow: hidden; padding: 0;">
      <canvas id="parallelism-canvas"></canvas>
    </div>

    <div class="view-container" id="breakdown-view" style="overflow: hidden; padding: 0;">
      <canvas id="breakdown-canvas"></canvas>
    </div>

    <div class="view-container" id="latency-view" style="overflow: hidden; padding: 0;">
      <canvas id="latency-canvas"></canvas>
    </div>

    <div class="view-container" id="gaps-view" style="overflow: hidden; padding: 0;">
      <canvas id="gaps-canvas"></canvas>
    </div>

    <div class="view-container" id="replay-view" style="overflow: hidden; padding: 0;">
      <canvas id="replay-canvas"></canvas>
    </div>

    <div class="view-container" id="heatmap-view" style="overflow: hidden; padding: 0;">
      <canvas id="heatmap-canvas"></canvas>
    </div>

    <div class="sidebar">
      <div class="sidebar-section">
        <h3>Overview</h3>
        <div class="section-content">
          <div class="stats">
            <div class="stat-item">
              <div class="stat-value" id="stat-duration">-</div>
              <div class="stat-label">Duration (ms)</div>
            </div>
            <div class="stat-item">
              <div class="stat-value" id="stat-resources">-</div>
              <div class="stat-label">Resources</div>
            </div>
            <div class="stat-item">
              <div class="stat-value" id="stat-sync">-</div>
              <div class="stat-label">Sync (ms)</div>
            </div>
            <div class="stat-item">
              <div class="stat-value" id="stat-async">-</div>
              <div class="stat-label">Async (ms)</div>
            </div>
          </div>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Activity Timeline</h3>
        <div class="section-content">
          <canvas id="timeline-chart" height="40" style="width: 100%; background: #0f3460; border-radius: 4px;"></canvas>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Type Distribution</h3>
        <div class="section-content">
          <canvas id="type-chart" height="80" style="width: 100%; background: #0f3460; border-radius: 4px; margin-bottom: 0.5rem;"></canvas>
          <div id="type-breakdown" style="font-size: 0.7rem;"></div>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Time Breakdown</h3>
        <div class="section-content">
          <canvas id="time-chart" height="24" style="width: 100%; border-radius: 4px;"></canvas>
          <div id="time-breakdown" style="font-size: 0.7rem; margin-top: 0.25rem;"></div>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Runtime Overhead</h3>
        <div class="section-content">
          <canvas id="overhead-chart" height="24" style="width: 100%; border-radius: 4px;"></canvas>
          <div id="overhead-breakdown" style="font-size: 0.7rem; margin-top: 0.25rem;">
            <div style="color: #666;">Load a trace to analyze</div>
          </div>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Critical Path</h3>
        <div class="section-content">
          <div id="critical-path-info" style="font-size: 0.7rem;">
            <div class="detail-item" style="color: #666;">Click üî• to show</div>
          </div>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Analysis</h3>
        <div class="section-content">
          <div id="analysis-info" style="font-size: 0.7rem;">
            <div class="detail-item" style="color: #666;">Enable üê¢ or üîç toggles</div>
          </div>
          <div id="click-filter-status" style="display: none; margin-top: 0.5rem;">
            <div class="detail-item" style="color: #e94560;">
              <strong>üéØ Filtered to resource</strong>
              <button id="clear-filter-btn" style="margin-left: 0.5rem; padding: 2px 6px; font-size: 0.65rem;">Clear</button>
            </div>
          </div>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Legend</h3>
        <div class="section-content">
          <div class="legend" id="legend"></div>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Selected</h3>
        <div class="section-content">
          <div class="chain-nav">
            <button id="nav-parent" disabled>‚Üë Parent</button>
            <button id="nav-children" disabled>‚Üì Children</button>
          </div>
          <div id="selected-details">
            <div class="detail-item" style="color: #666;">Click a resource</div>
          </div>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Timing</h3>
        <div class="section-content">
          <div id="timing-breakdown">
            <div class="detail-item" style="color: #666;">Select a resource</div>
          </div>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Stack Trace</h3>
        <div class="section-content">
          <div id="stack-trace" class="stack-trace-container">
            <div class="stack-empty">Click a resource to see its stack</div>
          </div>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Annotations</h3>
        <div class="section-content">
          <div id="annotations">
            <div class="detail-item" style="color: #666;">-</div>
          </div>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>How to Read</h3>
        <div class="section-content">
          <div id="help-hints">
            <div class="view-help" data-view="waterfall">
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4;">
            <strong>Waterfall View:</strong><br>
            ‚Ä¢ Bars show resource lifetime<br>
            ‚Ä¢ Faded portion = async wait<br>
            ‚Ä¢ Solid portion = sync execution<br>
            ‚Ä¢ Tree mode shows causality hierarchy<br>
            ‚Ä¢ Click bar to select resource
          </div>
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4; margin-top: 0.3rem;">
            <strong>Sort Modes:</strong><br>
            ‚Ä¢ Tree = causality hierarchy<br>
            ‚Ä¢ Time = creation order<br>
            ‚Ä¢ Duration = longest first
          </div>
        </div>
        <div class="view-help" data-view="bubble">
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4;">
            <strong>Bubble View:</strong><br>
            ‚Ä¢ Tree flows top‚Üídown (root at top)<br>
            ‚Ä¢ Bubble size = sync execution time<br>
            ‚Ä¢ Edge labels = async wait latency<br>
            ‚Ä¢ <span style="color: #ffd700;">Gold</span> labels = latency &gt;1ms
          </div>
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4; margin-top: 0.3rem;">
            <strong>Controls:</strong><br>
            ‚Ä¢ Scroll to zoom<br>
            ‚Ä¢ Shift+drag to pan<br>
            ‚Ä¢ Click bubble to select
          </div>
        </div>
        <div class="view-help" data-view="dag">
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4;">
            <strong>DAG View:</strong><br>
            ‚Ä¢ Force-directed dependency graph<br>
            ‚Ä¢ Arrows show trigger relationships<br>
            ‚Ä¢ Good for exploring complex deps
          </div>
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4; margin-top: 0.3rem;">
            <strong>Controls:</strong><br>
            ‚Ä¢ Drag nodes to rearrange<br>
            ‚Ä¢ Shift+drag to pan<br>
            ‚Ä¢ Scroll to zoom<br>
            ‚Ä¢ Click node to select
          </div>
        </div>
        <div class="view-help" data-view="parallelism">
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4;">
            <strong>Parallelism View:</strong><br>
            ‚Ä¢ Stacked chart = concurrent ops over time<br>
            ‚Ä¢ <span style="color: #ff6432;">Orange line</span> = serialization threshold (=1)<br>
            ‚Ä¢ <span style="color: #ff6432;">Orange bars</span> = bottleneck moments
          </div>
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4; margin-top: 0.3rem;">
            <strong>Interpretation:</strong><br>
            ‚Ä¢ High peaks = good parallelism<br>
            ‚Ä¢ Flat at 1 = sequential execution<br>
            ‚Ä¢ Colors show resource type mix
          </div>
        </div>
        <div class="view-help" data-view="breakdown">
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4;">
            <strong>Breakdown View:</strong><br>
            ‚Ä¢ Treemap = area proportional to time<br>
            ‚Ä¢ <span style="opacity: 0.9;">Solid</span> = sync execution time<br>
            ‚Ä¢ <span style="opacity: 0.4;">Faded</span> = async wait time<br>
            ‚Ä¢ Quickly see where time goes by type
          </div>
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4; margin-top: 0.3rem;">
            <strong>Interpretation:</strong><br>
            ‚Ä¢ Large boxes = time-consuming types<br>
            ‚Ä¢ High sync % = CPU-bound<br>
            ‚Ä¢ High async % = I/O-bound
          </div>
        </div>
        <div class="view-help" data-view="latency">
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4;">
            <strong>Latency View:</strong><br>
            ‚Ä¢ Histogram of async wait times<br>
            ‚Ä¢ <span style="color: #50c878;">p50</span> / <span style="color: #ffd700;">p90</span> / <span style="color: #ff6347;">p99</span> percentile lines<br>
            ‚Ä¢ Log scale for wide ranges
          </div>
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4; margin-top: 0.3rem;">
            <strong>Interpretation:</strong><br>
            ‚Ä¢ Right tail = outliers to investigate<br>
            ‚Ä¢ Wide spread = inconsistent latency<br>
            ‚Ä¢ Tight cluster = predictable timing
          </div>
        </div>
        <div class="view-help" data-view="gaps">
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4;">
            <strong>Gaps View:</strong><br>
            ‚Ä¢ <span style="color: #50c878;">Green</span> = sync execution<br>
            ‚Ä¢ <span style="color: #ff6432;">Orange</span> = idle gaps (no work)<br>
            ‚Ä¢ Shows ops waiting during gaps
          </div>
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4; margin-top: 0.3rem;">
            <strong>Interpretation:</strong><br>
            ‚Ä¢ Gaps with waiters = blocking ops<br>
            ‚Ä¢ Many small gaps = fragmented work<br>
            ‚Ä¢ Large gaps = optimization opportunity
          </div>
        </div>
        <div class="view-help" data-view="replay">
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4;">
            <strong>Replay View:</strong><br>
            ‚Ä¢ Watch request unfold in real-time<br>
            ‚Ä¢ <span style="color: #50c878;">Glowing</span> = executing now<br>
            ‚Ä¢ <span style="opacity: 0.5;">Dashed</span> = waiting for I/O<br>
            ‚Ä¢ <span style="opacity: 0.3;">Faded</span> = completed
          </div>
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4; margin-top: 0.3rem;">
            <strong>Badges:</strong><br>
            ‚Ä¢ <span style="color: #ff6432;">Orange #</span> = ops waiting on this<br>
            ‚Ä¢ üî• = critical path node<br>
            ‚Ä¢ <span style="color: #9966cc;">Purple ?</span> = unresolved promise
          </div>
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4; margin-top: 0.3rem;">
            <strong>Controls:</strong><br>
            ‚Ä¢ Play/Pause to control animation<br>
            ‚Ä¢ Click progress bar to seek<br>
            ‚Ä¢ Adjust speed: 0.5x, 1x, 2x
          </div>
        </div>
        <div class="view-help" data-view="heatmap">
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4;">
            <strong>Heatmap View:</strong><br>
            ‚Ä¢ Shows activity intensity over time<br>
            ‚Ä¢ Each row = one resource type<br>
            ‚Ä¢ Brighter cells = more activity<br>
            ‚Ä¢ Hover for exact counts
          </div>
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4; margin-top: 0.3rem;">
            <strong>Look For:</strong><br>
            ‚Ä¢ Hot spots = busy periods<br>
            ‚Ä¢ Diagonal patterns = cascading ops<br>
            ‚Ä¢ Gaps = idle time
          </div>
        </div>
            <div class="view-help" data-view="all">
              <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4; margin-top: 0.3rem;">
                <strong>Resource Types:</strong><br>
                ‚Ä¢ <span style="color: #50c878;">Typed</span> = API calls (fetch, timer, cache)<br>
                ‚Ä¢ <span style="color: #7ec8e3;">User</span> = Promises from your code<br>
                ‚Ä¢ <span style="color: #888;">Internal</span> = Runtime machinery
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="tooltip" class="tooltip" style="display: none;"></div>

  <!-- AI Analysis Modal -->
  <div id="ai-modal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 900px;">
      <div class="modal-header">
        <h2>ü§ñ AI Performance Analysis</h2>
        <button class="modal-close" id="ai-close">‚úï</button>
      </div>
      <div class="modal-body">
        <p style="margin-bottom: 1rem;">Copy the analysis prompt below and paste it into Claude, ChatGPT, or your preferred AI assistant:</p>

        <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
          <button id="ai-copy-btn" style="background: #0f3460; border: 1px solid #e94560; color: white; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer;">üìã Copy to Clipboard</button>
          <a id="ai-claude-link" href="#" target="_blank" style="background: #e94560; color: white; padding: 0.5rem 1rem; border-radius: 4px; text-decoration: none; display: inline-block;">Open in Claude ‚Üí</a>
        </div>

        <textarea id="ai-prompt" readonly style="width: 100%; height: 400px; background: #0a1628; color: #7ec8e3; border: 1px solid #0f3460; border-radius: 4px; padding: 1rem; font-family: monospace; font-size: 0.75rem; resize: vertical;"></textarea>

        <div id="ai-copy-status" style="margin-top: 0.5rem; color: #50c878; display: none;">‚úì Copied to clipboard!</div>
      </div>
    </div>
  </div>

  <!-- Tutorial Modal -->
  <div id="tutorial-modal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 900px;">
      <div class="modal-header">
        <h2>üî¨ Async Trace Optimization Guide</h2>
        <button class="modal-close" id="tutorial-close">‚úï</button>
      </div>
      <div class="modal-body">
        <div class="guide-section">
          <h3>Keyboard Shortcuts</h3>
          <table class="guide-table">
            <tr><th>Key</th><th>Action</th></tr>
            <tr><td colspan="2" style="font-weight:bold; background:#f0f0f0;">Navigation</td></tr>
            <tr><td><code>1</code>-<code>9</code></td><td>Switch views (Waterfall, Bubble, DAG, Parallelism, Breakdown, Latency, Gaps, Replay, Heatmap)</td></tr>
            <tr><td><code>?</code> or <code>H</code></td><td>Show this help guide</td></tr>
            <tr><td><code>O</code> or <code>L</code></td><td>Open file dialog to load trace</td></tr>
            <tr><td><code>P</code> or <code>V</code></td><td>Toggle paste JSON area</td></tr>
            <tr><td><code>Esc</code></td><td>Close modals / dropdowns</td></tr>
            <tr><td colspan="2" style="font-weight:bold; background:#f0f0f0;">Analysis (via dropdown)</td></tr>
            <tr><td><code>C</code></td><td>Toggle critical path highlight</td></tr>
            <tr><td><code>B</code></td><td>Toggle bottleneck detection</td></tr>
            <tr><td><code>T</code></td><td>Toggle pattern detection</td></tr>
            <tr><td><code>F</code></td><td>Toggle click-to-filter mode</td></tr>
            <tr><td><code>G</code></td><td>Toggle stack trace grouping</td></tr>
            <tr><td><code>A</code></td><td>Toggle high contrast / accessibility mode</td></tr>
            <tr><td colspan="2" style="font-weight:bold; background:#f0f0f0;">Other</td></tr>
            <tr><td><code>I</code></td><td>Open AI analysis prompt</td></tr>
            <tr><td><code>Shift+R</code></td><td>Refresh/reset current view</td></tr>
            <tr><td><code>Space</code></td><td>Play/Pause (Replay view)</td></tr>
            <tr><td><code>R</code></td><td>Reset animation (Replay view)</td></tr>
          </table>
        </div>

        <div class="guide-section">
          <h3>Visualization Views</h3>
          <table class="guide-table">
            <tr><th>View</th><th>Best For</th><th>What to Look For</th></tr>
            <tr><td><strong>1: Waterfall</strong></td><td>Timeline overview</td><td>Overall duration, resource lifetimes, sort by tree/time/duration</td></tr>
            <tr><td><strong>2: Bubble</strong></td><td>Causality analysis</td><td>Tall chains (sequential), wide trees (parallel), gold edges (>1ms)</td></tr>
            <tr><td><strong>3: DAG</strong></td><td>Complex dependencies</td><td>Drag to explore, find unexpected connections</td></tr>
            <tr><td><strong>4: Parallelism</strong></td><td>Concurrency level</td><td>Orange bars = serialization, stacked height = parallelism</td></tr>
            <tr><td><strong>5: Breakdown</strong></td><td>Time allocation</td><td>Large boxes = time hogs, solid = CPU, faded = I/O</td></tr>
            <tr><td><strong>6: Latency</strong></td><td>Wait distribution</td><td>Right tail = outliers, percentile lines (p50/p90/p99)</td></tr>
            <tr><td><strong>7: Gaps</strong></td><td>Idle time analysis</td><td>Orange gaps = nothing running, waiters during gaps</td></tr>
            <tr><td><strong>8: Replay</strong></td><td>Understanding flow</td><td>Watch operations unfold, dependency arrows, state changes</td></tr>
            <tr><td><strong>9: Heatmap</strong></td><td>Activity density</td><td>Hot spots = high activity, rows = resource types, intensity = count</td></tr>
          </table>
        </div>

        <div class="guide-section">
          <h3>1. Identify Serialization Bottlenecks</h3>
          <p><strong>Views:</strong> Bubble (2), Parallelism (4)</p>
          <p><strong>Pattern:</strong> Long vertical chains or parallelism = 1</p>
          <div class="guide-example">
            <div class="guide-bad">
              <strong>‚ùå Bad: Sequential</strong>
              <pre>const a = await fetch('/api/a');
const b = await fetch('/api/b');
const c = await fetch('/api/c');</pre>
            </div>
            <div class="guide-good">
              <strong>‚úì Good: Parallel</strong>
              <pre>const [a, b, c] = await Promise.all([
  fetch('/api/a'),
  fetch('/api/b'),
  fetch('/api/c')
]);</pre>
            </div>
          </div>
          <p class="guide-tip">üí° In Parallelism view, orange bars highlight when only 1 operation is active - these are serialization points.</p>
        </div>

        <div class="guide-section">
          <h3>2. Find Async Bottlenecks (Long Waits)</h3>
          <p><strong>Views:</strong> Bubble (2), Latency (6)</p>
          <p><strong>Pattern:</strong> <span style="color: #ffd700;">Gold edge labels</span> (>1ms) or right-tail outliers in histogram</p>
          <p><strong>Questions to ask:</strong></p>
          <ul>
            <li>Can this fetch response be cached?</li>
            <li>Is this KV/D1/DO call necessary?</li>
            <li>Can non-critical work use <code>ctx.waitUntil()</code>?</li>
          </ul>
          <p class="guide-tip">üí° The Latency histogram shows p50/p90/p99 lines - focus on outliers beyond p99.</p>
        </div>

        <div class="guide-section">
          <h3>3. Analyze CPU vs I/O Balance</h3>
          <p><strong>Views:</strong> Breakdown (5), sidebar Time Breakdown</p>
          <table class="guide-table">
            <tr><th>Ratio</th><th>Meaning</th><th>Action</th></tr>
            <tr><td>90% async (faded)</td><td>I/O bound (typical)</td><td>Optimize fetch/cache</td></tr>
            <tr><td>50/50</td><td>Mixed workload</td><td>Profile both paths</td></tr>
            <tr><td>90% sync (solid)</td><td>CPU bound</td><td>Optimize JS, use streams</td></tr>
          </table>
          <p class="guide-tip">üí° In Breakdown treemap, solid portions = sync execution, faded = async waiting.</p>
        </div>

        <div class="guide-section">
          <h3>4. Find Idle Gaps</h3>
          <p><strong>View:</strong> Gaps (7)</p>
          <p><strong>Pattern:</strong> <span style="color: #ff6432;">Orange sections</span> where no work is happening</p>
          <ul>
            <li><strong>Gaps with waiters</strong> = blocking operation, check what's pending</li>
            <li><strong>Large gaps</strong> = optimization opportunity</li>
            <li><strong>Many small gaps</strong> = fragmented execution, consider batching</li>
          </ul>
          <p class="guide-tip">üí° Hover over gaps to see which operations were waiting during that time.</p>
        </div>

        <div class="guide-section">
          <h3>5. Reduce Runtime Overhead</h3>
          <p><strong>Pattern:</strong> Many dimmed (internal) promises</p>
          <p>Use <strong>"User Only"</strong> filter to focus on your code.</p>
          <ul>
            <li>Deeply nested <code>.then()</code> chains create overhead</li>
            <li>Flatten with <code>async/await</code></li>
            <li>Reduce intermediate transformations</li>
          </ul>
        </div>

        <div class="guide-section">
          <h3>6. Find Redundant Operations</h3>
          <p><strong>Pattern:</strong> Multiple fetch/cache with same URL annotation</p>
          <div class="guide-example">
            <div class="guide-bad">
              <strong>‚ùå Duplicate fetches</strong>
              <pre>const userA = await fetch('/user/123');
// later...
const userB = await fetch('/user/123');</pre>
            </div>
            <div class="guide-good">
              <strong>‚úì Cache in variable</strong>
              <pre>const user = await fetch('/user/123');
// reuse `user` throughout</pre>
            </div>
          </div>
        </div>

        <div class="guide-section">
          <h3>7. Find Critical Path</h3>
          <p><strong>View:</strong> Waterfall (1) with üî• button, Bubble (2)</p>
          <p>The critical path determines total request time.</p>
          <ol>
            <li>Click üî• in toolbar to highlight critical path</li>
            <li>Or: Find resource with latest <code>callbackEndedAt</code></li>
            <li>Navigate up to root using ‚Üë button</li>
            <li>Sum of edge latencies = minimum request time</li>
          </ol>
          <p class="guide-tip">üí° Only optimizing operations on the critical path improves overall latency.</p>
        </div>

        <div class="guide-section">
          <h3>8. Watch Request Flow</h3>
          <p><strong>View:</strong> Replay (8)</p>
          <p>Use replay to understand how your request executes:</p>
          <ul>
            <li><strong>Glowing circles</strong> = currently executing</li>
            <li><strong>Dashed outline</strong> = waiting for I/O</li>
            <li><strong>Faded circles</strong> = completed</li>
            <li><strong>Arrows</strong> = causality (parent triggered child)</li>
          </ul>
          <p class="guide-tip">üí° Use 0.5x speed to carefully observe the sequence of operations.</p>
        </div>

        <div class="guide-section">
          <h3>Visual Patterns Quick Reference</h3>
          <table class="guide-table">
            <tr><th>Visual Pattern</th><th>Where</th><th>Meaning</th><th>Fix</th></tr>
            <tr><td>Tall narrow tree</td><td>Bubble</td><td>Sequential ops</td><td>Promise.all</td></tr>
            <tr><td style="color: #ffd700;">Gold edges</td><td>Bubble</td><td>High latency</td><td>Cache/batch</td></tr>
            <tr><td style="color: #ff6432;">Orange bars</td><td>Parallelism</td><td>Serialization</td><td>Parallelize</td></tr>
            <tr><td style="color: #ff6432;">Orange gaps</td><td>Gaps</td><td>Idle time</td><td>Start work earlier</td></tr>
            <tr><td>Right tail</td><td>Latency</td><td>Outliers</td><td>Investigate slow ops</td></tr>
            <tr><td>Large solid boxes</td><td>Breakdown</td><td>CPU heavy</td><td>Optimize algorithm</td></tr>
            <tr><td>Large faded boxes</td><td>Breakdown</td><td>I/O heavy</td><td>Cache/parallelize</td></tr>
            <tr><td>Wide shallow tree</td><td>Bubble</td><td>Parallelism ‚úì</td><td>Already good</td></tr>
          </table>
        </div>

        <div class="guide-section">
          <h3>Accessibility Mode</h3>
          <p>Press <code>A</code> or click the <strong>‚ôø High Contrast</strong> button to enable accessibility mode.</p>
          <p>In this mode:</p>
          <ul>
            <li><strong>Patterns</strong> - Different resource types get distinct patterns (dots, stripes, crosshatch) in addition to colors</li>
            <li><strong>Higher contrast</strong> - Faded portions are more visible with diagonal stripes</li>
            <li><strong>Sync/Async dividers</strong> - Clear white lines separate sync and async portions in Breakdown view</li>
            <li><strong>Bordered sync regions</strong> - Sync execution shown with white borders in Waterfall</li>
          </ul>
          <p class="guide-tip">üí° Accessibility mode helps users who have difficulty distinguishing colors.</p>
        </div>

        <div class="guide-section">
          <h3>Pattern Detection &amp; Thresholds</h3>
          <p>Press <code>T</code> or enable <strong>üîç Patterns</strong> to detect anti-patterns based on "Broken Promises" concepts.</p>
          <p><strong>Severity Levels:</strong></p>
          <ul>
            <li><span style="color: #ff00ff;">üî¥ High</span> - Significant impact: sequential-await, sync-flood, unbatched-ops</li>
            <li><span style="color: #cc66ff;">üü° Medium</span> - Worth investigating: waterfall-fetch, promise-flood, callback-storm, fetch-flood</li>
            <li><span style="color: #9966cc;">üü¢ Low</span> - Minor issues: unresolved-promise, redundant-timers, hot-callback</li>
          </ul>
          <p><strong>Configurable Thresholds</strong> (in Analysis dropdown):</p>
          <table class="guide-table">
            <tr><th>Threshold</th><th>Default</th><th>Detects</th></tr>
            <tr><td>Sync block</td><td>50ms</td><td>Event loop blocking operations</td></tr>
            <tr><td>Long gap</td><td>500ms</td><td>Operations waiting too long</td></tr>
            <tr><td>Promise flood</td><td>20</td><td>Too many promises created in 1ms</td></tr>
            <tr><td>Callback storm</td><td>10</td><td>Too many callbacks in 1ms</td></tr>
            <tr><td>Unbatched ops</td><td>3</td><td>KV/DO ops that could be batched</td></tr>
            <tr><td>Fetch concurrency</td><td>6</td><td>Parallel fetches (connection risk)</td></tr>
          </table>
          <p class="guide-tip">üí° Adjust thresholds based on your workload - lower values detect more issues, higher values reduce noise.</p>
        </div>

        <div class="guide-section">
          <h3>Recommended Workflow</h3>
          <ol>
            <li><strong>Overview</strong> ‚Üí Start with Waterfall (1) to see timeline</li>
            <li><strong>Parallelism check</strong> ‚Üí Switch to Parallelism (4), look for orange serialization</li>
            <li><strong>Time allocation</strong> ‚Üí Check Breakdown (5) for where time goes</li>
            <li><strong>Causality</strong> ‚Üí Use Bubble (2) to understand dependencies</li>
            <li><strong>Critical path</strong> ‚Üí Click üî• to highlight what matters</li>
            <li><strong>Latency outliers</strong> ‚Üí Check Latency (6) histogram for anomalies</li>
            <li><strong>Idle time</strong> ‚Üí Review Gaps (7) for wasted time</li>
            <li><strong>Understand flow</strong> ‚Üí Use Replay (8) to watch execution</li>
            <li><strong>Implement fix</strong> ‚Üí Re-trace and compare</li>
          </ol>
        </div>
      </div>
    </div>
  </div>

  <script>
    const TYPE_COLORS = {
      'root': '#e94560',
      'js-promise': '#7ec8e3',
      'kj-promise': '#50c878',
      'fetch': '#ff6347',
      'cache-get': '#00ced1',
      'cache-put': '#20b2aa',
      'timer': '#ffd700',
      'stream-read': '#87ceeb',
      'stream-write': '#4682b4',
      'websocket': '#dc143c',
      'other': '#808080'
    };

    let traceData = null;
    let selectedResource = null;
    let highlightedChain = new Set();
    let criticalPathSet = new Set();  // Resources on the critical path
    let showCriticalPath = false;
    let criticalPathInfo = null;  // { path: [], totalLatency: 0 }
    let currentView = 'waterfall';
    let bubbles = [];
    let cachedBubbleLayout = null;  // Cache layout to prevent re-rendering on selection
    let canvas, ctx;

    // DAG view state
    let dagNodes = [];
    let dagSimulationRunning = false;
    let dagDragNode = null;
    let dagPanX = 0, dagPanY = 0;
    let dagZoom = 1;
    let dagIsPanning = false;
    let dagLastMouseX = 0, dagLastMouseY = 0;

    // Pan and zoom state for bubble view
    let panX = 0, panY = 0;
    let zoom = 1;
    let isPanning = false;
    let lastMouseX = 0, lastMouseY = 0;

    // Replay state
    let replayTime = 0;
    let replayPlaying = false;
    let replaySpeed = 1;
    let replayAnimationId = null;

    // Accessibility mode - uses patterns instead of colors
    let accessibilityMode = false;

    // Analysis toggles
    let showBottlenecks = false;
    let showPatterns = false;
    let clickToFilterEnabled = false;
    let stackTraceGrouping = false;
    let showTemporalEdges = false;
    let clickFilterResourceId = null;  // Currently filtered resource
    let detectedBottlenecks = [];  // Top N slowest resources
    let detectedPatterns = [];  // Detected anti-patterns
    let temporalEdges = [];  // Edges based on callback timing

    // Gaps view state for hover interaction
    let gapsData = [];  // Computed gaps from last render
    let gapsRenderParams = null;  // Rendering parameters for hit detection

    // Pattern detection thresholds (configurable via UI)
    let patternThresholds = {
      syncBlockMs: 50,       // Event loop blocking threshold (ms)
      longGapMs: 500,        // Long async gap threshold (ms)
      promiseFlood: 20,      // Promise accumulation threshold (count per ms)
      callbackStorm: 10,     // Callback storm threshold (count per ms)
      unbatchedOps: 3,       // Unbatched operations threshold (count)
      fetchFlood: 6,         // Concurrent fetch risk threshold (count)
      hotCallback: 5         // Hot callback threshold (children count)
    };

    // Pattern cache for accessibility mode
    const patternCache = new Map();

    function getPattern(ctx, type, color) {
      const key = `${type}-${color}-${accessibilityMode}`;
      if (patternCache.has(key)) return patternCache.get(key);

      const patternCanvas = document.createElement('canvas');
      const pctx = patternCanvas.getContext('2d');
      patternCanvas.width = 12;
      patternCanvas.height = 12;

      // Different patterns for different resource types
      const patterns = {
        'root': 'solid',
        'js-promise': 'dots',
        'fetch': 'diagonal',
        'timer': 'horizontal',
        'cache-get': 'vertical',
        'cache-put': 'crosshatch',
        'kv-get': 'zigzag',
        'kv-put': 'diamond',
      };

      const patternType = patterns[type] || 'dots';

      pctx.fillStyle = color;
      pctx.fillRect(0, 0, 12, 12);

      if (accessibilityMode) {
        pctx.strokeStyle = 'rgba(255,255,255,0.6)';
        pctx.lineWidth = 1.5;

        switch (patternType) {
          case 'dots':
            pctx.fillStyle = 'rgba(255,255,255,0.5)';
            pctx.beginPath();
            pctx.arc(3, 3, 1.5, 0, Math.PI * 2);
            pctx.arc(9, 9, 1.5, 0, Math.PI * 2);
            pctx.fill();
            break;
          case 'diagonal':
            pctx.beginPath();
            pctx.moveTo(0, 12);
            pctx.lineTo(12, 0);
            pctx.stroke();
            break;
          case 'horizontal':
            pctx.beginPath();
            pctx.moveTo(0, 6);
            pctx.lineTo(12, 6);
            pctx.stroke();
            break;
          case 'vertical':
            pctx.beginPath();
            pctx.moveTo(6, 0);
            pctx.lineTo(6, 12);
            pctx.stroke();
            break;
          case 'crosshatch':
            pctx.beginPath();
            pctx.moveTo(0, 6);
            pctx.lineTo(12, 6);
            pctx.moveTo(6, 0);
            pctx.lineTo(6, 12);
            pctx.stroke();
            break;
          case 'zigzag':
            pctx.beginPath();
            pctx.moveTo(0, 6);
            pctx.lineTo(4, 2);
            pctx.lineTo(8, 10);
            pctx.lineTo(12, 6);
            pctx.stroke();
            break;
          case 'diamond':
            pctx.beginPath();
            pctx.moveTo(6, 1);
            pctx.lineTo(11, 6);
            pctx.lineTo(6, 11);
            pctx.lineTo(1, 6);
            pctx.closePath();
            pctx.stroke();
            break;
        }
      }

      const pattern = ctx.createPattern(patternCanvas, 'repeat');
      patternCache.set(key, pattern);
      return pattern;
    }

    function clearPatternCache() {
      patternCache.clear();
    }

    // Check if a hex color is light (for choosing text color)
    function isLightColor(hexColor) {
      // Handle hex colors like #7ec8e3
      const hex = hexColor.replace('#', '');
      const r = parseInt(hex.substr(0, 2), 16);
      const g = parseInt(hex.substr(2, 2), 16);
      const b = parseInt(hex.substr(4, 2), 16);
      // Calculate relative luminance (per WCAG)
      const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
      return luminance > 0.5;
    }

    document.addEventListener('DOMContentLoaded', () => {
      canvas = document.getElementById('bubble-canvas');
      ctx = canvas.getContext('2d');

      // View switching
      document.getElementById('view-select').addEventListener('change', (e) => {
        currentView = e.target.value;
        document.querySelectorAll('.view-container').forEach(v => v.classList.remove('active'));
        document.getElementById(currentView + '-view').classList.add('active');
        updateViewHelp();
        updateControlStates();
        if (traceData) render();
      });

      // Initialize help visibility
      updateViewHelp();
      updateControlStates();

      // Collapsible sidebar sections
      document.querySelectorAll('.sidebar-section h3').forEach(header => {
        header.addEventListener('click', () => {
          header.parentElement.classList.toggle('collapsed');
        });
      });

      document.getElementById('file-input').addEventListener('change', handleFileInput);
      document.getElementById('paste-btn').addEventListener('click', () => {
        document.getElementById('paste-container').classList.toggle('show');
      });
      document.getElementById('load-json-btn').addEventListener('click', loadFromTextarea);
      document.getElementById('demo-select').addEventListener('change', loadDemoData);
      document.getElementById('sort-mode').addEventListener('change', render);
      document.getElementById('filter-mode').addEventListener('change', () => {
        cachedBubbleLayout = null;  // Re-layout when filter changes
        dagNodes = [];  // Re-initialize DAG when filter changes
        render();
      });
      document.getElementById('nav-parent').addEventListener('click', navigateToParent);
      document.getElementById('nav-children').addEventListener('click', navigateToChildren);

      // Analysis dropdown toggle
      document.getElementById('analysis-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        const menu = document.getElementById('analysis-menu');
        const btn = document.getElementById('analysis-btn');
        menu.classList.toggle('show');
        btn.classList.toggle('active', menu.classList.contains('show'));
      });

      // Close dropdown when clicking outside
      document.addEventListener('click', (e) => {
        if (!e.target.closest('#analysis-dropdown')) {
          document.getElementById('analysis-menu').classList.remove('show');
          document.getElementById('analysis-btn').classList.remove('active');
        }
      });

      // Analysis checkbox handlers
      document.getElementById('critical-path-check').addEventListener('change', toggleCriticalPath);
      document.getElementById('bottleneck-check').addEventListener('change', toggleBottlenecks);
      document.getElementById('pattern-check').addEventListener('change', togglePatterns);
      document.getElementById('click-filter-check').addEventListener('change', toggleClickFilter);
      document.getElementById('stack-group-check').addEventListener('change', toggleStackGrouping);
      document.getElementById('temporal-edges-check').addEventListener('change', toggleTemporalEdges);
      document.getElementById('accessibility-check').addEventListener('change', toggleAccessibility);

      // Threshold slider handlers
      function setupThresholdSlider(id, key, suffix = '') {
        const slider = document.getElementById(id);
        const valueSpan = document.getElementById(id + '-val');
        slider.addEventListener('input', () => {
          patternThresholds[key] = parseInt(slider.value);
          valueSpan.textContent = slider.value + suffix;
          if (showPatterns && traceData) {
            detectPatterns();
            render();
          }
        });
      }
      setupThresholdSlider('threshold-sync', 'syncBlockMs', 'ms');
      setupThresholdSlider('threshold-gap', 'longGapMs', 'ms');
      setupThresholdSlider('threshold-promise', 'promiseFlood', '');
      setupThresholdSlider('threshold-callback', 'callbackStorm', '');
      setupThresholdSlider('threshold-unbatched', 'unbatchedOps', '');
      setupThresholdSlider('threshold-fetch', 'fetchFlood', '');

      // Tutorial modal
      document.getElementById('tutorial-btn').addEventListener('click', () => {
        document.getElementById('tutorial-modal').style.display = 'flex';
      });
      document.getElementById('tutorial-close').addEventListener('click', () => {
        document.getElementById('tutorial-modal').style.display = 'none';
      });
      document.getElementById('tutorial-modal').addEventListener('click', (e) => {
        if (e.target.id === 'tutorial-modal') {
          document.getElementById('tutorial-modal').style.display = 'none';
        }
      });
      document.addEventListener('keydown', (e) => {
        // Don't handle hotkeys when typing in input fields
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

        if (e.key === 'Escape') {
          document.getElementById('tutorial-modal').style.display = 'none';
          document.getElementById('ai-modal').style.display = 'none';
          document.getElementById('paste-container').classList.remove('show');
          document.getElementById('analysis-menu').classList.remove('show');
          document.getElementById('analysis-btn').classList.remove('active');
          return;
        }

        // Help hotkey: ? or H
        if (e.key === '?' || e.key === 'h' || e.key === 'H') {
          document.getElementById('tutorial-modal').style.display = 'flex';
          return;
        }

        // Load hotkey: O (Open) or L (Load)
        if (e.key === 'o' || e.key === 'O' || e.key === 'l' || e.key === 'L') {
          document.getElementById('file-input').click();
          return;
        }

        // Paste hotkey: P or V
        if (e.key === 'p' || e.key === 'P' || e.key === 'v' || e.key === 'V') {
          document.getElementById('paste-container').classList.toggle('show');
          if (document.getElementById('paste-container').classList.contains('show')) {
            document.getElementById('json-input').focus();
          }
          return;
        }

        // Critical path hotkey: C
        if (e.key === 'c' || e.key === 'C') {
          toggleCriticalPath(true);
          return;
        }

        // AI Analyze hotkey: I
        if (e.key === 'i' || e.key === 'I') {
          openAIAnalysis();
          return;
        }

        // View hotkeys: 1-9 for different views
        const viewKeys = {
          '1': 'waterfall',
          '2': 'bubble',
          '3': 'dag',
          '4': 'parallelism',
          '5': 'breakdown',
          '6': 'latency',
          '7': 'gaps',
          '8': 'replay',
          '9': 'heatmap'
        };

        if (viewKeys[e.key]) {
          const newView = viewKeys[e.key];
          currentView = newView;
          document.getElementById('view-select').value = newView;
          document.querySelectorAll('.view-container').forEach(v => v.classList.remove('active'));
          document.getElementById(newView + '-view').classList.add('active');
          updateViewHelp();
          updateControlStates();
          if (traceData) render();
          return;
        }

        // Accessibility mode toggle: A
        if (e.key === 'a' || e.key === 'A') {
          toggleAccessibility(true);
          return;
        }

        // Bottleneck detection toggle: B
        if (e.key === 'b' || e.key === 'B') {
          toggleBottlenecks(true);
          return;
        }

        // Pattern detection toggle: T
        if (e.key === 't' || e.key === 'T') {
          togglePatterns(true);
          return;
        }

        // Click-to-filter toggle: F
        if (e.key === 'f' || e.key === 'F') {
          toggleClickFilter(true);
          return;
        }

        // Stack trace grouping toggle: G
        if (e.key === 'g' || e.key === 'G') {
          toggleStackGrouping(true);
          return;
        }

        // Temporal edges toggle: E
        if (e.key === 'e' || e.key === 'E') {
          toggleTemporalEdges(true);
          return;
        }

        // Refresh/Reset current view: Shift+R
        if (e.shiftKey && (e.key === 'r' || e.key === 'R')) {
          if (traceData) {
            // Reset view-specific state
            if (currentView === 'bubble') {
              panX = 0; panY = 0; zoom = 1;
              cachedBubbleLayout = null;
            } else if (currentView === 'dag') {
              dagPanX = 0; dagPanY = 0; dagZoom = 1;
              dagNodes = [];
            } else if (currentView === 'replay') {
              stopReplayAnimation();
              replayTime = 0;
            }
            render();
          }
          return;
        }

        // Replay controls: Space = play/pause, R = reset
        if (currentView === 'replay' && traceData) {
          if (e.key === ' ' || e.key === 'Space') {
            e.preventDefault();
            if (replayPlaying) {
              stopReplayAnimation();
            } else {
              if (replayTime >= traceData.requestDurationNs) replayTime = 0;
              startReplayAnimation();
            }
            renderReplayFrame();
          } else if (e.key === 'r' || e.key === 'R') {
            stopReplayAnimation();
            replayTime = 0;
            renderReplayFrame();
          }
        }
      });

      // AI Analysis modal
      document.getElementById('ai-analyze-btn').addEventListener('click', openAIAnalysis);
      document.getElementById('ai-close').addEventListener('click', () => {
        document.getElementById('ai-modal').style.display = 'none';
      });
      document.getElementById('ai-modal').addEventListener('click', (e) => {
        if (e.target.id === 'ai-modal') {
          document.getElementById('ai-modal').style.display = 'none';
        }
      });
      document.getElementById('ai-copy-btn').addEventListener('click', () => {
        const prompt = document.getElementById('ai-prompt').value;
        navigator.clipboard.writeText(prompt).then(() => {
          const status = document.getElementById('ai-copy-status');
          status.style.display = 'block';
          setTimeout(() => status.style.display = 'none', 2000);
        });
      });

      // Clear filter button
      document.getElementById('clear-filter-btn').addEventListener('click', () => {
        clickFilterResourceId = null;
        document.getElementById('click-filter-check').checked = false;
        clickToFilterEnabled = false;
        updateAnalysisInfo();
        updateAnalysisButtonState();
        if (traceData) render();
      });

      canvas.addEventListener('mousemove', handleBubbleMouseMove);
      canvas.addEventListener('click', handleBubbleClick);
      canvas.addEventListener('mouseleave', () => {
        document.getElementById('tooltip').style.display = 'none';
        isPanning = false;
      });

      // Pan with middle mouse or shift+left drag
      canvas.addEventListener('mousedown', (e) => {
        if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
          isPanning = true;
          lastMouseX = e.clientX;
          lastMouseY = e.clientY;
          canvas.style.cursor = 'grabbing';
          e.preventDefault();
        }
      });

      canvas.addEventListener('mouseup', () => {
        isPanning = false;
        canvas.style.cursor = 'default';
      });

      canvas.addEventListener('mousemove', (e) => {
        if (isPanning) {
          panX += e.clientX - lastMouseX;
          panY += e.clientY - lastMouseY;
          lastMouseX = e.clientX;
          lastMouseY = e.clientY;
          renderBubble();
        }
      });

      // Zoom with scroll wheel
      canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const oldZoom = zoom;
        const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
        zoom = Math.max(0.25, Math.min(3, zoom * zoomDelta));

        // Adjust pan to zoom toward mouse position
        panX = mouseX - (mouseX - panX) * (zoom / oldZoom);
        panY = mouseY - (mouseY - panY) * (zoom / oldZoom);

        renderBubble();
      });

      // DAG canvas event handlers
      const dagCanvas = document.getElementById('dag-canvas');

      dagCanvas.addEventListener('mousedown', (e) => {
        const rect = dagCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left - dagPanX) / dagZoom;
        const y = (e.clientY - rect.top - dagPanY) / dagZoom;

        // Check if clicking on a node
        const clickedNode = dagNodes.find(n => {
          const dx = x - n.x, dy = y - n.y;
          return Math.sqrt(dx*dx + dy*dy) <= n.radius;
        });

        if (clickedNode && !e.shiftKey) {
          dagDragNode = clickedNode;
          clickedNode.fixed = true;
          dagCanvas.style.cursor = 'grabbing';
        } else if (e.shiftKey || e.button === 1) {
          dagIsPanning = true;
          dagLastMouseX = e.clientX;
          dagLastMouseY = e.clientY;
          dagCanvas.style.cursor = 'grabbing';
        }
      });

      dagCanvas.addEventListener('mousemove', (e) => {
        const rect = dagCanvas.getBoundingClientRect();

        if (dagDragNode) {
          dagDragNode.x = (e.clientX - rect.left - dagPanX) / dagZoom;
          dagDragNode.y = (e.clientY - rect.top - dagPanY) / dagZoom;
          renderDAG();
        } else if (dagIsPanning) {
          dagPanX += e.clientX - dagLastMouseX;
          dagPanY += e.clientY - dagLastMouseY;
          dagLastMouseX = e.clientX;
          dagLastMouseY = e.clientY;
          renderDAG();
        } else {
          // Hover detection
          const x = (e.clientX - rect.left - dagPanX) / dagZoom;
          const y = (e.clientY - rect.top - dagPanY) / dagZoom;
          const hovered = dagNodes.find(n => {
            const dx = x - n.x, dy = y - n.y;
            return Math.sqrt(dx*dx + dy*dy) <= n.radius;
          });

          if (hovered) {
            dagCanvas.style.cursor = 'pointer';
            const r = hovered.resource;
            const tooltip = document.getElementById('tooltip');
            const patternHTML = getPatternTooltipHTML(r.asyncId);
            const criticalPathHTML = getCriticalPathTooltipHTML(r.asyncId);
            tooltip.innerHTML = `
              <div class="tooltip-title">${r.type} #${r.asyncId}</div>
              <div>Trigger: #${r.triggerId || 'root'}</div>
              <div>Children: ${(traceData.childrenMap.get(r.asyncId) || []).length}</div>
              ${criticalPathHTML}
              ${patternHTML}
            `;
            tooltip.style.display = 'block';
            tooltip.style.left = (e.clientX + 10) + 'px';
            tooltip.style.top = (e.clientY + 10) + 'px';
          } else {
            dagCanvas.style.cursor = 'default';
            document.getElementById('tooltip').style.display = 'none';
          }
        }
      });

      dagCanvas.addEventListener('mouseup', (e) => {
        if (dagDragNode) {
          dagDragNode.fixed = false;
          dagDragNode = null;
        }
        dagIsPanning = false;
        dagCanvas.style.cursor = 'default';
      });

      dagCanvas.addEventListener('click', (e) => {
        if (dagDragNode) return;  // Was dragging, not clicking

        const rect = dagCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left - dagPanX) / dagZoom;
        const y = (e.clientY - rect.top - dagPanY) / dagZoom;

        const clicked = dagNodes.find(n => {
          const dx = x - n.x, dy = y - n.y;
          return Math.sqrt(dx*dx + dy*dy) <= n.radius;
        });

        if (clicked) {
          selectResource(clicked.resource);
          // Handle click-to-filter
          if (clickToFilterEnabled) {
            applyClickFilter(clicked.resource.asyncId);
          }
        }
      });

      dagCanvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const rect = dagCanvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const oldZoom = dagZoom;
        const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
        dagZoom = Math.max(0.1, Math.min(5, dagZoom * zoomDelta));

        dagPanX = mouseX - (mouseX - dagPanX) * (dagZoom / oldZoom);
        dagPanY = mouseY - (mouseY - dagPanY) * (dagZoom / oldZoom);

        renderDAG();
      });

      dagCanvas.addEventListener('mouseleave', () => {
        document.getElementById('tooltip').style.display = 'none';
        dagIsPanning = false;
        if (dagDragNode) {
          dagDragNode.fixed = false;
          dagDragNode = null;
        }
      });

      // Gaps canvas event handlers
      const gapsCanvas = document.getElementById('gaps-canvas');

      gapsCanvas.addEventListener('mousemove', (e) => {
        if (!gapsRenderParams || !gapsData.length) return;

        const rect = gapsCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const { padding, barWidth, numBuckets } = gapsRenderParams;

        // Check if we're in the chart area
        if (x < padding.left || x > gapsCanvas.width - padding.right ||
            y < padding.top || y > gapsCanvas.height - padding.bottom) {
          document.getElementById('tooltip').style.display = 'none';
          gapsCanvas.style.cursor = 'default';
          return;
        }

        // Find which gap (if any) we're hovering over
        const hoveredGap = gapsData.find(gap => {
          const gapX = padding.left + gap.startBucket * barWidth;
          const gapWidth = (gap.endBucket - gap.startBucket) * barWidth;
          return x >= gapX && x <= gapX + gapWidth;
        });

        if (hoveredGap) {
          gapsCanvas.style.cursor = 'pointer';
          const tooltip = document.getElementById('tooltip');

          // Build waiting resources summary
          const waitingByType = {};
          hoveredGap.waitingResources.forEach(r => {
            waitingByType[r.type] = (waitingByType[r.type] || 0) + 1;
          });
          const waitingSummary = Object.entries(waitingByType)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5)
            .map(([type, count]) => `<div style="color: #7ec8e3; font-size: 0.7rem;">‚Ä¢ ${type}: ${count}</div>`)
            .join('');

          tooltip.innerHTML = `
            <div class="tooltip-title">Idle Gap</div>
            <div>Duration: ${hoveredGap.durationMs.toFixed(2)}ms</div>
            <div>Time: ${(hoveredGap.startNs / 1e6).toFixed(2)}ms - ${(hoveredGap.endNs / 1e6).toFixed(2)}ms</div>
            <div style="margin-top: 0.3rem; font-weight: bold; color: #ff6432;">${hoveredGap.waitingResources.length} operations waiting:</div>
            ${waitingSummary || '<div style="color: #666; font-size: 0.7rem;">No async operations waiting</div>'}
            ${Object.keys(waitingByType).length > 5 ? `<div style="color: #888; font-size: 0.65rem;">...and ${Object.keys(waitingByType).length - 5} more types</div>` : ''}
          `;
          tooltip.style.display = 'block';
          tooltip.style.left = (e.clientX + 10) + 'px';
          tooltip.style.top = (e.clientY + 10) + 'px';
        } else {
          document.getElementById('tooltip').style.display = 'none';
          gapsCanvas.style.cursor = 'default';
        }
      });

      gapsCanvas.addEventListener('mouseleave', () => {
        document.getElementById('tooltip').style.display = 'none';
      });

      window.addEventListener('resize', () => {
        if (traceData) {
          if (currentView === 'bubble') {
            cachedBubbleLayout = null;  // Invalidate cache on resize
            renderBubble();
          } else if (currentView === 'dag') {
            renderDAG();
          } else if (currentView === 'parallelism') {
            renderParallelism();
          } else if (currentView === 'breakdown') {
            renderBreakdown();
          } else if (currentView === 'latency') {
            renderLatency();
          } else if (currentView === 'gaps') {
            renderGaps();
          } else if (currentView === 'replay') {
            renderReplayFrame();
          }
        }
      });
    });

    function handleFileInput(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          traceData = JSON.parse(e.target.result);
          processAndRender();
        } catch (err) {
          alert('Invalid JSON: ' + err.message);
        }
      };
      reader.readAsText(file);
    }

    function loadFromTextarea() {
      try {
        traceData = JSON.parse(document.getElementById('json-input').value);
        processAndRender();
        document.getElementById('paste-container').classList.remove('show');
      } catch (err) {
        alert('Invalid JSON: ' + err.message);
      }
    }

    async function loadDemoData() {
      const demo = document.getElementById('demo-select').value;
      if (!demo) return;
      const files = {
          'timer': 'sample-trace.json',
          'async-patterns': 'sample-async-patterns.json',
          'chat-room': 'sample-chat-room.json',
          'good-parallel': 'sample-good-parallel.json',
          'bad-sequential': 'sample-bad-sequential.json',
          'bad-duplicates': 'sample-bad-duplicates.json',
          'waterfall-fetches': 'sample-waterfall-fetches.json',
          'unresolved-promises': 'sample-unresolved-promises.json',
          'long-async-gaps': 'sample-long-async-gaps.json',
          'redundant-timers': 'sample-redundant-timers.json',
          'cache-misses': 'sample-cache-misses.json',
          'streams-pipeline': 'sample-streams-pipeline.json',
          'pathological': 'sample-pathological-streams.json',
          // Real traces captured from workerd samples
          'real-helloworld': 'sample-real-helloworld.json',
          'real-helloworld-sw': 'sample-real-helloworld-sw.json',
          'real-async-context': 'sample-real-async-context.json',
          'real-durable-objects': 'sample-real-durable-objects.json',
          'real-nodejs-compat-fs': 'sample-real-nodejs-compat-fs.json',
          'real-nodejs-compat-streams': 'sample-real-nodejs-compat-streams.json',
          'real-tcp': 'sample-real-tcp.json'
        };
      try {
        const response = await fetch(files[demo]);
        traceData = await response.json();
        processAndRender();
      } catch (err) {
        alert('Failed to load: ' + err.message);
      }
    }

    // Classify a resource as 'typed', 'user', or 'internal'
    function classifyResource(r) {
      // Typed resources are explicit API operations (not js-promise)
      if (r.type !== 'js-promise') {
        return 'typed';
      }
      // JS promises with stack traces pointing to user code = user
      const st = traceData.stackTraceMap.get(r.stackTraceId);
      if (st && st.frames && st.frames.length > 0) {
        // Check if any frame is in user code (not empty, not internal)
        const hasUserFrame = st.frames.some(f =>
          f && !f.startsWith('node:') && !f.startsWith('cloudflare:'));
        if (hasUserFrame) return 'user';
      }
      // JS promises with empty stack traces = internal runtime machinery
      return 'internal';
    }

    function shouldShowResource(r) {
      const filterMode = document.getElementById('filter-mode').value;
      if (filterMode === 'all') return true;

      const classification = r._classification || classifyResource(r);
      if (filterMode === 'user') {
        return classification === 'typed' || classification === 'user';
      }
      if (filterMode === 'typed') {
        return classification === 'typed';
      }
      return true;
    }

    function processAndRender() {
      cachedBubbleLayout = null;  // Invalidate layout cache when loading new data
      dagNodes = [];  // Invalidate DAG layout when loading new data
      dagPanX = 0; dagPanY = 0; dagZoom = 1;  // Reset DAG pan/zoom
      panX = 0; panY = 0; zoom = 1;  // Reset pan/zoom

      traceData.resourceMap = new Map();
      traceData.resources.forEach(r => traceData.resourceMap.set(r.asyncId, r));

      traceData.stackTraceMap = new Map();
      traceData.stackTraces.forEach(st => traceData.stackTraceMap.set(st.id, st));

      traceData.annotationMap = new Map();
      traceData.annotations.forEach(a => {
        if (!traceData.annotationMap.has(a.asyncId)) traceData.annotationMap.set(a.asyncId, []);
        traceData.annotationMap.get(a.asyncId).push(a);
      });

      // Classify each resource
      traceData.resources.forEach(r => {
        r._classification = classifyResource(r);
      });

      traceData.childrenMap = new Map();
      traceData.resources.forEach(r => {
        if (r.triggerId !== 0) {
          if (!traceData.childrenMap.has(r.triggerId)) traceData.childrenMap.set(r.triggerId, []);
          traceData.childrenMap.get(r.triggerId).push(r.asyncId);
        }
      });

      traceData.depthMap = new Map();
      function calcDepth(id, depth) {
        traceData.depthMap.set(id, depth);
        (traceData.childrenMap.get(id) || []).forEach(cid => calcDepth(cid, depth + 1));
      }
      const root = traceData.resources.find(r => r.type === 'root');
      if (root) calcDepth(root.asyncId, 0);

      updateStats();
      updateLegend();
      renderRuntimeOverheadChart();
      computeCriticalPath();
      updateCriticalPathInfo();
      // Run detection if enabled
      if (showBottlenecks) detectBottlenecks();
      if (showPatterns) detectPatterns();
      if (showTemporalEdges) computeTemporalEdges();
      // Reset click filter on new data
      clickFilterResourceId = null;
      // Update analysis sidebar with new data
      updateAnalysisInfo();
      render();
    }

    // Compute the critical path - the chain of resources that determines minimum latency.
    // The critical path is the longest sequential chain through the dependency graph,
    // where "length" is measured by cumulative time (creation to callback end).
    function computeCriticalPath() {
      if (!traceData) return;

      criticalPathSet.clear();
      criticalPathInfo = null;

      // For each resource, compute the longest path FROM ROOT ending at that resource.
      // pathLength[id] = { length: cumulative time, predecessor: id that led here }
      const pathInfo = new Map();

      // Sort by creation time to process in roughly topological order
      const sorted = [...traceData.resources].sort((a, b) => a.createdAt - b.createdAt);

      sorted.forEach(r => {
        // When does this resource's work complete?
        const myEnd = r.callbackEndedAt > 0 ? r.callbackEndedAt :
                      (r.destroyedAt > 0 ? r.destroyedAt : traceData.requestDurationNs);

        // The "cost" of this resource (its contribution to latency)
        const myCost = myEnd - r.createdAt;

        // Find the best predecessor - the one that gives longest path to here
        let bestPredecessor = null;
        let bestPathLength = myCost;  // If no predecessor, path length is just my cost

        if (r.triggerId !== 0 && pathInfo.has(r.triggerId)) {
          const parentInfo = pathInfo.get(r.triggerId);
          const pathThroughParent = parentInfo.length + myCost;
          if (pathThroughParent > bestPathLength) {
            bestPathLength = pathThroughParent;
            bestPredecessor = r.triggerId;
          }
        }

        // For root, or orphans, path length starts at myCost
        pathInfo.set(r.asyncId, {
          length: bestPathLength,
          predecessor: bestPredecessor,
          endTime: myEnd
        });
      });

      // Find the resource with the longest path (this is the end of the critical path)
      let maxPathLength = 0;
      let lastResource = null;

      pathInfo.forEach((info, asyncId) => {
        if (info.length > maxPathLength) {
          maxPathLength = info.length;
          lastResource = traceData.resourceMap.get(asyncId);
        }
      });

      if (!lastResource) return;

      // Trace back to build the critical path
      const path = [];
      let current = lastResource;
      while (current) {
        path.unshift(current);
        criticalPathSet.add(current.asyncId);
        const info = pathInfo.get(current.asyncId);
        if (!info || info.predecessor === null) break;
        current = traceData.resourceMap.get(info.predecessor);
      }

      // Calculate timing breakdown on critical path
      let totalAsyncWait = 0;
      let totalSyncTime = 0;
      path.forEach(r => {
        if (r.callbackStartedAt > 0 && r.createdAt > 0) {
          totalAsyncWait += r.callbackStartedAt - r.createdAt;
        }
        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          totalSyncTime += r.callbackEndedAt - r.callbackStartedAt;
        }
      });

      criticalPathInfo = {
        path,
        totalAsyncWait,
        totalSyncTime,
        totalTime: maxPathLength
      };

      console.log(`Critical path: ${path.length} resources, ` +
        `total=${(maxPathLength/1e6).toFixed(2)}ms, ` +
        `async=${(totalAsyncWait/1e6).toFixed(2)}ms, ` +
        `sync=${(totalSyncTime/1e6).toFixed(2)}ms`);
    }

    function toggleCriticalPath(fromHotkey = false) {
      const checkbox = document.getElementById('critical-path-check');
      if (fromHotkey) {
        showCriticalPath = !showCriticalPath;
        checkbox.checked = showCriticalPath;
      } else {
        showCriticalPath = checkbox.checked;
      }
      updateCriticalPathInfo();
      updateAnalysisButtonState();
      render();
    }

    function toggleAccessibility(fromHotkey = false) {
      const checkbox = document.getElementById('accessibility-check');
      if (fromHotkey) {
        accessibilityMode = !accessibilityMode;
        checkbox.checked = accessibilityMode;
      } else {
        accessibilityMode = checkbox.checked;
      }
      clearPatternCache();
      document.body.classList.toggle('accessibility-mode', accessibilityMode);
      updateAnalysisButtonState();
      if (traceData) render();
    }

    function updateAnalysisButtonState() {
      const activeCount = [showCriticalPath, showBottlenecks, showPatterns, clickToFilterEnabled, stackTraceGrouping, showTemporalEdges, accessibilityMode].filter(x => x).length;
      const btn = document.getElementById('analysis-btn');
      if (activeCount > 0) {
        btn.textContent = `üî¨ Analysis (${activeCount}) ‚ñæ`;
        btn.classList.add('active');
      } else {
        btn.textContent = 'üî¨ Analysis ‚ñæ';
        btn.classList.remove('active');
      }
    }

    function updateCriticalPathInfo() {
      const container = document.getElementById('critical-path-info');

      if (!criticalPathInfo || criticalPathInfo.path.length === 0) {
        container.innerHTML = '<div class="detail-item" style="color: #666;">No path computed</div>';
        return;
      }

      const info = criticalPathInfo;
      const pathDesc = info.path.map(r => {
        const typeName = r.type.replace('js-', '').substring(0, 6);
        return `<span style="color: ${TYPE_COLORS[r.type] || '#808080'};">${typeName}</span>`;
      }).join(' ‚Üí ');

      container.innerHTML = `
        <div class="detail-item">
          <strong style="color: #ff6432;">üî• ${info.path.length} resources</strong>
        </div>
        <div class="detail-item">
          <strong>Async wait:</strong> ${(info.totalAsyncWait / 1e6).toFixed(2)}ms
        </div>
        <div class="detail-item">
          <strong>Sync time:</strong> ${(info.totalSyncTime / 1e6).toFixed(2)}ms
        </div>
        <div class="detail-item" style="word-break: break-all; line-height: 1.4;">
          ${pathDesc}
        </div>
        <div class="detail-item" style="color: #888; font-size: 0.65rem;">
          This is the minimum latency path.<br>
          Only optimizing this path reduces total time.
        </div>
      `;
    }

    // ==================== ANALYSIS INFO UPDATE ====================
    function updateAnalysisInfo() {
      const container = document.getElementById('analysis-info');
      const filterStatus = document.getElementById('click-filter-status');

      let html = '';

      // Show bottlenecks info
      if (showBottlenecks && detectedBottlenecks.length > 0) {
        html += `<div class="detail-item" style="color: #ffc832;"><strong>üê¢ Top ${detectedBottlenecks.length} Bottlenecks</strong></div>`;
        detectedBottlenecks.slice(0, 3).forEach(id => {
          const r = traceData?.resourceMap?.get(id);
          if (r) {
            let time = 0;
            if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
              time += r.callbackEndedAt - r.callbackStartedAt;
            }
            if (r.callbackStartedAt > 0 && r.createdAt > 0) {
              time += r.callbackStartedAt - r.createdAt;
            }
            html += `<div class="detail-item" style="padding-left: 0.5rem; word-wrap: break-word;">#${id} ${r.type} (${(time/1e6).toFixed(1)}ms)</div>`;
          }
        });
      }

      // Show patterns info
      if (showPatterns && detectedPatterns.length > 0) {
        html += `<div class="detail-item" style="color: #c864ff; margin-top: 0.3rem;"><strong>üîç ${detectedPatterns.length} Pattern(s) Found</strong></div>`;
        detectedPatterns.slice(0, 3).forEach(p => {
          const icon = p.type === 'sequential-await' ? '‚ö°' : p.type === 'duplicate-fetch' ? 'üîÑ' : 'üìö';
          html += `<div class="detail-item" style="padding-left: 0.5rem; word-wrap: break-word; line-height: 1.3;">${icon} ${p.message}</div>`;
        });
      }

      // Show temporal edges info
      if (showTemporalEdges && temporalEdges.length > 0) {
        html += `<div class="detail-item" style="color: #50c878; margin-top: 0.3rem;"><strong>‚è±Ô∏è ${temporalEdges.length} Temporal Edge(s)</strong></div>`;
        html += `<div class="detail-item" style="padding-left: 0.5rem; color: #888;">Callbacks that start during another callback</div>`;
      }

      if (!showBottlenecks && !showPatterns && !showTemporalEdges) {
        html = '<div class="detail-item" style="color: #666;">Enable üê¢, üîç, or ‚è±Ô∏è toggles</div>';
      } else if (html === '') {
        html = '<div class="detail-item" style="color: #50c878;">No issues detected!</div>';
      }

      container.innerHTML = html;

      // Update filter status
      if (clickToFilterEnabled && clickFilterResourceId !== null) {
        filterStatus.style.display = 'block';
      } else {
        filterStatus.style.display = 'none';
      }
    }

    // ==================== BOTTLENECK DETECTION ====================
    function toggleBottlenecks(fromHotkey = false) {
      const checkbox = document.getElementById('bottleneck-check');
      if (fromHotkey) {
        showBottlenecks = !showBottlenecks;
        checkbox.checked = showBottlenecks;
      } else {
        showBottlenecks = checkbox.checked;
      }
      updateAnalysisButtonState();
      if (traceData) {
        detectBottlenecks();
        updateAnalysisInfo();
        render();
      }
    }

    function detectBottlenecks() {
      if (!traceData) {
        detectedBottlenecks = [];
        return;
      }

      // Find top 5 resources by total time (sync + async wait)
      const resourceTimes = traceData.resources.map(r => {
        let totalTime = 0;
        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          totalTime += r.callbackEndedAt - r.callbackStartedAt;  // sync
        }
        if (r.callbackStartedAt > 0 && r.createdAt > 0) {
          totalTime += r.callbackStartedAt - r.createdAt;  // async wait
        }
        return { resource: r, totalTime };
      }).filter(rt => rt.totalTime > 0);

      resourceTimes.sort((a, b) => b.totalTime - a.totalTime);
      detectedBottlenecks = resourceTimes.slice(0, 5).map(rt => rt.resource.asyncId);
    }

    // ==================== PATTERN DETECTION ====================
    function togglePatterns(fromHotkey = false) {
      const checkbox = document.getElementById('pattern-check');
      if (fromHotkey) {
        showPatterns = !showPatterns;
        checkbox.checked = showPatterns;
      } else {
        showPatterns = checkbox.checked;
      }
      updateAnalysisButtonState();
      if (traceData) {
        detectPatterns();
        updateAnalysisInfo();
        render();
      }
    }

    function detectPatterns() {
      if (!traceData) {
        detectedPatterns = [];
        return;
      }

      detectedPatterns = [];

      // Build parent -> children map
      const childrenMap = new Map();
      traceData.resources.forEach(r => {
        if (!childrenMap.has(r.triggerId)) {
          childrenMap.set(r.triggerId, []);
        }
        childrenMap.get(r.triggerId).push(r);
      });

      // Pattern 1: Sequential fetches that could be parallel (Promise.all opportunity)
      // Look for fetch operations that execute one after another in time
      const fetches = traceData.resources.filter(r =>
        r.type === 'fetch' && r.callbackStartedAt > 0 && r.callbackEndedAt > 0
      );

      if (fetches.length >= 2) {
        // Sort by callback start time
        fetches.sort((a, b) => a.callbackStartedAt - b.callbackStartedAt);

        // Find sequential groups (each fetch starts after previous ends)
        let sequentialGroup = [fetches[0]];
        for (let i = 1; i < fetches.length; i++) {
          const prev = fetches[i - 1];
          const curr = fetches[i];
          // Check if current started after previous ended (with small tolerance)
          // Also check if current was CREATED after previous callback ended,
          // which indicates await pattern (not parallel)
          if (curr.createdAt > prev.callbackStartedAt) {
            // This fetch was created after the previous one started executing,
            // suggesting sequential await pattern
            sequentialGroup.push(curr);
          } else {
            // Parallel execution detected, check if previous group was sequential
            if (sequentialGroup.length >= 2) {
              detectedPatterns.push({
                type: 'sequential-await',
                message: `${sequentialGroup.length} sequential fetch operations could use Promise.all()`,
                resources: sequentialGroup.map(s => s.asyncId),
                severity: 'high'
              });
            }
            sequentialGroup = [curr];
          }
        }
        // Check final group
        if (sequentialGroup.length >= 2) {
          detectedPatterns.push({
            type: 'sequential-await',
            message: `${sequentialGroup.length} sequential fetch operations could use Promise.all()`,
            resources: sequentialGroup.map(s => s.asyncId),
            severity: 'high'
          });
        }
      }

      // Pattern 2: Duplicate fetches (same URL)
      const fetchUrls = new Map();
      traceData.resources.forEach(r => {
        if (r.type === 'fetch') {
          const urlAnnotation = (traceData.annotations || []).find(a =>
            a.asyncId === r.asyncId && a.key === 'url'
          );
          if (urlAnnotation) {
            const url = urlAnnotation.value;
            if (!fetchUrls.has(url)) {
              fetchUrls.set(url, []);
            }
            fetchUrls.get(url).push(r.asyncId);
          }
        }
      });

      fetchUrls.forEach((ids, url) => {
        if (ids.length > 1) {
          detectedPatterns.push({
            type: 'duplicate-fetch',
            message: `Duplicate fetch to ${url.substring(0, 40)}...`,
            resources: ids,
            severity: 'medium'
          });
        }
      });

      // Pattern 3: Long promise chains (deep nesting)
      const depths = new Map();
      function getDepth(asyncId) {
        if (depths.has(asyncId)) return depths.get(asyncId);
        const r = traceData.resources.find(res => res.asyncId === asyncId);
        if (!r || r.triggerId === 0) {
          depths.set(asyncId, 0);
          return 0;
        }
        const depth = 1 + getDepth(r.triggerId);
        depths.set(asyncId, depth);
        return depth;
      }

      traceData.resources.forEach(r => getDepth(r.asyncId));

      const maxDepth = Math.max(...depths.values());
      if (maxDepth > 10) {
        const deepResources = traceData.resources
          .filter(r => depths.get(r.asyncId) > 8)
          .map(r => r.asyncId);
        detectedPatterns.push({
          type: 'deep-chain',
          message: `Deep async chain (depth ${maxDepth}) - consider flattening`,
          resources: deepResources,
          severity: 'medium'
        });
      }

      // Pattern 4: Waterfall fetches (fetch triggered by another fetch's result)
      // These are fetches whose trigger chain includes another fetch
      const allFetches = traceData.resources.filter(r => r.type === 'fetch');
      const fetchIds = new Set(allFetches.map(f => f.asyncId));

      allFetches.forEach(fetch => {
        // Walk up the trigger chain to see if we hit another fetch
        let current = fetch;
        let depth = 0;
        while (current && current.triggerId !== 0 && depth < 20) {
          const parent = traceData.resources.find(r => r.asyncId === current.triggerId);
          if (parent && fetchIds.has(parent.asyncId)) {
            detectedPatterns.push({
              type: 'waterfall-fetch',
              message: `Waterfall: fetch #${fetch.asyncId} depends on fetch #${parent.asyncId}`,
              resources: [fetch.asyncId, parent.asyncId],
              severity: 'medium'
            });
            break;
          }
          current = parent;
          depth++;
        }
      });

      // Pattern 5: Unresolved promises (created but callback never started)
      const unresolvedPromises = traceData.resources.filter(r =>
        r.type === 'js-promise' &&
        r.createdAt > 0 &&
        r.callbackStartedAt === 0 &&
        r.destroyedAt === 0  // Still alive at end of request
      );
      if (unresolvedPromises.length > 0) {
        detectedPatterns.push({
          type: 'unresolved-promise',
          message: `${unresolvedPromises.length} promise(s) never resolved`,
          resources: unresolvedPromises.map(r => r.asyncId),
          severity: 'low'
        });
      }

      // Pattern 6: Long async gaps (waiting >threshold before callback)
      const longGapThreshold = patternThresholds.longGapMs * 1e6; // Convert ms to ns
      traceData.resources.forEach(r => {
        if (r.createdAt > 0 && r.callbackStartedAt > 0) {
          const waitTime = r.callbackStartedAt - r.createdAt;
          if (waitTime > longGapThreshold) {
            const waitMs = (waitTime / 1e6).toFixed(0);
            detectedPatterns.push({
              type: 'long-async-gap',
              message: `${r.type} #${r.asyncId} waited ${waitMs}ms before executing`,
              resources: [r.asyncId],
              severity: 'medium'
            });
          }
        }
      });

      // Pattern 7: Redundant timers (multiple timers with similar delays created together)
      const timers = traceData.resources.filter(r => r.type === 'timer');
      if (timers.length >= 2) {
        // Group timers by approximate delay (within 10ms) and creation time (within 5ms)
        const timerGroups = new Map();
        timers.forEach(t => {
          // Estimate delay from creation to callback
          const delay = t.callbackStartedAt > 0 ? t.callbackStartedAt - t.createdAt : 0;
          const delayBucket = Math.round(delay / 10e6) * 10; // Round to 10ms
          const createBucket = Math.round(t.createdAt / 5e6) * 5; // Round to 5ms
          const key = `${delayBucket}-${createBucket}`;
          if (!timerGroups.has(key)) timerGroups.set(key, []);
          timerGroups.get(key).push(t);
        });

        timerGroups.forEach((group, key) => {
          if (group.length >= 2) {
            detectedPatterns.push({
              type: 'redundant-timers',
              message: `${group.length} timers with similar delay created together`,
              resources: group.map(t => t.asyncId),
              severity: 'low'
            });
          }
        });
      }

      // Pattern 8: Cache misses (cache-get with long wait, suggesting network fetch)
      const cacheGets = traceData.resources.filter(r => r.type === 'cache-get');
      const cacheMissThreshold = 50 * 1e6; // 50ms suggests a miss (hit would be faster)
      cacheGets.forEach(cg => {
        if (cg.callbackStartedAt > 0 && cg.createdAt > 0) {
          const waitTime = cg.callbackStartedAt - cg.createdAt;
          if (waitTime > cacheMissThreshold) {
            const waitMs = (waitTime / 1e6).toFixed(0);
            detectedPatterns.push({
              type: 'cache-miss',
              message: `Cache miss: ${waitMs}ms wait suggests origin fetch`,
              resources: [cg.asyncId],
              severity: 'low'
            });
          }
        }
      });

      // ==================== NEW PATTERNS ====================

      // Pattern 9: Event loop blocking (sync execution > threshold)
      const syncBlockThreshold = patternThresholds.syncBlockMs * 1e6;
      traceData.resources.forEach(r => {
        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          const syncTime = r.callbackEndedAt - r.callbackStartedAt;
          if (syncTime > syncBlockThreshold) {
            detectedPatterns.push({
              type: 'sync-flood',
              message: `Event loop blocked: ${r.type} #${r.asyncId} ran ${(syncTime/1e6).toFixed(0)}ms sync`,
              resources: [r.asyncId],
              severity: 'high'
            });
          }
        }
      });

      // Pattern 10: Promise accumulation (many promises in short window)
      const promiseBuckets = new Map();
      traceData.resources.filter(r => r.type === 'js-promise').forEach(r => {
        const bucket = Math.floor(r.createdAt / 1e6); // 1ms buckets
        if (!promiseBuckets.has(bucket)) promiseBuckets.set(bucket, []);
        promiseBuckets.get(bucket).push(r.asyncId);
      });
      promiseBuckets.forEach((ids, bucket) => {
        if (ids.length >= patternThresholds.promiseFlood) {
          detectedPatterns.push({
            type: 'promise-flood',
            message: `Promise accumulation: ${ids.length} promises created within 1ms`,
            resources: ids,
            severity: 'medium'
          });
        }
      });

      // Pattern 11: Callback storm (many callbacks starting in short window)
      const callbackBuckets = new Map();
      traceData.resources.filter(r => r.callbackStartedAt > 0).forEach(r => {
        const bucket = Math.floor(r.callbackStartedAt / 1e6);
        if (!callbackBuckets.has(bucket)) callbackBuckets.set(bucket, []);
        callbackBuckets.get(bucket).push(r.asyncId);
      });
      callbackBuckets.forEach((ids, bucket) => {
        if (ids.length >= patternThresholds.callbackStorm) {
          detectedPatterns.push({
            type: 'callback-storm',
            message: `Callback storm: ${ids.length} callbacks fired within 1ms`,
            resources: ids,
            severity: 'medium'
          });
        }
      });

      // Pattern 12: Unbatched KV/DO operations
      const batchableTypes = ['kv-get', 'kv-put', 'kv-delete', 'do-get', 'do-put', 'do-delete'];
      batchableTypes.forEach(opType => {
        const ops = traceData.resources.filter(r => r.type === opType);
        if (ops.length < patternThresholds.unbatchedOps) return;

        // Group by creation time proximity (5ms window)
        const groups = [];
        let currentGroup = [];
        ops.sort((a, b) => a.createdAt - b.createdAt).forEach(op => {
          if (currentGroup.length === 0 || op.createdAt - currentGroup[0].createdAt < 5e6) {
            currentGroup.push(op);
          } else {
            if (currentGroup.length >= patternThresholds.unbatchedOps) groups.push([...currentGroup]);
            currentGroup = [op];
          }
        });
        if (currentGroup.length >= patternThresholds.unbatchedOps) groups.push(currentGroup);

        groups.forEach(group => {
          detectedPatterns.push({
            type: 'unbatched-ops',
            message: `Unbatched: ${group.length} ${opType} operations could be batched`,
            resources: group.map(r => r.asyncId),
            severity: 'high'
          });
        });
      });

      // Pattern 13: Concurrent fetch risk (too many parallel fetches)
      const fetchEvents = [];
      traceData.resources.filter(r => r.type === 'fetch').forEach(f => {
        if (f.createdAt > 0) fetchEvents.push({ time: f.createdAt, delta: 1, id: f.asyncId });
        const endTime = f.callbackEndedAt > 0 ? f.callbackEndedAt :
                        (f.destroyedAt > 0 ? f.destroyedAt : traceData.requestDurationNs);
        fetchEvents.push({ time: endTime, delta: -1, id: f.asyncId });
      });
      if (fetchEvents.length > 0) {
        fetchEvents.sort((a, b) => a.time - b.time);
        let concurrent = 0;
        let maxConcurrent = 0;
        let maxConcurrentFetches = [];
        let activeFetches = [];
        fetchEvents.forEach(e => {
          if (e.delta > 0) {
            activeFetches.push(e.id);
          } else {
            activeFetches = activeFetches.filter(id => id !== e.id);
          }
          concurrent += e.delta;
          if (concurrent > maxConcurrent) {
            maxConcurrent = concurrent;
            maxConcurrentFetches = [...activeFetches];
          }
        });
        if (maxConcurrent >= patternThresholds.fetchFlood) {
          detectedPatterns.push({
            type: 'fetch-flood',
            message: `High fetch concurrency: ${maxConcurrent} parallel fetches (connection limit risk)`,
            resources: maxConcurrentFetches,
            severity: 'medium'
          });
        }
      }

      // Pattern 14: Hot callback (single callback spawning many children)
      const childCounts = new Map();
      traceData.resources.forEach(r => {
        if (r.triggerId !== 0) {
          childCounts.set(r.triggerId, (childCounts.get(r.triggerId) || 0) + 1);
        }
      });
      childCounts.forEach((count, parentId) => {
        if (count > patternThresholds.hotCallback) {
          const parent = traceData.resourceMap.get(parentId);
          if (parent) {
            detectedPatterns.push({
              type: 'hot-callback',
              message: `Hot callback: ${parent.type} #${parentId} spawned ${count} children`,
              resources: [parentId],
              severity: 'low'
            });
          }
        }
      });

      // Deduplicate patterns by resource set
      const seen = new Set();
      detectedPatterns = detectedPatterns.filter(p => {
        const key = p.resources.sort().join(',');
        if (seen.has(key)) return false;
        seen.add(key);
        return true;
      });
    }

    // Get severity-based pattern style for a resource
    function getPatternSeverity(asyncId) {
      if (!showPatterns) return null;
      const pattern = detectedPatterns.find(p => p.resources.includes(asyncId));
      if (!pattern) return null;
      return pattern.severity || 'medium';
    }

    // Get severity-based styling colors and sizes
    function getPatternStyle(severity) {
      switch (severity) {
        case 'high':
          return { color: '#ff00ff', glow: 15, lineWidth: 3, alpha: 0.9 };
        case 'medium':
          return { color: '#cc66ff', glow: 10, lineWidth: 2, alpha: 0.7 };
        case 'low':
          return { color: '#9966cc', glow: 6, lineWidth: 1.5, alpha: 0.5 };
        default:
          return { color: '#cc66ff', glow: 10, lineWidth: 2, alpha: 0.7 };
      }
    }

    // Get all patterns that include a given resource
    function getPatternsForResource(asyncId) {
      if (!showPatterns || !detectedPatterns.length) return [];
      return detectedPatterns.filter(p => p.resources.includes(asyncId));
    }

    // Generate HTML for pattern list in tooltips
    function getPatternTooltipHTML(asyncId) {
      const patterns = getPatternsForResource(asyncId);
      if (patterns.length === 0) return '';

      const severityColors = {
        high: '#ff00ff',
        medium: '#cc66ff',
        low: '#9966cc'
      };
      const severityIcons = {
        high: 'üî¥',
        medium: 'üü°',
        low: 'üü¢'
      };

      const patternItems = patterns.map(p => {
        const severity = p.severity || 'medium';
        const color = severityColors[severity];
        const icon = severityIcons[severity];
        return `<div style="color: ${color}; font-size: 0.65rem;">${icon} ${p.type}: ${p.message.substring(0, 50)}${p.message.length > 50 ? '...' : ''}</div>`;
      }).join('');

      return `<div style="margin-top: 0.4rem; border-top: 1px solid #333; padding-top: 0.3rem;">
        <div style="font-weight: bold; font-size: 0.7rem; color: #e94560;">Detected Patterns:</div>
        ${patternItems}
      </div>`;
    }

    function getCriticalPathTooltipHTML(asyncId) {
      if (!showCriticalPath || !criticalPathSet.has(asyncId)) return '';
      if (!criticalPathInfo || !criticalPathInfo.path) return '';

      // Find position in critical path
      const path = criticalPathInfo.path;
      const pathIndex = path.findIndex(id => id === asyncId);
      const positionText = pathIndex >= 0
        ? `Step ${pathIndex + 1} of ${path.length}`
        : 'On critical path';

      return `<div style="margin-top: 0.4rem; border-top: 1px solid #333; padding-top: 0.3rem;">
        <div style="font-weight: bold; font-size: 0.7rem; color: #ff6432;">üî• Critical Path</div>
        <div style="font-size: 0.65rem; color: #ff8c5a;">${positionText}</div>
      </div>`;
    }

    // ==================== CLICK-TO-FILTER ====================
    function toggleClickFilter(fromHotkey = false) {
      const checkbox = document.getElementById('click-filter-check');
      if (fromHotkey) {
        clickToFilterEnabled = !clickToFilterEnabled;
        checkbox.checked = clickToFilterEnabled;
      } else {
        clickToFilterEnabled = checkbox.checked;
      }
      if (!clickToFilterEnabled) {
        clickFilterResourceId = null;
      }
      // Invalidate layout caches when filter changes
      cachedBubbleLayout = null;
      dagNodes = [];
      updateAnalysisInfo();
      updateAnalysisButtonState();
      if (traceData) render();
    }

    function applyClickFilter(asyncId) {
      clickFilterResourceId = asyncId;
      // Invalidate layout caches when filter changes
      cachedBubbleLayout = null;
      dagNodes = [];
      updateAnalysisInfo();
      render();
    }

    function getAncestors(asyncId) {
      const ancestors = new Set();
      let current = traceData.resources.find(r => r.asyncId === asyncId);
      while (current && current.triggerId !== 0) {
        ancestors.add(current.triggerId);
        current = traceData.resources.find(r => r.asyncId === current.triggerId);
      }
      return ancestors;
    }

    function getDescendants(asyncId) {
      const descendants = new Set();
      const queue = [asyncId];
      while (queue.length > 0) {
        const id = queue.shift();
        traceData.resources.forEach(r => {
          if (r.triggerId === id && !descendants.has(r.asyncId)) {
            descendants.add(r.asyncId);
            queue.push(r.asyncId);
          }
        });
      }
      return descendants;
    }

    function isResourceVisible(asyncId) {
      if (!clickToFilterEnabled || clickFilterResourceId === null) return true;
      if (asyncId === clickFilterResourceId) return true;
      const ancestors = getAncestors(clickFilterResourceId);
      const descendants = getDescendants(clickFilterResourceId);
      return ancestors.has(asyncId) || descendants.has(asyncId);
    }

    // ==================== STACK TRACE GROUPING ====================
    function toggleStackGrouping(fromHotkey = false) {
      const checkbox = document.getElementById('stack-group-check');
      if (fromHotkey) {
        stackTraceGrouping = !stackTraceGrouping;
        checkbox.checked = stackTraceGrouping;
      } else {
        stackTraceGrouping = checkbox.checked;
      }
      updateAnalysisButtonState();
      if (traceData) render();
    }

    function getStackGroups() {
      if (!traceData || !traceData.stackTraces) return new Map();

      const groups = new Map();
      traceData.resources.forEach(r => {
        const stackId = r.stackTraceId || 0;
        if (!groups.has(stackId)) {
          const stack = traceData.stackTraces.find(s => s.id === stackId);
          groups.set(stackId, {
            stackId,
            frames: stack ? stack.frames : [],
            resources: [],
            totalTime: 0
          });
        }
        const group = groups.get(stackId);
        group.resources.push(r);

        // Calculate time
        let time = 0;
        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          time += r.callbackEndedAt - r.callbackStartedAt;
        }
        if (r.callbackStartedAt > 0 && r.createdAt > 0) {
          time += r.callbackStartedAt - r.createdAt;
        }
        group.totalTime += time;
      });

      return groups;
    }

    // ==================== TEMPORAL EDGES ====================
    // Show edges based on callback timing: if resource B's callback starts
    // during resource A's callback, draw an edge from A to B.
    function toggleTemporalEdges(fromHotkey = false) {
      const checkbox = document.getElementById('temporal-edges-check');
      if (fromHotkey) {
        showTemporalEdges = !showTemporalEdges;
        checkbox.checked = showTemporalEdges;
      } else {
        showTemporalEdges = checkbox.checked;
      }
      updateAnalysisButtonState();
      if (traceData) {
        computeTemporalEdges();
        render();
      }
    }

    function computeTemporalEdges() {
      if (!traceData) {
        temporalEdges = [];
        return;
      }

      temporalEdges = [];

      // Find resources with callback timing
      const withCallbacks = traceData.resources.filter(r =>
        r.callbackStartedAt > 0 && r.callbackEndedAt > 0
      );

      // For each resource with a callback, find other resources whose callbacks
      // START during this resource's callback window
      withCallbacks.forEach(parent => {
        withCallbacks.forEach(child => {
          if (parent.asyncId === child.asyncId) return;
          // Skip if there's already a triggerId relationship
          if (child.triggerId === parent.asyncId) return;

          // Check if child's callback starts during parent's callback
          if (child.callbackStartedAt >= parent.callbackStartedAt &&
              child.callbackStartedAt < parent.callbackEndedAt) {
            temporalEdges.push({
              from: parent.asyncId,
              to: child.asyncId,
              // Delay from parent callback start to child callback start
              delay: child.callbackStartedAt - parent.callbackStartedAt
            });
          }
        });
      });

      // Sort by from, then by delay for consistent rendering
      temporalEdges.sort((a, b) => {
        if (a.from !== b.from) return a.from - b.from;
        return a.delay - b.delay;
      });
    }

    function updateStats() {
      let totalSync = 0, totalAsync = 0;
      traceData.resources.forEach(r => {
        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          totalSync += r.callbackEndedAt - r.callbackStartedAt;
        }
        if (r.callbackStartedAt > 0 && r.createdAt > 0) {
          totalAsync += r.callbackStartedAt - r.createdAt;
        }
      });
      document.getElementById('stat-duration').textContent = (traceData.requestDurationNs / 1e6).toFixed(1);
      document.getElementById('stat-resources').textContent = traceData.resources.length;
      document.getElementById('stat-sync').textContent = (totalSync / 1e6).toFixed(1);
      document.getElementById('stat-async').textContent = (totalAsync / 1e6).toFixed(1);

      // Render summary charts
      renderTimelineChart();
      renderTypeChart();
      renderTimeBreakdownChart(totalSync, totalAsync);
    }

    function renderTimelineChart() {
      const canvas = document.getElementById('timeline-chart');
      const ctx = canvas.getContext('2d');
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = 40 * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

      const width = rect.width;
      const height = 40;
      const duration = traceData.requestDurationNs;
      const bucketCount = Math.floor(width / 3);
      const buckets = new Array(bucketCount).fill(0);
      const syncBuckets = new Array(bucketCount).fill(0);

      // Count activity per time bucket
      traceData.resources.forEach(r => {
        const start = r.createdAt;
        const end = r.callbackEndedAt > 0 ? r.callbackEndedAt : (r.destroyedAt > 0 ? r.destroyedAt : duration);
        const startBucket = Math.floor((start / duration) * bucketCount);
        const endBucket = Math.min(bucketCount - 1, Math.floor((end / duration) * bucketCount));

        for (let i = startBucket; i <= endBucket; i++) {
          if (i >= 0 && i < bucketCount) buckets[i]++;
        }

        // Track sync time separately
        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          const syncStart = Math.floor((r.callbackStartedAt / duration) * bucketCount);
          const syncEnd = Math.min(bucketCount - 1, Math.floor((r.callbackEndedAt / duration) * bucketCount));
          for (let i = syncStart; i <= syncEnd; i++) {
            if (i >= 0 && i < bucketCount) syncBuckets[i]++;
          }
        }
      });

      const maxCount = Math.max(...buckets, 1);
      const barWidth = width / bucketCount;

      ctx.fillStyle = '#0f3460';
      ctx.fillRect(0, 0, width, height);

      // Draw async activity (all resources active)
      ctx.fillStyle = 'rgba(126, 200, 227, 0.4)';
      buckets.forEach((count, i) => {
        const barHeight = (count / maxCount) * (height - 4);
        ctx.fillRect(i * barWidth, height - 2 - barHeight, barWidth - 1, barHeight);
      });

      // Draw sync activity overlay
      ctx.fillStyle = 'rgba(233, 69, 96, 0.8)';
      syncBuckets.forEach((count, i) => {
        const barHeight = (count / maxCount) * (height - 4);
        ctx.fillRect(i * barWidth, height - 2 - barHeight, barWidth - 1, barHeight);
      });

      // Draw time markers
      ctx.fillStyle = '#666';
      ctx.font = '8px sans-serif';
      ctx.textAlign = 'center';
      for (let i = 0; i <= 4; i++) {
        const x = (i / 4) * width;
        const time = (i / 4) * duration / 1e6;
        ctx.fillText(time.toFixed(0) + 'ms', x, 10);
      }
    }

    function renderTypeChart() {
      const canvas = document.getElementById('type-chart');
      const ctx = canvas.getContext('2d');
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = 80 * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

      const width = rect.width;
      const height = 80;

      // Count by type and calculate sync time per type
      const typeCounts = new Map();
      const typeSyncTime = new Map();
      traceData.resources.forEach(r => {
        typeCounts.set(r.type, (typeCounts.get(r.type) || 0) + 1);
        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          typeSyncTime.set(r.type, (typeSyncTime.get(r.type) || 0) + (r.callbackEndedAt - r.callbackStartedAt));
        }
      });

      const types = Array.from(typeCounts.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 6);

      const maxCount = Math.max(...types.map(t => t[1]), 1);
      const barHeight = (height - 20) / types.length;

      ctx.fillStyle = '#0f3460';
      ctx.fillRect(0, 0, width, height);

      // Draw horizontal bars
      types.forEach(([type, count], i) => {
        const y = 4 + i * barHeight;
        const barWidth = ((count / maxCount) * (width - 60));

        ctx.fillStyle = TYPE_COLORS[type] || '#808080';
        ctx.globalAlpha = 0.8;
        ctx.fillRect(55, y + 2, barWidth, barHeight - 4);
        ctx.globalAlpha = 1;

        // Type label
        ctx.fillStyle = '#aaa';
        ctx.font = '9px sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText(type.replace('js-', '').substring(0, 7), 52, y + barHeight / 2 + 3);

        // Count label
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'left';
        ctx.fillText(count.toString(), barWidth + 58, y + barHeight / 2 + 3);
      });

      // Update breakdown text
      const breakdown = document.getElementById('type-breakdown');
      const totalSyncTime = Array.from(typeSyncTime.values()).reduce((a, b) => a + b, 0);
      breakdown.innerHTML = types.map(([type, count]) => {
        const syncTime = typeSyncTime.get(type) || 0;
        const pct = totalSyncTime > 0 ? ((syncTime / totalSyncTime) * 100).toFixed(0) : 0;
        return `<span style="color: ${TYPE_COLORS[type] || '#808080'}">‚óè</span> ${type}: ${count} (${pct}% CPU)`;
      }).join('<br>');
    }

    function renderTimeBreakdownChart(totalSync, totalAsync) {
      const canvas = document.getElementById('time-chart');
      const ctx = canvas.getContext('2d');
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = 24 * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

      const width = rect.width;
      const height = 24;
      const total = totalSync + totalAsync;

      if (total === 0) return;

      const syncWidth = (totalSync / total) * width;
      const asyncWidth = (totalAsync / total) * width;

      // Async portion (waiting)
      ctx.fillStyle = 'rgba(126, 200, 227, 0.6)';
      ctx.fillRect(0, 0, asyncWidth, height);

      // Sync portion (executing)
      ctx.fillStyle = '#e94560';
      ctx.fillRect(asyncWidth, 0, syncWidth, height);

      // Labels
      ctx.fillStyle = '#fff';
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'center';

      if (asyncWidth > 50) {
        ctx.fillText(`Async ${(totalAsync / 1e6).toFixed(1)}ms`, asyncWidth / 2, height / 2 + 4);
      }
      if (syncWidth > 50) {
        ctx.fillText(`Sync ${(totalSync / 1e6).toFixed(1)}ms`, asyncWidth + syncWidth / 2, height / 2 + 4);
      }

      // Update breakdown text
      const syncPct = ((totalSync / total) * 100).toFixed(0);
      const asyncPct = ((totalAsync / total) * 100).toFixed(0);
      document.getElementById('time-breakdown').innerHTML =
        `<span style="color: #7ec8e3;">‚ñ†</span> Async wait: ${asyncPct}% | ` +
        `<span style="color: #e94560;">‚ñ†</span> Sync exec: ${syncPct}%`;
    }

    function renderRuntimeOverheadChart() {
      if (!traceData) return;

      // Calculate time by classification
      // 'typed' = API calls (fetch, cache, etc.) - user-initiated
      // 'user' = User code promises (have stack traces)
      // 'internal' = Runtime overhead (no stack, internal machinery)
      const timeByClass = {
        typed: { sync: 0, async: 0, count: 0 },
        user: { sync: 0, async: 0, count: 0 },
        internal: { sync: 0, async: 0, count: 0 }
      };

      traceData.resources.forEach(r => {
        const cls = r._classification || 'internal';
        if (!timeByClass[cls]) return;

        timeByClass[cls].count++;

        // Sync time (callback execution)
        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          timeByClass[cls].sync += r.callbackEndedAt - r.callbackStartedAt;
        }

        // Async time (waiting for callback)
        if (r.createdAt > 0 && r.callbackStartedAt > 0) {
          timeByClass[cls].async += r.callbackStartedAt - r.createdAt;
        }
      });

      // Calculate totals
      const userTime = timeByClass.typed.sync + timeByClass.typed.async +
                       timeByClass.user.sync + timeByClass.user.async;
      const runtimeTime = timeByClass.internal.sync + timeByClass.internal.async;
      const totalTime = userTime + runtimeTime;

      // Render chart
      const canvas = document.getElementById('overhead-chart');
      const ctx = canvas.getContext('2d');
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = 24 * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

      const width = rect.width;
      const height = 24;

      if (totalTime === 0) {
        ctx.fillStyle = '#333';
        ctx.fillRect(0, 0, width, height);
        document.getElementById('overhead-breakdown').innerHTML =
          '<div style="color: #666;">No timing data available</div>';
        return;
      }

      const userWidth = (userTime / totalTime) * width;
      const runtimeWidth = (runtimeTime / totalTime) * width;

      // User code portion (green)
      ctx.fillStyle = '#50c878';
      ctx.fillRect(0, 0, userWidth, height);

      // Runtime overhead portion (orange)
      ctx.fillStyle = '#ff8c00';
      ctx.fillRect(userWidth, 0, runtimeWidth, height);

      // Labels
      ctx.fillStyle = '#fff';
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'center';

      if (userWidth > 50) {
        ctx.fillText(`User ${(userTime / 1e6).toFixed(1)}ms`, userWidth / 2, height / 2 + 4);
      }
      if (runtimeWidth > 40) {
        ctx.fillText(`Runtime ${(runtimeTime / 1e6).toFixed(1)}ms`, userWidth + runtimeWidth / 2, height / 2 + 4);
      }

      // Update breakdown text with detailed stats
      const userPct = ((userTime / totalTime) * 100).toFixed(0);
      const runtimePct = ((runtimeTime / totalTime) * 100).toFixed(0);
      const userCount = timeByClass.typed.count + timeByClass.user.count;
      const runtimeCount = timeByClass.internal.count;

      document.getElementById('overhead-breakdown').innerHTML =
        `<span style="color: #50c878;">‚ñ†</span> User: ${userPct}% (${userCount} ops)<br>` +
        `<span style="color: #ff8c00;">‚ñ†</span> Runtime: ${runtimePct}% (${runtimeCount} ops)` +
        `<div style="margin-top: 0.25rem; font-size: 0.6rem; color: #888;">` +
        `API: ${timeByClass.typed.count} | User promises: ${timeByClass.user.count} | Internal: ${timeByClass.internal.count}` +
        `</div>`;
    }

    function updateLegend() {
      const types = new Set(traceData.resources.map(r => r.type));
      const legend = document.getElementById('legend');
      legend.innerHTML = '';
      types.forEach(type => {
        const item = document.createElement('div');
        item.className = 'legend-item';
        item.innerHTML = `<div class="legend-color" style="background: ${TYPE_COLORS[type] || '#808080'}"></div><span>${type}</span>`;
        legend.appendChild(item);
      });
    }

    function render() {
      if (currentView === 'waterfall') {
        renderWaterfall();
      } else if (currentView === 'bubble') {
        renderBubble();
      } else if (currentView === 'dag') {
        renderDAG();
      } else if (currentView === 'parallelism') {
        renderParallelism();
      } else if (currentView === 'breakdown') {
        renderBreakdown();
      } else if (currentView === 'latency') {
        renderLatency();
      } else if (currentView === 'gaps') {
        renderGaps();
      } else if (currentView === 'replay') {
        renderReplay();
      } else if (currentView === 'heatmap') {
        renderHeatmap();
      }
    }

    function updateViewHelp() {
      document.querySelectorAll('.view-help').forEach(el => {
        const view = el.dataset.view;
        el.classList.toggle('active', view === currentView || view === 'all');
      });
    }

    function updateControlStates() {
      // Sort mode only works in Waterfall view
      const sortMode = document.getElementById('sort-mode');
      const isWaterfall = currentView === 'waterfall';
      sortMode.disabled = !isWaterfall;
      sortMode.style.opacity = isWaterfall ? '1' : '0.4';
      sortMode.style.cursor = isWaterfall ? 'pointer' : 'not-allowed';

      // Filter mode only works in certain views
      const filterMode = document.getElementById('filter-mode');
      const filterViews = ['waterfall', 'bubble', 'dag', 'heatmap'];
      const filterEnabled = filterViews.includes(currentView);
      filterMode.disabled = !filterEnabled;
      filterMode.style.opacity = filterEnabled ? '1' : '0.4';
      filterMode.style.cursor = filterEnabled ? 'pointer' : 'not-allowed';
    }

    // ==================== WATERFALL VIEW ====================
    function renderWaterfall() {
      document.getElementById('waterfall-empty').style.display = 'none';
      document.getElementById('waterfall').style.display = 'block';

      const container = document.getElementById('waterfall');
      container.innerHTML = '';

      const sortMode = document.getElementById('sort-mode').value;
      let sorted = [...traceData.resources];

      if (sortMode === 'creation') {
        sorted.sort((a, b) => a.createdAt - b.createdAt);
      } else if (sortMode === 'duration') {
        sorted.sort((a, b) => {
          const durA = (a.callbackEndedAt || a.destroyedAt || traceData.requestDurationNs) - a.createdAt;
          const durB = (b.callbackEndedAt || b.destroyedAt || traceData.requestDurationNs) - b.createdAt;
          return durB - durA;
        });
      } else {
        sorted = [];
        function addToTree(id) {
          const r = traceData.resourceMap.get(id);
          if (r) {
            sorted.push(r);
            const children = (traceData.childrenMap.get(id) || []).slice().sort((a, b) => {
              return traceData.resourceMap.get(a).createdAt - traceData.resourceMap.get(b).createdAt;
            });
            children.forEach(addToTree);
          }
        }
        const root = traceData.resources.find(r => r.type === 'root');
        if (root) addToTree(root.asyncId);
        traceData.resources.forEach(r => { if (!sorted.includes(r)) sorted.push(r); });
      }

      const duration = traceData.requestDurationNs;
      const timelineWidth = Math.max(600, container.clientWidth - 200);

      // Time axis
      const axis = document.createElement('div');
      axis.className = 'time-axis';
      axis.style.width = (180 + timelineWidth) + 'px';
      for (let i = 0; i <= 10; i++) {
        const tick = document.createElement('div');
        tick.className = 'time-tick';
        tick.style.left = (180 + (i / 10) * timelineWidth) + 'px';
        tick.textContent = ((i / 10) * duration / 1e6).toFixed(1) + 'ms';
        axis.appendChild(tick);
      }
      container.appendChild(axis);

      // Rows
      sorted.forEach(r => {
        if (!shouldShowResource(r)) return;
        // Apply click-to-filter visibility
        if (clickToFilterEnabled && clickFilterResourceId !== null && !isResourceVisible(r.asyncId)) return;

        const row = document.createElement('div');
        row.className = 'resource-row';
        if (selectedResource && selectedResource.asyncId === r.asyncId) row.classList.add('selected');
        if (highlightedChain.has(r.asyncId)) row.classList.add('highlighted');
        if (showCriticalPath && criticalPathSet.has(r.asyncId)) row.classList.add('critical-path');
        if (r._classification === 'internal') row.classList.add('internal');
        // Bottleneck highlighting
        if (showBottlenecks && detectedBottlenecks.includes(r.asyncId)) row.classList.add('bottleneck');
        // Pattern highlighting (severity-based)
        if (showPatterns) {
          const patternMatch = detectedPatterns.find(p => p.resources.includes(r.asyncId));
          if (patternMatch) {
            row.classList.add('pattern-match');
            row.classList.add(`pattern-${patternMatch.severity || 'medium'}`);
          }
        }

        const label = document.createElement('div');
        label.className = 'resource-label';

        const depth = traceData.depthMap.get(r.asyncId) || 0;
        if (sortMode === 'tree' && depth > 0) {
          for (let i = 0; i < depth; i++) {
            const indent = document.createElement('span');
            indent.className = 'indent';
            label.appendChild(indent);
          }
        }

        const badge = document.createElement('span');
        badge.className = 'type-badge';
        badge.style.background = TYPE_COLORS[r.type] || '#808080';
        badge.textContent = r.type.replace('js-', '').substring(0, 5);
        label.appendChild(badge);

        const idSpan = document.createElement('span');
        idSpan.textContent = ` #${r.asyncId}`;
        idSpan.style.color = '#888';
        label.appendChild(idSpan);

        row.appendChild(label);

        const timeline = document.createElement('div');
        timeline.className = 'resource-timeline';
        timeline.style.width = timelineWidth + 'px';

        const bar = document.createElement('div');
        bar.className = 'resource-bar';

        const startTime = r.createdAt;
        const endTime = r.callbackEndedAt > 0 ? r.callbackEndedAt : (r.destroyedAt > 0 ? r.destroyedAt : duration);
        const left = (startTime / duration) * timelineWidth;
        const width = Math.max(2, ((endTime - startTime) / duration) * timelineWidth);

        bar.style.left = left + 'px';
        bar.style.width = width + 'px';
        bar.style.background = TYPE_COLORS[r.type] || '#808080';

        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          const asyncWait = r.callbackStartedAt - r.createdAt;
          const syncTime = r.callbackEndedAt - r.callbackStartedAt;
          const total = endTime - startTime;

          if (asyncWait > 0 && total > 0) {
            const asyncDiv = document.createElement('div');
            asyncDiv.className = 'async-wait';
            asyncDiv.style.width = ((asyncWait / total) * 100) + '%';
            asyncDiv.style.background = TYPE_COLORS[r.type] || '#808080';
            bar.appendChild(asyncDiv);
          }

          if (syncTime > 0 && total > 0) {
            const syncDiv = document.createElement('div');
            syncDiv.className = 'sync-time';
            syncDiv.style.width = ((syncTime / total) * 100) + '%';
            syncDiv.style.background = TYPE_COLORS[r.type] || '#808080';
            bar.appendChild(syncDiv);
          }
        }

        const totalMs = (endTime - startTime) / 1e6;
        if (totalMs >= 0.5 && width > 30) {
          const barLabel = document.createElement('span');
          barLabel.className = 'bar-label';
          barLabel.textContent = totalMs.toFixed(1) + 'ms';
          bar.appendChild(barLabel);
        }

        bar.addEventListener('click', () => {
          selectResource(r);
          // Handle click-to-filter
          if (clickToFilterEnabled) {
            applyClickFilter(r.asyncId);
          }
        });
        timeline.appendChild(bar);
        row.appendChild(timeline);
        container.appendChild(row);
      });
    }

    // ==================== BUBBLE VIEW ====================
    function computeBubbleLayout() {
      const container = document.getElementById('bubble-view');
      const canvasWidth = container.clientWidth;
      const canvasHeight = container.clientHeight;

      const padding = 50;
      const width = canvasWidth - padding * 2;
      const height = canvasHeight - padding * 2;

      // Filter resources based on current filter mode and click filter
      const filteredResources = traceData.resources.filter(r =>
        shouldShowResource(r) && isResourceVisible(r.asyncId)
      );

      // Build tree structure with individual resources (not grouped)
      const nodes = new Map();
      const root = filteredResources.find(r => r.type === 'root');
      if (!root) return null;

      // Calculate max sync time for sizing
      const maxSyncTime = Math.max(...filteredResources.map(r =>
        (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) ? r.callbackEndedAt - r.callbackStartedAt : 0
      ), 1);

      // Create nodes for each resource
      filteredResources.forEach(r => {
        const syncTime = (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) ? r.callbackEndedAt - r.callbackStartedAt : 0;
        const isInternal = r._classification === 'internal';
        nodes.set(r.asyncId, {
          resource: r,
          children: [],
          depth: 0,
          x: 0,
          y: 0,
          radius: Math.max(12, Math.min(35, Math.sqrt(syncTime / maxSyncTime) * 40 + 12)),
          color: TYPE_COLORS[r.type] || '#808080',
          subtreeWidth: 0,
          isInternal
        });
      });

      // Build parent-child relationships (only for filtered resources)
      filteredResources.forEach(r => {
        if (r.triggerId !== 0 && nodes.has(r.triggerId) && nodes.has(r.asyncId)) {
          nodes.get(r.triggerId).children.push(nodes.get(r.asyncId));
        }
      });

      // Sort children by creation time to ensure consistent ordering
      nodes.forEach(node => {
        node.children.sort((a, b) => a.resource.createdAt - b.resource.createdAt);
      });

      // Calculate depths (BFS from root)
      const rootNode = nodes.get(root.asyncId);
      if (!rootNode) return null;

      let maxDepth = 0;
      const queue = [[rootNode, 0]];
      while (queue.length > 0) {
        const [node, depth] = queue.shift();
        node.depth = depth;
        maxDepth = Math.max(maxDepth, depth);
        node.children.forEach(child => queue.push([child, depth + 1]));
      }

      // Calculate subtree widths (post-order traversal)
      const nodeSpacing = 50;
      function calcSubtreeWidth(node) {
        if (node.children.length === 0) {
          node.subtreeWidth = node.radius * 2 + nodeSpacing;
          return node.subtreeWidth;
        }
        let totalWidth = 0;
        node.children.forEach(child => {
          totalWidth += calcSubtreeWidth(child);
        });
        node.subtreeWidth = Math.max(node.radius * 2 + nodeSpacing, totalWidth);
        return node.subtreeWidth;
      }
      calcSubtreeWidth(rootNode);

      // Position nodes (top-down tree layout)
      const levelHeight = Math.min(80, (height - 40) / (maxDepth + 1));

      function positionNode(node, leftBound, rightBound) {
        node.x = (leftBound + rightBound) / 2;
        node.y = padding + 30 + node.depth * levelHeight;

        if (node.children.length > 0) {
          const totalChildWidth = node.children.reduce((sum, c) => sum + c.subtreeWidth, 0);
          let currentLeft = node.x - totalChildWidth / 2;

          node.children.forEach(child => {
            const childRight = currentLeft + child.subtreeWidth;
            positionNode(child, currentLeft, childRight);
            currentLeft = childRight;
          });
        }
      }

      // Start positioning from root centered at top
      positionNode(rootNode, padding, canvasWidth - padding);

      // Collect all positioned nodes for rendering
      const allNodes = [];
      function collectNodes(node) {
        allNodes.push(node);
        node.children.forEach(collectNodes);
      }
      collectNodes(rootNode);

      // Also add orphan nodes (not connected to root)
      const positionedIds = new Set(allNodes.map(n => n.resource.asyncId));
      let orphanX = padding + 30;
      nodes.forEach((node, id) => {
        if (!positionedIds.has(id)) {
          node.x = orphanX;
          node.y = canvasHeight - padding - 30;
          orphanX += node.radius * 2 + 20;
          allNodes.push(node);
        }
      });

      return {
        nodes,
        allNodes,
        maxDepth,
        levelHeight,
        padding,
        canvasWidth,
        canvasHeight
      };
    }

    function renderBubble() {
      const container = document.getElementById('bubble-view');
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;

      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (!traceData) return;

      // Compute layout only if not cached or dimensions changed
      if (!cachedBubbleLayout ||
          cachedBubbleLayout.canvasWidth !== canvas.width ||
          cachedBubbleLayout.canvasHeight !== canvas.height) {
        cachedBubbleLayout = computeBubbleLayout();
      }

      if (!cachedBubbleLayout) return;

      const { nodes, allNodes, maxDepth, levelHeight, padding } = cachedBubbleLayout;

      bubbles = [];

      // Apply pan and zoom transform
      ctx.save();
      ctx.translate(panX, panY);
      ctx.scale(zoom, zoom);

      // Draw edges with latency labels
      allNodes.forEach(node => {
        if (node.resource.triggerId !== 0) {
          const parentNode = nodes.get(node.resource.triggerId);
          if (parentNode) {
            // Calculate latency (time from parent callback end or creation to child creation)
            const parentEnd = parentNode.resource.callbackEndedAt > 0 ? parentNode.resource.callbackEndedAt : parentNode.resource.createdAt;
            const childStart = node.resource.createdAt;
            const latencyNs = childStart - parentEnd;
            const latencyMs = latencyNs / 1e6;

            // Draw edge line
            const isInChain = highlightedChain.has(node.resource.asyncId) && highlightedChain.has(parentNode.resource.asyncId);
            ctx.strokeStyle = isInChain ? 'rgba(233, 69, 96, 0.8)' : 'rgba(126, 200, 227, 0.4)';
            ctx.lineWidth = isInChain ? 2 : 1;

            ctx.beginPath();
            ctx.moveTo(parentNode.x, parentNode.y + parentNode.radius);
            ctx.lineTo(node.x, node.y - node.radius);
            ctx.stroke();

            // Draw arrowhead
            const angle = Math.atan2(node.y - node.radius - (parentNode.y + parentNode.radius), node.x - parentNode.x);
            const arrowSize = 6;
            const arrowX = node.x;
            const arrowY = node.y - node.radius;
            ctx.beginPath();
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(arrowX - arrowSize * Math.cos(angle - Math.PI/6), arrowY - arrowSize * Math.sin(angle - Math.PI/6));
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(arrowX - arrowSize * Math.cos(angle + Math.PI/6), arrowY - arrowSize * Math.sin(angle + Math.PI/6));
            ctx.stroke();

            // Draw latency label on edge
            if (Math.abs(latencyMs) >= 0.01) {
              const midX = (parentNode.x + node.x) / 2;
              const midY = (parentNode.y + parentNode.radius + node.y - node.radius) / 2;

              const labelText = latencyMs >= 1 ? `${latencyMs.toFixed(1)}ms` : `${(latencyMs * 1000).toFixed(0)}¬µs`;
              ctx.font = '9px sans-serif';
              const textWidth = ctx.measureText(labelText).width;

              // Background for readability
              ctx.fillStyle = 'rgba(26, 26, 46, 0.9)';
              ctx.fillRect(midX - textWidth/2 - 2, midY - 6, textWidth + 4, 12);

              // Label text
              ctx.fillStyle = latencyMs > 1 ? '#ffd700' : '#888';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(labelText, midX, midY);
            }
          }
        }
      });

      // Draw temporal edges (dashed, green) if enabled
      if (showTemporalEdges && temporalEdges.length > 0) {
        ctx.save();
        ctx.setLineDash([4, 4]);
        ctx.strokeStyle = 'rgba(80, 200, 120, 0.6)';
        ctx.lineWidth = 1.5;

        temporalEdges.forEach(edge => {
          const fromNode = nodes.get(edge.from);
          const toNode = nodes.get(edge.to);
          if (fromNode && toNode) {
            ctx.beginPath();
            ctx.moveTo(fromNode.x + fromNode.radius * 0.7, fromNode.y);
            ctx.lineTo(toNode.x - toNode.radius * 0.7, toNode.y);
            ctx.stroke();

            // Small arrowhead
            const angle = Math.atan2(toNode.y - fromNode.y, toNode.x - fromNode.x);
            const arrowX = toNode.x - toNode.radius * 0.7;
            const arrowY = toNode.y;
            const arrowSize = 5;
            ctx.beginPath();
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(arrowX - arrowSize * Math.cos(angle - Math.PI/6), arrowY - arrowSize * Math.sin(angle - Math.PI/6));
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(arrowX - arrowSize * Math.cos(angle + Math.PI/6), arrowY - arrowSize * Math.sin(angle + Math.PI/6));
            ctx.stroke();
          }
        });

        ctx.restore();
      }

      // Draw bubbles
      allNodes.forEach(node => {
        const r = node.resource;
        const isHighlighted = highlightedChain.has(r.asyncId);
        const isSelected = selectedResource && r.asyncId === selectedResource.asyncId;
        const isOnCriticalPath = showCriticalPath && criticalPathSet.has(r.asyncId);
        const isBottleneck = showBottlenecks && detectedBottlenecks.includes(r.asyncId);
        const patternSeverity = getPatternSeverity(r.asyncId);
        const isPatternMatch = patternSeverity !== null;
        const isInternal = node.isInternal;

        // Glow effect (dimmer for internal)
        const grad = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, node.radius);
        grad.addColorStop(0, node.color);
        grad.addColorStop(0.7, node.color);
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.globalAlpha = isInternal ? 0.15 : 0.3;
        ctx.beginPath();
        ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;

        // Inner circle (dimmer for internal)
        ctx.fillStyle = node.color;
        const baseAlpha = isInternal ? 0.35 : 0.7;
        ctx.globalAlpha = isSelected ? 1 : (isHighlighted ? 0.9 : baseAlpha);
        ctx.beginPath();
        ctx.arc(node.x, node.y, node.radius * 0.75, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;

        // Critical path ring (fire orange glow)
        if (isOnCriticalPath) {
          ctx.strokeStyle = '#ff6432';
          ctx.lineWidth = 3;
          ctx.shadowColor = '#ff6432';
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.arc(node.x, node.y, node.radius * 0.85, 0, Math.PI * 2);
          ctx.stroke();
          ctx.shadowBlur = 0;
        }

        // Bottleneck ring (yellow glow)
        if (isBottleneck && !isOnCriticalPath) {
          ctx.strokeStyle = '#ffc832';
          ctx.lineWidth = 3;
          ctx.shadowColor = '#ffc832';
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.arc(node.x, node.y, node.radius * 0.85, 0, Math.PI * 2);
          ctx.stroke();
          ctx.shadowBlur = 0;
        }

        // Pattern match ring (severity-based purple glow)
        if (isPatternMatch && !isOnCriticalPath && !isBottleneck) {
          const pStyle = getPatternStyle(patternSeverity);
          ctx.strokeStyle = pStyle.color;
          ctx.lineWidth = pStyle.lineWidth;
          ctx.shadowColor = pStyle.color;
          ctx.shadowBlur = pStyle.glow;
          ctx.beginPath();
          ctx.arc(node.x, node.y, node.radius * 0.85, 0, Math.PI * 2);
          ctx.stroke();
          ctx.shadowBlur = 0;
        }

        // Selection ring
        if (isSelected) {
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(node.x, node.y, node.radius * 0.75, 0, Math.PI * 2);
          ctx.stroke();
        }

        // Label inside bubble
        const typeLabel = r.type.replace('js-', '').replace('cache-', '').substring(0, 5);
        ctx.fillStyle = 'white';
        ctx.font = `${Math.min(9, node.radius / 3)}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(typeLabel, node.x, node.y);

        // Store for hit detection
        bubbles.push({
          x: node.x,
          y: node.y,
          radius: node.radius,
          group: { resources: [r] }
        });
      });

      // Draw depth labels on left side
      ctx.fillStyle = '#555';
      ctx.font = '9px sans-serif';
      ctx.textAlign = 'right';
      for (let d = 0; d <= maxDepth; d++) {
        const y = padding + 30 + d * levelHeight;
        ctx.fillText(`L${d}`, padding - 10, y);
      }

      ctx.restore();  // Restore transform

      // Draw zoom/pan hint in corner (not transformed)
      ctx.fillStyle = '#444';
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText(`Scroll: zoom | Shift+drag: pan | Zoom: ${(zoom * 100).toFixed(0)}%`, 10, canvas.height - 10);
    }

    function screenToWorld(screenX, screenY) {
      return {
        x: (screenX - panX) / zoom,
        y: (screenY - panY) / zoom
      };
    }

    function handleBubbleMouseMove(e) {
      if (isPanning) return;

      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left, screenY = e.clientY - rect.top;
      const { x, y } = screenToWorld(screenX, screenY);

      const hovered = bubbles.find(b => {
        const dx = x - b.x, dy = y - b.y;
        return Math.sqrt(dx * dx + dy * dy) <= b.radius;
      });

      if (hovered) {
        const r = hovered.group.resources[0];
        const tooltip = document.getElementById('tooltip');
        const st = traceData.stackTraceMap.get(r.stackTraceId);
        const stackPreview = (st && st.frames.length > 0)
          ? `<div style="margin-top: 0.3rem; font-family: monospace; font-size: 0.65rem; color: #7ec8e3;">
               ${st.frames.slice(0, 3).map(f => `<div>‚Üí ${f}</div>`).join('')}
               ${st.frames.length > 3 ? `<div style="color: #666;">...${st.frames.length - 3} more</div>` : ''}
             </div>`
          : '<div style="color: #666; font-size: 0.65rem; margin-top: 0.3rem;">No stack (internal)</div>';
        const classLabel = r._classification === 'typed' ? 'API' : (r._classification === 'user' ? 'User' : 'Internal');
        const patternHTML = getPatternTooltipHTML(r.asyncId);
        const criticalPathHTML = getCriticalPathTooltipHTML(r.asyncId);
        tooltip.innerHTML = `
          <div class="tooltip-title">${r.type} #${r.asyncId} <span style="color: #888; font-size: 0.7rem;">(${classLabel})</span></div>
          <div>Created: ${(r.createdAt / 1e6).toFixed(2)}ms</div>
          ${r.callbackStartedAt > 0 ? `<div>Callback: ${(r.callbackStartedAt / 1e6).toFixed(2)}ms</div>` : ''}
          ${stackPreview}
          ${criticalPathHTML}
          ${patternHTML}
        `;
        tooltip.style.display = 'block';
        tooltip.style.left = (e.clientX + 10) + 'px';
        tooltip.style.top = (e.clientY + 10) + 'px';
        canvas.style.cursor = 'pointer';
      } else {
        document.getElementById('tooltip').style.display = 'none';
        canvas.style.cursor = 'default';
      }
    }

    function handleBubbleClick(e) {
      if (e.shiftKey) return;  // Shift+click is for panning

      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left, screenY = e.clientY - rect.top;
      const { x, y } = screenToWorld(screenX, screenY);

      const clicked = bubbles.find(b => {
        const dx = x - b.x, dy = y - b.y;
        return Math.sqrt(dx * dx + dy * dy) <= b.radius;
      });

      if (clicked) {
        const resource = clicked.group.resources[0];
        selectResource(resource);
        // Handle click-to-filter
        if (clickToFilterEnabled) {
          applyClickFilter(resource.asyncId);
        }
      }
    }

    // ==================== DAG VIEW ====================
    function initDAGNodes() {
      if (!traceData) return;

      const container = document.getElementById('dag-view');
      const width = container.clientWidth;
      const height = container.clientHeight;

      // Filter based on current filter mode and click filter
      const filteredResources = traceData.resources.filter(r =>
        shouldShowResource(r) && isResourceVisible(r.asyncId)
      );

      // Create nodes with initial positions based on depth
      dagNodes = [];
      const nodeMap = new Map();

      // Group by depth for initial layout
      const depthGroups = new Map();
      filteredResources.forEach(r => {
        const depth = traceData.depthMap.get(r.asyncId) || 0;
        if (!depthGroups.has(depth)) depthGroups.set(depth, []);
        depthGroups.get(depth).push(r);
      });

      const maxDepth = Math.max(...depthGroups.keys(), 0);
      const levelHeight = height / (maxDepth + 2);

      depthGroups.forEach((resources, depth) => {
        const levelWidth = width / (resources.length + 1);
        resources.forEach((r, i) => {
          const node = {
            resource: r,
            x: levelWidth * (i + 1),
            y: levelHeight * (depth + 1),
            vx: 0,
            vy: 0,
            radius: 15,
            color: TYPE_COLORS[r.type] || '#808080',
            fixed: false
          };
          dagNodes.push(node);
          nodeMap.set(r.asyncId, node);
        });
      });

      // Reset pan/zoom
      dagPanX = 0;
      dagPanY = 0;
      dagZoom = 1;

      // Start force simulation
      startDAGSimulation();
    }

    function startDAGSimulation() {
      if (dagSimulationRunning) return;
      dagSimulationRunning = true;

      const container = document.getElementById('dag-view');
      const width = container.clientWidth;
      const height = container.clientHeight;
      const centerX = width / 2;
      const centerY = height / 2;

      let iterations = 0;
      const maxIterations = 150;

      function simulate() {
        if (!dagSimulationRunning || iterations >= maxIterations) {
          dagSimulationRunning = false;
          return;
        }

        const alpha = 1 - iterations / maxIterations;  // Cooling factor

        // Apply forces
        dagNodes.forEach(node => {
          if (node.fixed) return;

          let fx = 0, fy = 0;

          // Repulsion from other nodes
          dagNodes.forEach(other => {
            if (other === node) return;
            const dx = node.x - other.x;
            const dy = node.y - other.y;
            const dist = Math.sqrt(dx*dx + dy*dy) || 1;
            const minDist = 60;
            if (dist < minDist * 3) {
              const force = (minDist * minDist) / (dist * dist) * 2;
              fx += (dx / dist) * force;
              fy += (dy / dist) * force;
            }
          });

          // Attraction to parent
          const r = node.resource;
          if (r.triggerId !== 0) {
            const parent = dagNodes.find(n => n.resource.asyncId === r.triggerId);
            if (parent) {
              const dx = parent.x - node.x;
              const dy = parent.y - node.y;
              const dist = Math.sqrt(dx*dx + dy*dy) || 1;
              const idealDist = 80;
              const force = (dist - idealDist) * 0.05;
              fx += (dx / dist) * force;
              fy += (dy / dist) * force;

              // Also prefer to be below parent
              fy += 0.5;
            }
          }

          // Weak centering force
          fx += (centerX - node.x) * 0.001;
          fy += (centerY - node.y) * 0.001;

          // Apply velocity with damping
          node.vx = (node.vx + fx * alpha) * 0.8;
          node.vy = (node.vy + fy * alpha) * 0.8;

          node.x += node.vx;
          node.y += node.vy;

          // Keep in bounds
          node.x = Math.max(50, Math.min(width - 50, node.x));
          node.y = Math.max(50, Math.min(height - 50, node.y));
        });

        iterations++;
        renderDAG();
        requestAnimationFrame(simulate);
      }

      simulate();
    }

    function renderDAG() {
      const container = document.getElementById('dag-view');
      const canvas = document.getElementById('dag-canvas');
      const ctx = canvas.getContext('2d');

      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;

      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (!traceData || dagNodes.length === 0) {
        // Initialize nodes on first render
        initDAGNodes();
        return;
      }

      ctx.save();
      ctx.translate(dagPanX, dagPanY);
      ctx.scale(dagZoom, dagZoom);

      // Build node lookup for edge drawing
      const nodeMap = new Map();
      dagNodes.forEach(n => nodeMap.set(n.resource.asyncId, n));

      // Draw edges
      dagNodes.forEach(node => {
        const r = node.resource;
        if (r.triggerId !== 0) {
          const parent = nodeMap.get(r.triggerId);
          if (parent) {
            const isHighlighted = highlightedChain.has(r.asyncId) && highlightedChain.has(r.triggerId);
            const isOnCriticalPath = showCriticalPath &&
              criticalPathSet.has(r.asyncId) && criticalPathSet.has(r.triggerId);

            ctx.strokeStyle = isOnCriticalPath ? '#ff6432' :
                             isHighlighted ? '#e94560' : 'rgba(126, 200, 227, 0.3)';
            ctx.lineWidth = isOnCriticalPath ? 3 : (isHighlighted ? 2 : 1);

            ctx.beginPath();
            ctx.moveTo(parent.x, parent.y);
            ctx.lineTo(node.x, node.y);
            ctx.stroke();

            // Arrowhead
            const angle = Math.atan2(node.y - parent.y, node.x - parent.x);
            const arrowX = node.x - node.radius * Math.cos(angle);
            const arrowY = node.y - node.radius * Math.sin(angle);
            const arrowSize = 8;

            ctx.beginPath();
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(arrowX - arrowSize * Math.cos(angle - 0.4), arrowY - arrowSize * Math.sin(angle - 0.4));
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(arrowX - arrowSize * Math.cos(angle + 0.4), arrowY - arrowSize * Math.sin(angle + 0.4));
            ctx.stroke();
          }
        }
      });

      // Draw temporal edges (dashed, green) if enabled
      if (showTemporalEdges && temporalEdges.length > 0) {
        ctx.save();
        ctx.setLineDash([4, 4]);
        ctx.strokeStyle = 'rgba(80, 200, 120, 0.6)';
        ctx.lineWidth = 1.5;

        temporalEdges.forEach(edge => {
          const fromNode = nodeMap.get(edge.from);
          const toNode = nodeMap.get(edge.to);
          if (fromNode && toNode) {
            ctx.beginPath();
            ctx.moveTo(fromNode.x, fromNode.y);
            ctx.lineTo(toNode.x, toNode.y);
            ctx.stroke();

            // Small arrowhead
            const angle = Math.atan2(toNode.y - fromNode.y, toNode.x - fromNode.x);
            const arrowX = toNode.x - toNode.radius * Math.cos(angle);
            const arrowY = toNode.y - toNode.radius * Math.sin(angle);
            const arrowSize = 5;
            ctx.beginPath();
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(arrowX - arrowSize * Math.cos(angle - 0.4), arrowY - arrowSize * Math.sin(angle - 0.4));
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(arrowX - arrowSize * Math.cos(angle + 0.4), arrowY - arrowSize * Math.sin(angle + 0.4));
            ctx.stroke();
          }
        });

        ctx.restore();
      }

      // Draw nodes
      dagNodes.forEach(node => {
        const r = node.resource;
        const isSelected = selectedResource && r.asyncId === selectedResource.asyncId;
        const isHighlighted = highlightedChain.has(r.asyncId);
        const isOnCriticalPath = showCriticalPath && criticalPathSet.has(r.asyncId);
        const isBottleneck = showBottlenecks && detectedBottlenecks.includes(r.asyncId);
        const patternSeverity = getPatternSeverity(r.asyncId);
        const isPatternMatch = patternSeverity !== null;
        const isInternal = r._classification === 'internal';

        // Node circle
        ctx.beginPath();
        ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
        ctx.fillStyle = node.color;
        ctx.globalAlpha = isInternal ? 0.4 : (isHighlighted ? 1 : 0.8);
        ctx.fill();
        ctx.globalAlpha = 1;

        // Critical path glow
        if (isOnCriticalPath) {
          ctx.strokeStyle = '#ff6432';
          ctx.lineWidth = 3;
          ctx.shadowColor = '#ff6432';
          ctx.shadowBlur = 10;
          ctx.stroke();
          ctx.shadowBlur = 0;
        }
        // Bottleneck glow (yellow)
        else if (isBottleneck) {
          ctx.strokeStyle = '#ffc832';
          ctx.lineWidth = 3;
          ctx.shadowColor = '#ffc832';
          ctx.shadowBlur = 10;
          ctx.stroke();
          ctx.shadowBlur = 0;
        }
        // Pattern match glow (severity-based purple)
        else if (isPatternMatch) {
          const pStyle = getPatternStyle(patternSeverity);
          ctx.strokeStyle = pStyle.color;
          ctx.lineWidth = pStyle.lineWidth;
          ctx.shadowColor = pStyle.color;
          ctx.shadowBlur = pStyle.glow;
          ctx.stroke();
          ctx.shadowBlur = 0;
        }

        // Selection ring
        if (isSelected) {
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 3;
          ctx.stroke();
        } else if (isHighlighted && !isOnCriticalPath && !isBottleneck && !isPatternMatch) {
          ctx.strokeStyle = '#e94560';
          ctx.lineWidth = 2;
          ctx.stroke();
        }

        // Label
        ctx.fillStyle = 'white';
        ctx.font = '9px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const label = r.type.replace('js-', '').substring(0, 4);
        ctx.fillText(label, node.x, node.y);
      });

      ctx.restore();

      // Instructions
      ctx.fillStyle = '#444';
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText('Drag nodes | Shift+drag: pan | Scroll: zoom', 10, canvas.height - 10);
    }

    // ==================== PARALLELISM VIEW ====================
    function renderParallelism() {
      const container = document.getElementById('parallelism-view');
      const canvas = document.getElementById('parallelism-canvas');
      const ctx = canvas.getContext('2d');

      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;

      const width = canvas.width;
      const height = canvas.height;
      const padding = { top: 40, right: 20, bottom: 50, left: 60 };
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;

      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, width, height);

      if (!traceData) return;

      const duration = traceData.requestDurationNs;
      const numBuckets = Math.min(500, Math.floor(chartWidth / 2));
      const bucketSize = duration / numBuckets;

      // Count concurrent operations per bucket, separated by type
      const typeBuckets = new Map();  // type -> array of counts
      const allTypes = new Set();

      traceData.resources.forEach(r => {
        allTypes.add(r.type);
        if (!typeBuckets.has(r.type)) {
          typeBuckets.set(r.type, new Array(numBuckets).fill(0));
        }

        const start = r.createdAt;
        const end = r.callbackEndedAt > 0 ? r.callbackEndedAt :
                    (r.destroyedAt > 0 ? r.destroyedAt : duration);

        const startBucket = Math.max(0, Math.floor(start / bucketSize));
        const endBucket = Math.min(numBuckets - 1, Math.floor(end / bucketSize));

        const buckets = typeBuckets.get(r.type);
        for (let i = startBucket; i <= endBucket; i++) {
          buckets[i]++;
        }
      });

      // Calculate total per bucket and find max
      const totalBuckets = new Array(numBuckets).fill(0);
      typeBuckets.forEach(buckets => {
        buckets.forEach((count, i) => totalBuckets[i] += count);
      });
      const maxConcurrent = Math.max(...totalBuckets, 1);

      // Sort types by total count for consistent stacking
      const sortedTypes = Array.from(allTypes).sort((a, b) => {
        const sumA = typeBuckets.get(a).reduce((s, v) => s + v, 0);
        const sumB = typeBuckets.get(b).reduce((s, v) => s + v, 0);
        return sumB - sumA;
      });

      // Draw title
      ctx.fillStyle = '#e94560';
      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Concurrent Operations Over Time', width / 2, 20);

      // Draw axes
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding.left, padding.top);
      ctx.lineTo(padding.left, height - padding.bottom);
      ctx.lineTo(width - padding.right, height - padding.bottom);
      ctx.stroke();

      // Y-axis labels
      ctx.fillStyle = '#888';
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'right';
      for (let i = 0; i <= 5; i++) {
        const y = padding.top + (1 - i / 5) * chartHeight;
        const value = Math.round((i / 5) * maxConcurrent);
        ctx.fillText(value.toString(), padding.left - 8, y + 3);

        // Grid line
        ctx.strokeStyle = '#333';
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(width - padding.right, y);
        ctx.stroke();
      }

      // X-axis labels
      ctx.textAlign = 'center';
      for (let i = 0; i <= 5; i++) {
        const x = padding.left + (i / 5) * chartWidth;
        const time = (i / 5) * duration / 1e6;
        ctx.fillText(time.toFixed(1) + 'ms', x, height - padding.bottom + 15);
      }

      // Draw stacked area chart
      const barWidth = chartWidth / numBuckets;

      for (let i = 0; i < numBuckets; i++) {
        let y = height - padding.bottom;
        const x = padding.left + i * barWidth;

        sortedTypes.forEach(type => {
          const count = typeBuckets.get(type)[i];
          if (count > 0) {
            const barHeight = (count / maxConcurrent) * chartHeight;
            ctx.fillStyle = TYPE_COLORS[type] || '#808080';
            ctx.globalAlpha = 0.8;
            ctx.fillRect(x, y - barHeight, barWidth + 0.5, barHeight);
            y -= barHeight;
          }
        });
      }
      ctx.globalAlpha = 1;

      // Draw "parallelism = 1" danger line
      const oneLineY = height - padding.bottom - (1 / maxConcurrent) * chartHeight;
      if (maxConcurrent > 1) {
        ctx.strokeStyle = '#ff6432';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(padding.left, oneLineY);
        ctx.lineTo(width - padding.right, oneLineY);
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.fillStyle = '#ff6432';
        ctx.font = '9px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText('‚Üê serialization (=1)', width - padding.right - 100, oneLineY - 5);
      }

      // Find and highlight serialization points (where concurrency drops to 1)
      let serializationPoints = [];
      for (let i = 1; i < numBuckets - 1; i++) {
        if (totalBuckets[i] === 1 && (totalBuckets[i-1] > 1 || totalBuckets[i+1] > 1)) {
          serializationPoints.push(i);
        }
      }

      // Draw serialization markers
      ctx.fillStyle = 'rgba(255, 100, 50, 0.3)';
      serializationPoints.forEach(i => {
        const x = padding.left + i * barWidth;
        ctx.fillRect(x - 2, padding.top, 4, chartHeight);
      });

      // Draw legend
      const legendY = height - 25;
      let legendX = padding.left;
      ctx.font = '10px sans-serif';

      sortedTypes.slice(0, 8).forEach(type => {
        ctx.fillStyle = TYPE_COLORS[type] || '#808080';
        ctx.fillRect(legendX, legendY, 12, 12);
        ctx.fillStyle = '#aaa';
        ctx.textAlign = 'left';
        const label = type.replace('js-', '').substring(0, 8);
        ctx.fillText(label, legendX + 16, legendY + 10);
        legendX += ctx.measureText(label).width + 30;
      });

      // Stats overlay
      const avgConcurrency = totalBuckets.reduce((s, v) => s + v, 0) / numBuckets;
      const serializationPct = (totalBuckets.filter(v => v <= 1).length / numBuckets * 100).toFixed(0);

      ctx.fillStyle = 'rgba(22, 33, 62, 0.9)';
      ctx.fillRect(width - 180, padding.top, 170, 70);
      ctx.strokeStyle = '#0f3460';
      ctx.strokeRect(width - 180, padding.top, 170, 70);

      ctx.fillStyle = '#e94560';
      ctx.font = 'bold 11px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText('Statistics', width - 170, padding.top + 15);

      ctx.fillStyle = '#aaa';
      ctx.font = '10px sans-serif';
      ctx.fillText(`Peak: ${maxConcurrent} concurrent`, width - 170, padding.top + 32);
      ctx.fillText(`Avg: ${avgConcurrency.toFixed(1)} concurrent`, width - 170, padding.top + 46);
      ctx.fillText(`Serialized: ${serializationPct}% of time`, width - 170, padding.top + 60);
    }

    // ==================== BREAKDOWN VIEW ====================
    function renderBreakdown() {
      const container = document.getElementById('breakdown-view');
      const canvas = document.getElementById('breakdown-canvas');
      const ctx = canvas.getContext('2d');

      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;

      const width = canvas.width;
      const height = canvas.height;
      const padding = { top: 50, right: 20, bottom: 30, left: 20 };
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;

      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, width, height);

      if (!traceData) return;

      // Gather time data by type
      const typeData = new Map();

      traceData.resources.forEach(r => {
        if (!typeData.has(r.type)) {
          typeData.set(r.type, { type: r.type, syncTime: 0, asyncTime: 0, count: 0 });
        }
        const data = typeData.get(r.type);
        data.count++;

        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          data.syncTime += r.callbackEndedAt - r.callbackStartedAt;
        }
        if (r.callbackStartedAt > 0 && r.createdAt > 0) {
          data.asyncTime += r.callbackStartedAt - r.createdAt;
        }
      });

      // Convert to array and calculate total time per type
      const types = Array.from(typeData.values())
        .map(d => ({ ...d, totalTime: d.syncTime + d.asyncTime }))
        .filter(d => d.totalTime > 0)
        .sort((a, b) => b.totalTime - a.totalTime);

      if (types.length === 0) {
        ctx.fillStyle = '#666';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('No timing data available', width / 2, height / 2);
        return;
      }

      const totalTime = types.reduce((sum, t) => sum + t.totalTime, 0);

      // Draw title
      ctx.fillStyle = '#e94560';
      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Time Breakdown by Resource Type (Treemap)', width / 2, 25);

      // Treemap layout using squarified algorithm
      function squarify(items, x, y, w, h) {
        if (items.length === 0) return [];

        const result = [];
        const total = items.reduce((sum, item) => sum + item.totalTime, 0);

        // Base case: single item fills the whole space
        if (items.length === 1) {
          result.push({ ...items[0], x, y, w, h });
          return result;
        }

        // Find best row (squarified algorithm)
        const scale = (w * h) / total;
        const isVertical = w >= h;
        const side = isVertical ? h : w;

        let rowItems = [];
        let rowArea = 0;
        let bestWorst = Infinity;

        for (let i = 0; i < items.length; i++) {
          const testRow = [...rowItems, items[i]];
          const testArea = rowArea + items[i].totalTime;

          // Calculate worst aspect ratio in this row
          const rowSide = testArea * scale / side;
          let worst = 0;
          testRow.forEach(item => {
            const itemSide = (item.totalTime * scale) / rowSide;
            const aspect = Math.max(rowSide / itemSide, itemSide / rowSide);
            worst = Math.max(worst, aspect);
          });

          if (worst <= bestWorst || rowItems.length === 0) {
            rowItems = testRow;
            rowArea = testArea;
            bestWorst = worst;
          } else {
            break;
          }
        }

        // Layout the row
        const rowSize = rowArea * scale / side;
        let pos = 0;

        rowItems.forEach(item => {
          const itemSize = item.totalTime * scale / rowSize;
          if (isVertical) {
            result.push({ ...item, x: x, y: y + pos, w: rowSize, h: itemSize });
          } else {
            result.push({ ...item, x: x + pos, y: y, w: itemSize, h: rowSize });
          }
          pos += itemSize;
        });

        // Recursively layout remaining items
        const remaining = items.slice(rowItems.length);
        if (remaining.length > 0) {
          if (isVertical) {
            result.push(...squarify(remaining, x + rowSize, y, w - rowSize, h));
          } else {
            result.push(...squarify(remaining, x, y + rowSize, w, h - rowSize));
          }
        }

        return result;
      }

      const rects = squarify(types, padding.left, padding.top, chartWidth, chartHeight);

      // Draw treemap rectangles
      rects.forEach(rect => {
        const color = TYPE_COLORS[rect.type] || '#808080';

        // Split rectangle to show sync vs async
        if (rect.syncTime > 0 || rect.asyncTime > 0) {
          const syncRatio = rect.syncTime / rect.totalTime;
          const asyncRatio = 1 - syncRatio;

          // Draw async portion (top) - higher contrast now
          if (asyncRatio > 0) {
            const asyncHeight = (rect.h - 2) * asyncRatio;
            if (accessibilityMode) {
              // In accessibility mode, use diagonal stripes for async
              ctx.fillStyle = color;
              ctx.globalAlpha = 0.5;
              ctx.fillRect(rect.x + 1, rect.y + 1, rect.w - 2, asyncHeight);
              // Draw stripe pattern
              ctx.strokeStyle = 'rgba(255,255,255,0.4)';
              ctx.lineWidth = 1;
              ctx.beginPath();
              for (let i = -asyncHeight; i < rect.w; i += 6) {
                ctx.moveTo(rect.x + 1 + i, rect.y + 1 + asyncHeight);
                ctx.lineTo(rect.x + 1 + i + asyncHeight, rect.y + 1);
              }
              ctx.stroke();
              ctx.globalAlpha = 1;
            } else {
              ctx.fillStyle = color;
              ctx.globalAlpha = 0.55;  // Increased from 0.4 for better visibility
              ctx.fillRect(rect.x + 1, rect.y + 1, rect.w - 2, asyncHeight);
              ctx.globalAlpha = 1;
            }
          }

          // Draw sync portion (solid) at bottom
          if (syncRatio > 0) {
            const syncHeight = (rect.h - 2) * syncRatio;
            if (accessibilityMode) {
              ctx.fillStyle = getPattern(ctx, rect.type, color);
            } else {
              ctx.fillStyle = color;
            }
            ctx.globalAlpha = 0.95;
            ctx.fillRect(rect.x + 1, rect.y + rect.h - 1 - syncHeight, rect.w - 2, syncHeight);
            ctx.globalAlpha = 1;
          }

          // Draw dividing line between sync and async in accessibility mode
          if (accessibilityMode && syncRatio > 0 && asyncRatio > 0) {
            const dividerY = rect.y + rect.h - 1 - (rect.h - 2) * syncRatio;
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(rect.x + 1, dividerY);
            ctx.lineTo(rect.x + rect.w - 1, dividerY);
            ctx.stroke();
          }
        } else {
          // No timing data - just fill solid
          ctx.fillStyle = accessibilityMode ? getPattern(ctx, rect.type, color) : color;
          ctx.globalAlpha = 0.85;
          ctx.fillRect(rect.x + 1, rect.y + 1, rect.w - 2, rect.h - 2);
          ctx.globalAlpha = 1;
        }

        // Border
        ctx.strokeStyle = '#1a1a2e';
        ctx.lineWidth = 2;
        ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);

        // Label (only if rectangle is big enough)
        if (rect.w > 50 && rect.h > 40) {
          // Determine if we need dark text based on background color luminance
          const isLightBg = isLightColor(color);
          ctx.fillStyle = isLightBg ? '#1a1a2e' : 'white';
          ctx.font = 'bold 14px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          const label = rect.type.replace('js-', '').replace('cache-', 'c:');
          const timeMs = (rect.totalTime / 1e6).toFixed(1);
          const pct = ((rect.totalTime / totalTime) * 100).toFixed(0);

          ctx.fillText(label, rect.x + rect.w / 2, rect.y + rect.h / 2 - 14);

          ctx.font = '12px sans-serif';
          ctx.fillText(`${timeMs}ms`, rect.x + rect.w / 2, rect.y + rect.h / 2 + 4);
          ctx.fillText(`(${pct}%)`, rect.x + rect.w / 2, rect.y + rect.h / 2 + 20);

          // Sync/async breakdown if big enough
          if (rect.h > 80) {
            const syncPct = ((rect.syncTime / rect.totalTime) * 100).toFixed(0);
            ctx.font = '11px sans-serif';
            ctx.fillStyle = isLightBg ? 'rgba(26,26,46,0.7)' : 'rgba(255,255,255,0.7)';
            ctx.fillText(`sync: ${syncPct}%`, rect.x + rect.w / 2, rect.y + rect.h / 2 + 38);
          }
        } else if (rect.w > 25 && rect.h > 20) {
          // Abbreviated label
          const isLightBg = isLightColor(color);
          ctx.fillStyle = isLightBg ? '#1a1a2e' : 'white';
          ctx.font = '11px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          const shortLabel = rect.type.substring(0, 3);
          ctx.fillText(shortLabel, rect.x + rect.w / 2, rect.y + rect.h / 2);
        }
      });

      // Legend for sync/async
      const legendY = height - 20;
      ctx.fillStyle = '#888';
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'left';

      ctx.globalAlpha = 0.9;
      ctx.fillStyle = '#666';
      ctx.fillRect(padding.left, legendY - 8, 12, 12);
      ctx.globalAlpha = 0.4;
      ctx.fillRect(padding.left + 80, legendY - 8, 12, 12);
      ctx.globalAlpha = 1;

      ctx.fillStyle = '#888';
      ctx.fillText('= Sync time', padding.left + 16, legendY);
      ctx.fillText('= Async wait', padding.left + 96, legendY);

      // Stats overlay
      ctx.fillStyle = 'rgba(22, 33, 62, 0.9)';
      ctx.fillRect(width - 200, padding.top, 190, 85);
      ctx.strokeStyle = '#0f3460';
      ctx.strokeRect(width - 200, padding.top, 190, 85);

      ctx.fillStyle = '#e94560';
      ctx.font = 'bold 11px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText('Top Time Consumers', width - 190, padding.top + 15);

      ctx.fillStyle = '#aaa';
      ctx.font = '10px sans-serif';
      types.slice(0, 4).forEach((t, i) => {
        const y = padding.top + 30 + i * 13;
        const pct = ((t.totalTime / totalTime) * 100).toFixed(0);
        const label = t.type.replace('js-', '');
        ctx.fillStyle = TYPE_COLORS[t.type] || '#808080';
        ctx.fillRect(width - 190, y - 8, 8, 8);
        ctx.fillStyle = '#aaa';
        ctx.fillText(`${label}: ${pct}% (${t.count})`, width - 178, y);
      });
    }

    // ==================== LATENCY VIEW ====================
    function renderLatency() {
      const container = document.getElementById('latency-view');
      const canvas = document.getElementById('latency-canvas');
      const ctx = canvas.getContext('2d');

      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;

      const width = canvas.width;
      const height = canvas.height;
      const padding = { top: 50, right: 30, bottom: 80, left: 70 };
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;

      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, width, height);

      if (!traceData) return;

      // Collect async wait times (latencies) for all resources
      const latencies = [];
      traceData.resources.forEach(r => {
        if (r.callbackStartedAt > 0 && r.createdAt > 0) {
          const latencyNs = r.callbackStartedAt - r.createdAt;
          if (latencyNs > 0) {
            latencies.push({
              latencyNs,
              latencyMs: latencyNs / 1e6,
              resource: r
            });
          }
        }
      });

      if (latencies.length === 0) {
        ctx.fillStyle = '#666';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('No latency data available', width / 2, height / 2);
        return;
      }

      // Sort by latency for percentile calculations
      latencies.sort((a, b) => a.latencyNs - b.latencyNs);

      const minLatency = latencies[0].latencyMs;
      const maxLatency = latencies[latencies.length - 1].latencyMs;
      const p50 = latencies[Math.floor(latencies.length * 0.5)].latencyMs;
      const p90 = latencies[Math.floor(latencies.length * 0.9)].latencyMs;
      const p99 = latencies[Math.floor(latencies.length * 0.99)].latencyMs;
      const avgLatency = latencies.reduce((s, l) => s + l.latencyMs, 0) / latencies.length;

      // Create histogram buckets (logarithmic scale for wide range)
      const numBuckets = Math.min(50, Math.floor(chartWidth / 15));
      const useLogScale = maxLatency / Math.max(minLatency, 0.001) > 100;

      let buckets;
      if (useLogScale) {
        // Logarithmic buckets for wide range
        const logMin = Math.log10(Math.max(minLatency, 0.001));
        const logMax = Math.log10(maxLatency);
        const logStep = (logMax - logMin) / numBuckets;
        buckets = Array.from({ length: numBuckets }, (_, i) => ({
          min: Math.pow(10, logMin + i * logStep),
          max: Math.pow(10, logMin + (i + 1) * logStep),
          count: 0,
          byType: new Map()
        }));
      } else {
        // Linear buckets for narrow range
        const step = (maxLatency - minLatency) / numBuckets || 1;
        buckets = Array.from({ length: numBuckets }, (_, i) => ({
          min: minLatency + i * step,
          max: minLatency + (i + 1) * step,
          count: 0,
          byType: new Map()
        }));
      }

      // Fill buckets
      latencies.forEach(l => {
        for (let i = 0; i < buckets.length; i++) {
          if (l.latencyMs >= buckets[i].min && (l.latencyMs < buckets[i].max || i === buckets.length - 1)) {
            buckets[i].count++;
            const type = l.resource.type;
            buckets[i].byType.set(type, (buckets[i].byType.get(type) || 0) + 1);
            break;
          }
        }
      });

      const maxCount = Math.max(...buckets.map(b => b.count), 1);

      // Draw title
      ctx.fillStyle = '#e94560';
      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Async Wait Time Distribution (Histogram)', width / 2, 25);

      // Draw axes
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding.left, padding.top);
      ctx.lineTo(padding.left, height - padding.bottom);
      ctx.lineTo(width - padding.right, height - padding.bottom);
      ctx.stroke();

      // Y-axis labels (count)
      ctx.fillStyle = '#888';
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'right';
      for (let i = 0; i <= 5; i++) {
        const y = padding.top + (1 - i / 5) * chartHeight;
        const value = Math.round((i / 5) * maxCount);
        ctx.fillText(value.toString(), padding.left - 8, y + 3);

        // Grid line
        ctx.strokeStyle = '#333';
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(width - padding.right, y);
        ctx.stroke();
      }

      // Y-axis title
      ctx.save();
      ctx.translate(15, height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillStyle = '#888';
      ctx.font = '11px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Count', 0, 0);
      ctx.restore();

      // Draw histogram bars (stacked by type)
      const barWidth = chartWidth / buckets.length;
      const allTypes = new Set();
      buckets.forEach(b => b.byType.forEach((_, type) => allTypes.add(type)));
      const sortedTypes = Array.from(allTypes).sort((a, b) => {
        const countA = buckets.reduce((s, b) => s + (b.byType.get(a) || 0), 0);
        const countB = buckets.reduce((s, b) => s + (b.byType.get(b) || 0), 0);
        return countB - countA;
      });

      buckets.forEach((bucket, i) => {
        const x = padding.left + i * barWidth;
        let y = height - padding.bottom;

        sortedTypes.forEach(type => {
          const count = bucket.byType.get(type) || 0;
          if (count > 0) {
            const barHeight = (count / maxCount) * chartHeight;
            ctx.fillStyle = TYPE_COLORS[type] || '#808080';
            ctx.globalAlpha = 0.85;
            ctx.fillRect(x + 1, y - barHeight, barWidth - 2, barHeight);
            y -= barHeight;
          }
        });
      });
      ctx.globalAlpha = 1;

      // X-axis labels
      ctx.fillStyle = '#888';
      ctx.font = '9px sans-serif';
      ctx.textAlign = 'center';
      const labelInterval = Math.ceil(buckets.length / 8);
      buckets.forEach((bucket, i) => {
        if (i % labelInterval === 0 || i === buckets.length - 1) {
          const x = padding.left + (i + 0.5) * barWidth;
          const label = bucket.min < 1 ? `${(bucket.min * 1000).toFixed(0)}¬µs` : `${bucket.min.toFixed(1)}ms`;
          ctx.fillText(label, x, height - padding.bottom + 15);
        }
      });

      // X-axis title
      ctx.fillStyle = '#888';
      ctx.font = '11px sans-serif';
      ctx.fillText('Async Wait Time' + (useLogScale ? ' (log scale)' : ''), width / 2, height - padding.bottom + 35);

      // Draw percentile lines
      function drawPercentileLine(value, label, color) {
        let x;
        if (useLogScale) {
          const logMin = Math.log10(Math.max(minLatency, 0.001));
          const logMax = Math.log10(maxLatency);
          const logVal = Math.log10(Math.max(value, 0.001));
          x = padding.left + ((logVal - logMin) / (logMax - logMin)) * chartWidth;
        } else {
          x = padding.left + ((value - minLatency) / (maxLatency - minLatency)) * chartWidth;
        }

        if (x >= padding.left && x <= width - padding.right) {
          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
          ctx.setLineDash([4, 4]);
          ctx.beginPath();
          ctx.moveTo(x, padding.top);
          ctx.lineTo(x, height - padding.bottom);
          ctx.stroke();
          ctx.setLineDash([]);

          ctx.fillStyle = color;
          ctx.font = '9px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText(label, x, padding.top - 5);
        }
      }

      drawPercentileLine(p50, 'p50', '#50c878');
      drawPercentileLine(p90, 'p90', '#ffd700');
      drawPercentileLine(p99, 'p99', '#ff6347');

      // Stats overlay
      ctx.fillStyle = 'rgba(22, 33, 62, 0.95)';
      ctx.fillRect(width - 180, padding.top, 170, 115);
      ctx.strokeStyle = '#0f3460';
      ctx.strokeRect(width - 180, padding.top, 170, 115);

      ctx.fillStyle = '#e94560';
      ctx.font = 'bold 11px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText('Latency Statistics', width - 170, padding.top + 15);

      ctx.font = '10px sans-serif';
      ctx.fillStyle = '#aaa';
      ctx.fillText(`Count: ${latencies.length} resources`, width - 170, padding.top + 32);
      ctx.fillText(`Min: ${minLatency < 1 ? (minLatency * 1000).toFixed(0) + '¬µs' : minLatency.toFixed(2) + 'ms'}`, width - 170, padding.top + 46);
      ctx.fillText(`Avg: ${avgLatency.toFixed(2)}ms`, width - 170, padding.top + 60);

      ctx.fillStyle = '#50c878';
      ctx.fillText(`p50: ${p50.toFixed(2)}ms`, width - 170, padding.top + 74);
      ctx.fillStyle = '#ffd700';
      ctx.fillText(`p90: ${p90.toFixed(2)}ms`, width - 170, padding.top + 88);
      ctx.fillStyle = '#ff6347';
      ctx.fillText(`p99: ${p99.toFixed(2)}ms`, width - 170, padding.top + 102);

      // Legend at bottom
      const legendY = height - 25;
      let legendX = padding.left;
      ctx.font = '10px sans-serif';

      sortedTypes.slice(0, 6).forEach(type => {
        ctx.fillStyle = TYPE_COLORS[type] || '#808080';
        ctx.fillRect(legendX, legendY - 8, 12, 12);
        ctx.fillStyle = '#aaa';
        ctx.textAlign = 'left';
        const label = type.replace('js-', '').substring(0, 8);
        ctx.fillText(label, legendX + 16, legendY);
        legendX += ctx.measureText(label).width + 30;
      });
    }

    // ==================== GAPS VIEW ====================
    function renderGaps() {
      const container = document.getElementById('gaps-view');
      const canvas = document.getElementById('gaps-canvas');
      const ctx = canvas.getContext('2d');

      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;

      const width = canvas.width;
      const height = canvas.height;
      const padding = { top: 50, right: 30, bottom: 60, left: 70 };
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;

      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, width, height);

      if (!traceData) return;

      const duration = traceData.requestDurationNs;

      // Build timeline of activity - track when sync work is happening
      const numBuckets = Math.min(1000, Math.floor(chartWidth));
      const bucketSize = duration / numBuckets;
      const activityBuckets = new Array(numBuckets).fill(0);  // Count of active sync operations
      const asyncBuckets = new Array(numBuckets).fill(0);     // Count of resources in async wait

      traceData.resources.forEach(r => {
        // Track sync execution periods
        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          const startBucket = Math.max(0, Math.floor(r.callbackStartedAt / bucketSize));
          const endBucket = Math.min(numBuckets - 1, Math.floor(r.callbackEndedAt / bucketSize));
          for (let i = startBucket; i <= endBucket; i++) {
            activityBuckets[i]++;
          }
        }

        // Track async wait periods
        if (r.createdAt > 0) {
          const waitEnd = r.callbackStartedAt > 0 ? r.callbackStartedAt :
                         (r.callbackEndedAt > 0 ? r.callbackEndedAt :
                         (r.destroyedAt > 0 ? r.destroyedAt : duration));
          const startBucket = Math.max(0, Math.floor(r.createdAt / bucketSize));
          const endBucket = Math.min(numBuckets - 1, Math.floor(waitEnd / bucketSize));
          for (let i = startBucket; i <= endBucket; i++) {
            asyncBuckets[i]++;
          }
        }
      });

      // Find gaps: periods where nothing is executing (no sync activity)
      // but there might be async waits happening
      const gaps = [];
      let gapStart = null;

      for (let i = 0; i < numBuckets; i++) {
        const isIdle = activityBuckets[i] === 0;
        if (isIdle && gapStart === null) {
          gapStart = i;
        } else if (!isIdle && gapStart !== null) {
          const gapEnd = i;
          const gapDurationNs = (gapEnd - gapStart) * bucketSize;
          if (gapDurationNs > duration * 0.005) {  // Only gaps > 0.5% of total
            gaps.push({
              startBucket: gapStart,
              endBucket: gapEnd,
              startNs: gapStart * bucketSize,
              endNs: gapEnd * bucketSize,
              durationNs: gapDurationNs,
              durationMs: gapDurationNs / 1e6,
              asyncWaiters: Math.max(...asyncBuckets.slice(gapStart, gapEnd + 1))
            });
          }
          gapStart = null;
        }
      }

      // Handle gap at end
      if (gapStart !== null) {
        const gapEnd = numBuckets;
        const gapDurationNs = (gapEnd - gapStart) * bucketSize;
        if (gapDurationNs > duration * 0.005) {
          gaps.push({
            startBucket: gapStart,
            endBucket: gapEnd,
            startNs: gapStart * bucketSize,
            endNs: gapEnd * bucketSize,
            durationNs: gapDurationNs,
            durationMs: gapDurationNs / 1e6,
            asyncWaiters: Math.max(...asyncBuckets.slice(gapStart, gapEnd))
          });
        }
      }

      // Sort gaps by duration
      gaps.sort((a, b) => b.durationNs - a.durationNs);

      // For each gap, find the resources that are waiting during it
      gaps.forEach(gap => {
        gap.waitingResources = traceData.resources.filter(r => {
          if (r.createdAt <= 0) return false;
          // Resource must be created before the gap ends
          if (r.createdAt > gap.endNs) return false;
          // Resource must not have completed before the gap starts
          const waitEnd = r.callbackStartedAt > 0 ? r.callbackStartedAt :
                         (r.callbackEndedAt > 0 ? r.callbackEndedAt :
                         (r.destroyedAt > 0 ? r.destroyedAt : duration));
          return waitEnd > gap.startNs;
        });
      });

      // Store gaps for hover detection (barWidth stored after it's computed below)
      gapsData = gaps;

      const totalGapTime = gaps.reduce((s, g) => s + g.durationNs, 0);
      const gapPercent = (totalGapTime / duration * 100).toFixed(1);

      // Draw title
      ctx.fillStyle = '#e94560';
      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Gap Analysis - Idle Periods (No Sync Execution)', width / 2, 25);

      // Draw axes
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding.left, padding.top);
      ctx.lineTo(padding.left, height - padding.bottom);
      ctx.lineTo(width - padding.right, height - padding.bottom);
      ctx.stroke();

      // Draw activity timeline
      const maxActivity = Math.max(...activityBuckets, 1);
      const barWidth = chartWidth / numBuckets;

      // Store render params for hover detection
      gapsRenderParams = { padding, chartWidth, chartHeight, barWidth, numBuckets, bucketSize, duration };

      // Background showing async waiters (light)
      for (let i = 0; i < numBuckets; i++) {
        if (asyncBuckets[i] > 0) {
          const barHeight = (asyncBuckets[i] / Math.max(...asyncBuckets, 1)) * chartHeight * 0.3;
          ctx.fillStyle = accessibilityMode ? 'rgba(126, 200, 227, 0.35)' : 'rgba(126, 200, 227, 0.2)';
          ctx.fillRect(padding.left + i * barWidth, height - padding.bottom - barHeight, barWidth, barHeight);
        }
      }

      // Draw sync activity bars
      for (let i = 0; i < numBuckets; i++) {
        if (activityBuckets[i] > 0) {
          const barHeight = (activityBuckets[i] / maxActivity) * chartHeight * 0.6;
          const x = padding.left + i * barWidth;
          const y = height - padding.bottom - barHeight;
          ctx.fillStyle = '#50c878';
          ctx.globalAlpha = accessibilityMode ? 1.0 : 0.8;
          ctx.fillRect(x, y, barWidth, barHeight);
        }
      }
      ctx.globalAlpha = 1;

      // In accessibility mode, draw a white border around the sync activity region
      if (accessibilityMode) {
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(padding.left, height - padding.bottom);
        for (let i = 0; i < numBuckets; i++) {
          const barHeight = (activityBuckets[i] / maxActivity) * chartHeight * 0.6;
          ctx.lineTo(padding.left + i * barWidth, height - padding.bottom - barHeight);
          ctx.lineTo(padding.left + (i + 1) * barWidth, height - padding.bottom - barHeight);
        }
        ctx.stroke();
      }

      // Highlight gaps with red overlay
      gaps.forEach((gap, idx) => {
        const x = padding.left + gap.startBucket * barWidth;
        const gapWidth = (gap.endBucket - gap.startBucket) * barWidth;

        // Red gap highlight - higher opacity in accessibility mode
        const baseOpacity = idx < 3 ? 0.4 : 0.2;
        const opacity = accessibilityMode ? baseOpacity + 0.15 : baseOpacity;
        ctx.fillStyle = `rgba(255, 100, 50, ${opacity})`;
        ctx.fillRect(x, padding.top, gapWidth, chartHeight);

        // Gap border - thicker in accessibility mode
        ctx.strokeStyle = '#ff6432';
        ctx.lineWidth = accessibilityMode ? (idx < 3 ? 3 : 2) : (idx < 3 ? 2 : 1);
        ctx.strokeRect(x, padding.top, gapWidth, chartHeight);

        // Label for significant gaps
        if (gap.durationMs >= 0.1 && gapWidth > 30) {
          ctx.fillStyle = '#ff6432';
          ctx.font = 'bold 10px sans-serif';
          ctx.textAlign = 'center';
          const label = gap.durationMs >= 1 ? `${gap.durationMs.toFixed(1)}ms` : `${(gap.durationMs * 1000).toFixed(0)}¬µs`;
          ctx.fillText(label, x + gapWidth / 2, padding.top + 15);

          if (gap.asyncWaiters > 0 && gapWidth > 50) {
            ctx.font = '9px sans-serif';
            ctx.fillStyle = '#7ec8e3';
            ctx.fillText(`${gap.asyncWaiters} waiting`, x + gapWidth / 2, padding.top + 28);
          }
        }
      });

      // X-axis labels
      ctx.fillStyle = '#888';
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'center';
      for (let i = 0; i <= 5; i++) {
        const x = padding.left + (i / 5) * chartWidth;
        const time = (i / 5) * duration / 1e6;
        ctx.fillText(time.toFixed(1) + 'ms', x, height - padding.bottom + 15);
      }

      // X-axis title
      ctx.fillText('Time', width / 2, height - padding.bottom + 35);

      // Y-axis title
      ctx.save();
      ctx.translate(20, height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillStyle = '#888';
      ctx.font = '11px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Activity Level', 0, 0);
      ctx.restore();

      // Legend
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'left';

      // Sync execution legend
      ctx.fillStyle = '#50c878';
      ctx.fillRect(padding.left, height - 25, 12, 12);
      if (accessibilityMode) {
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.lineWidth = 2;
        ctx.strokeRect(padding.left, height - 25, 12, 12);
      }
      ctx.fillStyle = '#888';
      ctx.fillText('Sync execution', padding.left + 16, height - 16);

      // Async waiting legend
      ctx.fillStyle = accessibilityMode ? 'rgba(126, 200, 227, 0.5)' : 'rgba(126, 200, 227, 0.5)';
      ctx.fillRect(padding.left + 110, height - 25, 12, 12);
      ctx.fillStyle = '#888';
      ctx.fillText('Async waiting', padding.left + 126, height - 16);

      // Idle gaps legend
      ctx.fillStyle = accessibilityMode ? 'rgba(255, 100, 50, 0.55)' : 'rgba(255, 100, 50, 0.5)';
      ctx.fillRect(padding.left + 220, height - 25, 12, 12);
      ctx.strokeStyle = '#ff6432';
      ctx.lineWidth = accessibilityMode ? 2 : 1;
      ctx.strokeRect(padding.left + 220, height - 25, 12, 12);
      ctx.fillStyle = '#888';
      ctx.fillText('Idle gaps', padding.left + 236, height - 16);

      // Stats overlay
      ctx.fillStyle = 'rgba(22, 33, 62, 0.95)';
      ctx.fillRect(width - 200, padding.top, 190, 100);
      ctx.strokeStyle = '#0f3460';
      ctx.strokeRect(width - 200, padding.top, 190, 100);

      ctx.fillStyle = '#e94560';
      ctx.font = 'bold 11px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText('Gap Statistics', width - 190, padding.top + 15);

      ctx.font = '10px sans-serif';
      ctx.fillStyle = '#aaa';
      ctx.fillText(`Gaps found: ${gaps.length}`, width - 190, padding.top + 32);
      ctx.fillText(`Total idle: ${(totalGapTime / 1e6).toFixed(2)}ms (${gapPercent}%)`, width - 190, padding.top + 46);

      if (gaps.length > 0) {
        ctx.fillStyle = '#ff6432';
        ctx.fillText(`Largest: ${gaps[0].durationMs.toFixed(2)}ms`, width - 190, padding.top + 60);
        ctx.fillStyle = '#aaa';
        ctx.fillText(`  at ${(gaps[0].startNs / 1e6).toFixed(2)}ms`, width - 190, padding.top + 74);
        if (gaps[0].asyncWaiters > 0) {
          ctx.fillStyle = '#7ec8e3';
          ctx.fillText(`  ${gaps[0].asyncWaiters} ops waiting`, width - 190, padding.top + 88);
        }
      }
    }

    // ==================== REPLAY VIEW ====================
    function renderReplay() {
      // Stop any existing animation
      if (replayAnimationId) {
        cancelAnimationFrame(replayAnimationId);
        replayAnimationId = null;
      }
      replayPlaying = false;
      replayTime = 0;
      renderReplayFrame();
    }

    function startReplayAnimation() {
      if (!traceData || replayPlaying) return;
      replayPlaying = true;
      let lastFrameTime = performance.now();

      function animate(now) {
        if (!replayPlaying || currentView !== 'replay') {
          replayPlaying = false;
          return;
        }

        const delta = (now - lastFrameTime) * replaySpeed;
        lastFrameTime = now;

        // Convert real-time delta to trace time (speed up playback)
        const traceTimePerMs = traceData.requestDurationNs / 3000;  // 3 second playback
        replayTime += delta * traceTimePerMs;

        if (replayTime >= traceData.requestDurationNs) {
          replayTime = traceData.requestDurationNs;
          replayPlaying = false;
        }

        renderReplayFrame();

        if (replayPlaying) {
          replayAnimationId = requestAnimationFrame(animate);
        }
      }

      replayAnimationId = requestAnimationFrame(animate);
    }

    function stopReplayAnimation() {
      replayPlaying = false;
      if (replayAnimationId) {
        cancelAnimationFrame(replayAnimationId);
        replayAnimationId = null;
      }
    }

    function renderReplayFrame() {
      const container = document.getElementById('replay-view');
      const canvas = document.getElementById('replay-canvas');
      const ctx = canvas.getContext('2d');

      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;

      const width = canvas.width;
      const height = canvas.height;
      const padding = { top: 80, right: 30, bottom: 50, left: 30 };
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;

      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, width, height);

      if (!traceData) return;

      const duration = traceData.requestDurationNs;
      const currentTimeMs = replayTime / 1e6;
      const durationMs = duration / 1e6;
      const progress = replayTime / duration;

      // Draw title
      ctx.fillStyle = '#e94560';
      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Request Replay - Watch Async Operations Unfold', width / 2, 25);

      // Draw playback controls area
      const controlsY = 45;
      ctx.fillStyle = '#888';
      ctx.font = '11px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(`Time: ${currentTimeMs.toFixed(2)}ms / ${durationMs.toFixed(2)}ms`, width / 2, controlsY);

      // Draw control buttons
      const btnY = controlsY + 8;
      const btnWidth = 60;
      const btnHeight = 22;
      const btnSpacing = 10;
      const totalBtnWidth = btnWidth * 4 + btnSpacing * 3;
      let btnX = (width - totalBtnWidth) / 2;

      // Play/Pause button
      ctx.fillStyle = replayPlaying ? '#ff6432' : '#50c878';
      ctx.fillRect(btnX, btnY, btnWidth, btnHeight);
      ctx.fillStyle = 'white';
      ctx.font = 'bold 10px sans-serif';
      ctx.fillText(replayPlaying ? '‚è∏ Pause' : '‚ñ∂ Play', btnX + btnWidth/2, btnY + 15);
      btnX += btnWidth + btnSpacing;

      // Reset button
      ctx.fillStyle = '#0f3460';
      ctx.strokeStyle = '#e94560';
      ctx.lineWidth = 1;
      ctx.fillRect(btnX, btnY, btnWidth, btnHeight);
      ctx.strokeRect(btnX, btnY, btnWidth, btnHeight);
      ctx.fillStyle = '#e94560';
      ctx.fillText('‚èÆ Reset', btnX + btnWidth/2, btnY + 15);
      btnX += btnWidth + btnSpacing;

      // Speed buttons
      const speeds = [0.5, 1, 2];
      speeds.forEach(speed => {
        ctx.fillStyle = replaySpeed === speed ? '#e94560' : '#0f3460';
        ctx.fillRect(btnX, btnY, 40, btnHeight);
        ctx.strokeStyle = '#e94560';
        ctx.strokeRect(btnX, btnY, 40, btnHeight);
        ctx.fillStyle = replaySpeed === speed ? 'white' : '#e94560';
        ctx.fillText(`${speed}x`, btnX + 20, btnY + 15);
        btnX += 40 + 5;
      });

      // Progress bar
      const progressY = btnY + btnHeight + 10;
      ctx.fillStyle = '#0f3460';
      ctx.fillRect(padding.left, progressY, chartWidth, 8);
      ctx.fillStyle = '#e94560';
      ctx.fillRect(padding.left, progressY, chartWidth * progress, 8);

      // Playhead
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(padding.left + chartWidth * progress, progressY + 4, 6, 0, Math.PI * 2);
      ctx.fill();

      // Draw resources that exist at current time
      const visibleResources = traceData.resources.filter(r => r.createdAt <= replayTime);
      const activeResources = visibleResources.filter(r => {
        const endTime = r.callbackEndedAt > 0 ? r.callbackEndedAt :
                       (r.destroyedAt > 0 ? r.destroyedAt : duration);
        return endTime >= replayTime;
      });

      // Layout resources in a grid
      const resourceAreaTop = progressY + 25;
      const resourceAreaHeight = height - resourceAreaTop - padding.bottom;
      const maxCols = Math.floor(chartWidth / 100);
      const maxRows = Math.floor(resourceAreaHeight / 80);
      const cellWidth = chartWidth / Math.max(maxCols, 1);
      const cellHeight = resourceAreaHeight / Math.max(maxRows, 1);

      // Sort by creation time for stable layout
      const sortedVisible = [...visibleResources].sort((a, b) => a.createdAt - b.createdAt);

      // Build position map for dependency lines
      const positionMap = new Map();
      sortedVisible.forEach((r, idx) => {
        if (idx >= maxCols * maxRows) return;
        const col = idx % maxCols;
        const row = Math.floor(idx / maxCols);
        const x = padding.left + col * cellWidth + cellWidth / 2;
        const y = resourceAreaTop + row * cellHeight + cellHeight / 2;
        positionMap.set(r.asyncId, { x, y, resource: r });
      });

      // Calculate waiting counts - how many resources are waiting on each resource
      // A resource is "waiting on" another if it's created, callback not started, and is a descendant
      const waitingOnCount = new Map();
      visibleResources.forEach(r => {
        const isWaiting = r.createdAt <= replayTime &&
                         (r.callbackStartedAt === 0 || r.callbackStartedAt > replayTime);
        if (isWaiting && r.triggerId !== 0) {
          // Walk up the trigger chain and increment counts
          let currentId = r.triggerId;
          const visited = new Set();
          while (currentId !== 0 && !visited.has(currentId)) {
            visited.add(currentId);
            waitingOnCount.set(currentId, (waitingOnCount.get(currentId) || 0) + 1);
            const parent = traceData.resourceMap.get(currentId);
            currentId = parent ? parent.triggerId : 0;
          }
        }
      });

      // Draw dependency lines first (behind circles)
      ctx.lineWidth = 1.5;
      sortedVisible.forEach((r, idx) => {
        if (idx >= maxCols * maxRows) return;
        const childPos = positionMap.get(r.asyncId);
        const parentPos = positionMap.get(r.triggerId);
        if (!childPos || !parentPos || r.triggerId === 0) return;

        const endTime = r.callbackEndedAt > 0 ? r.callbackEndedAt :
                       (r.destroyedAt > 0 ? r.destroyedAt : duration);
        const isActive = endTime >= replayTime;
        const parentEndTime = parentPos.resource.callbackEndedAt > 0 ? parentPos.resource.callbackEndedAt :
                             (parentPos.resource.destroyedAt > 0 ? parentPos.resource.destroyedAt : duration);
        const parentActive = parentEndTime >= replayTime;

        // Draw line from parent to child
        const dx = childPos.x - parentPos.x;
        const dy = childPos.y - parentPos.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 1) return;

        const radius = 28;
        const startX = parentPos.x + (dx / dist) * radius;
        const startY = parentPos.y + (dy / dist) * radius;
        const endX = childPos.x - (dx / dist) * radius;
        const endY = childPos.y - (dy / dist) * radius;

        // Color and style based on state
        const parentColor = TYPE_COLORS[parentPos.resource.type] || '#808080';
        if (isActive && parentActive) {
          ctx.strokeStyle = parentColor;
          ctx.globalAlpha = 0.6;
        } else {
          ctx.strokeStyle = '#444';
          ctx.globalAlpha = 0.3;
        }

        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();

        // Arrowhead
        const arrowSize = 6;
        const angle = Math.atan2(endY - startY, endX - startX);
        ctx.beginPath();
        ctx.moveTo(endX, endY);
        ctx.lineTo(endX - arrowSize * Math.cos(angle - 0.4), endY - arrowSize * Math.sin(angle - 0.4));
        ctx.lineTo(endX - arrowSize * Math.cos(angle + 0.4), endY - arrowSize * Math.sin(angle + 0.4));
        ctx.closePath();
        ctx.fillStyle = ctx.strokeStyle;
        ctx.fill();
        ctx.globalAlpha = 1;
      });

      // Draw resource circles
      const radius = 28;
      sortedVisible.forEach((r, idx) => {
        if (idx >= maxCols * maxRows) return;

        const pos = positionMap.get(r.asyncId);
        if (!pos) return;
        const { x, y } = pos;

        const endTime = r.callbackEndedAt > 0 ? r.callbackEndedAt :
                       (r.destroyedAt > 0 ? r.destroyedAt : duration);
        const isActive = endTime >= replayTime;
        const isExecuting = r.callbackStartedAt > 0 && r.callbackStartedAt <= replayTime &&
                           r.callbackEndedAt > 0 && r.callbackEndedAt >= replayTime;
        const isWaiting = r.createdAt <= replayTime &&
                         (r.callbackStartedAt === 0 || r.callbackStartedAt > replayTime);

        const color = TYPE_COLORS[r.type] || '#808080';

        // Pulse effect for newly created
        const age = replayTime - r.createdAt;
        const isNew = age < duration * 0.02;  // 2% of duration

        if (isNew && isActive) {
          ctx.beginPath();
          ctx.arc(x, y, radius + 12 * (1 - age / (duration * 0.02)), 0, Math.PI * 2);
          ctx.fillStyle = color;
          ctx.globalAlpha = 0.3 * (1 - age / (duration * 0.02));
          ctx.fill();
          ctx.globalAlpha = 1;
        }

        // Critical path highlight - draw first so it's behind the circle
        const isOnCriticalPath = showCriticalPath && criticalPathSet.has(r.asyncId);
        if (isOnCriticalPath && isActive) {
          ctx.beginPath();
          ctx.arc(x, y, radius + 6, 0, Math.PI * 2);
          ctx.strokeStyle = '#ff6432';
          ctx.lineWidth = 3;
          ctx.shadowColor = '#ff6432';
          ctx.shadowBlur = 15;
          ctx.stroke();
          ctx.shadowBlur = 0;
        }

        // Draw resource circle
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);

        if (!isActive) {
          // Completed - faded
          ctx.fillStyle = color;
          ctx.globalAlpha = 0.3;
          ctx.fill();
          ctx.globalAlpha = 1;
        } else if (isExecuting) {
          // Currently executing - bright with glow
          ctx.shadowColor = color;
          ctx.shadowBlur = 20;
          ctx.fillStyle = color;
          ctx.fill();
          ctx.shadowBlur = 0;

          // Spinning indicator
          const spinAngle = (replayTime / 1e6) * 10;
          ctx.strokeStyle = 'white';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(x, y, radius - 6, spinAngle, spinAngle + Math.PI);
          ctx.stroke();
        } else if (isWaiting) {
          // Waiting - pulsing outline
          ctx.fillStyle = color;
          ctx.globalAlpha = 0.5;
          ctx.fill();
          ctx.globalAlpha = 1;

          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.stroke();
          ctx.setLineDash([]);
        } else {
          ctx.fillStyle = color;
          ctx.globalAlpha = 0.7;
          ctx.fill();
          ctx.globalAlpha = 1;
        }

        // Label
        ctx.fillStyle = 'white';
        ctx.font = 'bold 10px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const label = r.type.replace('js-', '').substring(0, 6);
        ctx.fillText(label, x, y);

        // Waiting count badge
        const waitCount = waitingOnCount.get(r.asyncId) || 0;
        if (waitCount > 0 && isActive) {
          const badgeX = x + radius - 5;
          const badgeY = y - radius + 5;
          const badgeRadius = waitCount > 9 ? 10 : 8;

          // Badge background
          ctx.beginPath();
          ctx.arc(badgeX, badgeY, badgeRadius, 0, Math.PI * 2);
          ctx.fillStyle = '#ff6432';
          ctx.fill();
          ctx.strokeStyle = '#1a1a2e';
          ctx.lineWidth = 2;
          ctx.stroke();

          // Badge text
          ctx.fillStyle = 'white';
          ctx.font = 'bold 9px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(waitCount > 99 ? '99+' : waitCount.toString(), badgeX, badgeY);
        }

        // Critical path flame icon (shown for all critical path nodes, subtle when inactive)
        if (isOnCriticalPath) {
          const flameX = x - radius + 8;
          const flameY = y + radius - 8;
          ctx.font = isActive ? '14px sans-serif' : '12px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.globalAlpha = isActive ? 1.0 : 0.6;
          ctx.fillText('üî•', flameX, flameY);
          ctx.globalAlpha = 1;
        }

        // Unresolved promise indicator (shown when replay is complete or near end)
        const isUnresolved = r.type === 'js-promise' &&
                            r.createdAt > 0 &&
                            r.callbackStartedAt === 0 &&
                            r.destroyedAt === 0;
        if (isUnresolved && replayTime >= duration * 0.9) {
          // Draw a subtle "?" badge in the lower-right
          const badgeX = x + radius - 6;
          const badgeY = y + radius - 6;

          ctx.beginPath();
          ctx.arc(badgeX, badgeY, 8, 0, Math.PI * 2);
          ctx.fillStyle = '#9966cc';
          ctx.globalAlpha = 0.8;
          ctx.fill();
          ctx.globalAlpha = 1;
          ctx.strokeStyle = '#1a1a2e';
          ctx.lineWidth = 1.5;
          ctx.stroke();

          ctx.fillStyle = 'white';
          ctx.font = 'bold 10px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('?', badgeX, badgeY);

          // Also draw a dashed border around the node
          ctx.beginPath();
          ctx.arc(x, y, radius + 3, 0, Math.PI * 2);
          ctx.strokeStyle = '#9966cc';
          ctx.lineWidth = 2;
          ctx.setLineDash([4, 4]);
          ctx.globalAlpha = 0.6;
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.globalAlpha = 1;
        }
      });

      // Stats overlay
      ctx.fillStyle = 'rgba(22, 33, 62, 0.95)';
      ctx.fillRect(width - 160, resourceAreaTop, 150, 80);
      ctx.strokeStyle = '#0f3460';
      ctx.strokeRect(width - 160, resourceAreaTop, 150, 80);

      ctx.fillStyle = '#e94560';
      ctx.font = 'bold 11px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText('Live Stats', width - 150, resourceAreaTop + 15);

      ctx.font = '10px sans-serif';
      ctx.fillStyle = '#aaa';
      ctx.fillText(`Created: ${visibleResources.length}`, width - 150, resourceAreaTop + 32);
      ctx.fillText(`Active: ${activeResources.length}`, width - 150, resourceAreaTop + 46);

      const executing = activeResources.filter(r =>
        r.callbackStartedAt > 0 && r.callbackStartedAt <= replayTime &&
        r.callbackEndedAt > 0 && r.callbackEndedAt >= replayTime
      ).length;
      ctx.fillStyle = executing > 0 ? '#50c878' : '#888';
      ctx.fillText(`Executing: ${executing}`, width - 150, resourceAreaTop + 60);

      const waiting = activeResources.filter(r =>
        r.callbackStartedAt === 0 || r.callbackStartedAt > replayTime
      ).length;
      ctx.fillStyle = waiting > 0 ? '#ffd700' : '#888';
      ctx.fillText(`Waiting: ${waiting}`, width - 150, resourceAreaTop + 74);

      // Handle click events for controls
      canvas.onclick = (e) => {
        const rect = canvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;

        // Check play/pause button
        const playBtnX = (width - totalBtnWidth) / 2;
        if (clickX >= playBtnX && clickX <= playBtnX + btnWidth &&
            clickY >= btnY && clickY <= btnY + btnHeight) {
          if (replayPlaying) {
            stopReplayAnimation();
          } else {
            if (replayTime >= duration) replayTime = 0;
            startReplayAnimation();
          }
          renderReplayFrame();
          return;
        }

        // Check reset button
        const resetBtnX = playBtnX + btnWidth + btnSpacing;
        if (clickX >= resetBtnX && clickX <= resetBtnX + btnWidth &&
            clickY >= btnY && clickY <= btnY + btnHeight) {
          stopReplayAnimation();
          replayTime = 0;
          renderReplayFrame();
          return;
        }

        // Check speed buttons
        let speedBtnX = resetBtnX + btnWidth + btnSpacing;
        speeds.forEach(speed => {
          if (clickX >= speedBtnX && clickX <= speedBtnX + 40 &&
              clickY >= btnY && clickY <= btnY + btnHeight) {
            replaySpeed = speed;
            renderReplayFrame();
          }
          speedBtnX += 45;
        });

        // Check progress bar click
        if (clickY >= progressY && clickY <= progressY + 8 &&
            clickX >= padding.left && clickX <= padding.left + chartWidth) {
          const clickProgress = (clickX - padding.left) / chartWidth;
          replayTime = clickProgress * duration;
          renderReplayFrame();
        }
      };
    }

    // ==================== HEATMAP VIEW ====================
    function renderHeatmap() {
      const container = document.getElementById('heatmap-view');
      const canvas = document.getElementById('heatmap-canvas');
      const ctx = canvas.getContext('2d');

      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;

      const width = canvas.width;
      const height = canvas.height;
      const padding = { top: 60, right: 30, bottom: 60, left: 120 };
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;

      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, width, height);

      if (!traceData) return;

      // Get filtered resources
      const filterMode = document.getElementById('filter-mode').value;
      let resources = traceData.resources.filter(r => {
        if (filterMode === 'user') return r._classification === 'user' || r._classification === 'typed';
        if (filterMode === 'typed') return r._classification === 'typed';
        return true;
      });

      // Apply click-to-filter
      if (clickToFilterEnabled && clickFilterResourceId !== null) {
        resources = resources.filter(r => isResourceVisible(r.asyncId));
      }

      const duration = traceData.requestDurationNs;

      // Get unique resource types
      const types = Array.from(new Set(resources.map(r => r.type)));
      if (types.length === 0) {
        ctx.fillStyle = '#666';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('No resources to display', width / 2, height / 2);
        return;
      }

      // Sort types by total activity
      const typeActivity = new Map();
      types.forEach(t => typeActivity.set(t, 0));
      resources.forEach(r => {
        let time = 0;
        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          time += r.callbackEndedAt - r.callbackStartedAt;
        }
        typeActivity.set(r.type, typeActivity.get(r.type) + time);
      });
      types.sort((a, b) => typeActivity.get(b) - typeActivity.get(a));

      // Define time buckets
      const numBuckets = Math.min(80, Math.floor(chartWidth / 8));
      const bucketWidth = duration / numBuckets;
      const rowHeight = Math.min(30, chartHeight / types.length);

      // Build heatmap data: [type][bucket] = intensity
      const heatmapData = new Map();
      types.forEach(type => {
        heatmapData.set(type, new Array(numBuckets).fill(0));
      });

      // Fill heatmap with activity
      resources.forEach(r => {
        const typeData = heatmapData.get(r.type);
        if (!typeData) return;

        // Add activity during callback execution
        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          const startBucket = Math.floor(r.callbackStartedAt / bucketWidth);
          const endBucket = Math.floor(r.callbackEndedAt / bucketWidth);
          for (let b = Math.max(0, startBucket); b <= Math.min(numBuckets - 1, endBucket); b++) {
            typeData[b] += 1;
          }
        }
        // Also mark async waiting time (lighter)
        else if (r.createdAt > 0) {
          const startBucket = Math.floor(r.createdAt / bucketWidth);
          const endBucket = r.callbackStartedAt > 0
            ? Math.floor(r.callbackStartedAt / bucketWidth)
            : Math.floor((r.destroyedAt > 0 ? r.destroyedAt : duration) / bucketWidth);
          for (let b = Math.max(0, startBucket); b <= Math.min(numBuckets - 1, endBucket); b++) {
            typeData[b] += 0.3;  // Lower weight for waiting
          }
        }
      });

      // Find max intensity for normalization
      let maxIntensity = 0;
      heatmapData.forEach(typeData => {
        typeData.forEach(v => { if (v > maxIntensity) maxIntensity = v; });
      });
      if (maxIntensity === 0) maxIntensity = 1;

      // Draw title
      ctx.fillStyle = '#e94560';
      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Activity Heatmap (Time √ó Resource Type)', width / 2, 25);

      ctx.fillStyle = '#888';
      ctx.font = '11px sans-serif';
      ctx.fillText('Brighter = more activity in that time window', width / 2, 42);

      // Draw heatmap cells
      const cellWidth = chartWidth / numBuckets;
      types.forEach((type, typeIdx) => {
        const y = padding.top + typeIdx * rowHeight;
        const typeData = heatmapData.get(type);
        const baseColor = TYPE_COLORS[type] || '#808080';

        // Parse base color to RGB
        const hex = baseColor.replace('#', '');
        const r = parseInt(hex.substr(0, 2), 16);
        const g = parseInt(hex.substr(2, 2), 16);
        const b = parseInt(hex.substr(4, 2), 16);

        typeData.forEach((intensity, bucket) => {
          const x = padding.left + bucket * cellWidth;
          const normalizedIntensity = intensity / maxIntensity;

          // Interpolate from dark to color based on intensity
          const alpha = Math.min(1, normalizedIntensity * 1.5);
          ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha * 0.9})`;
          ctx.fillRect(x, y, cellWidth + 0.5, rowHeight - 1);

          // Add brighter highlight for high intensity
          if (normalizedIntensity > 0.7) {
            ctx.fillStyle = `rgba(255, 255, 255, ${(normalizedIntensity - 0.7) * 0.5})`;
            ctx.fillRect(x, y, cellWidth + 0.5, rowHeight - 1);
          }
        });

        // Type label
        ctx.fillStyle = TYPE_COLORS[type] || '#888';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        const label = type.replace('js-', '').replace('cache-', 'c:');
        ctx.fillText(label, padding.left - 8, y + rowHeight / 2);
      });

      // Draw time axis
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding.left, padding.top + types.length * rowHeight);
      ctx.lineTo(padding.left + chartWidth, padding.top + types.length * rowHeight);
      ctx.stroke();

      // Time labels
      ctx.fillStyle = '#888';
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      const numLabels = Math.min(10, numBuckets);
      for (let i = 0; i <= numLabels; i++) {
        const x = padding.left + (i / numLabels) * chartWidth;
        const time = (i / numLabels) * duration / 1e6;
        ctx.fillText(`${time.toFixed(1)}ms`, x, padding.top + types.length * rowHeight + 5);

        // Grid line
        if (i > 0 && i < numLabels) {
          ctx.strokeStyle = 'rgba(68, 68, 68, 0.3)';
          ctx.beginPath();
          ctx.moveTo(x, padding.top);
          ctx.lineTo(x, padding.top + types.length * rowHeight);
          ctx.stroke();
        }
      }

      // Legend
      const legendY = height - 30;
      ctx.fillStyle = '#888';
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText('Intensity:', padding.left, legendY);

      const gradientWidth = 100;
      const gradientX = padding.left + 60;
      for (let i = 0; i < gradientWidth; i++) {
        const intensity = i / gradientWidth;
        ctx.fillStyle = `rgba(233, 69, 96, ${intensity})`;
        ctx.fillRect(gradientX + i, legendY - 5, 1, 10);
      }
      ctx.fillStyle = '#888';
      ctx.fillText('Low', gradientX - 25, legendY);
      ctx.fillText('High', gradientX + gradientWidth + 5, legendY);
    }

    // ==================== SELECTION ====================
    function selectResource(r) {
      selectedResource = r;
      highlightedChain.clear();

      let current = r;
      while (current) {
        highlightedChain.add(current.asyncId);
        if (current.triggerId === 0) break;
        current = traceData.resourceMap.get(current.triggerId);
      }

      (traceData.childrenMap.get(r.asyncId) || []).forEach(id => highlightedChain.add(id));

      render();
      updateSelectedDetails();
    }

    function updateSelectedDetails() {
      const r = selectedResource;
      if (!r) return;

      document.getElementById('nav-parent').disabled = r.triggerId === 0;
      const children = traceData.childrenMap.get(r.asyncId) || [];
      document.getElementById('nav-children').disabled = children.length === 0;

      const endTime = r.callbackEndedAt > 0 ? r.callbackEndedAt : (r.destroyedAt > 0 ? r.destroyedAt : traceData.requestDurationNs);
      const totalDuration = endTime - r.createdAt;
      const asyncWait = r.callbackStartedAt > 0 ? r.callbackStartedAt - r.createdAt : 0;
      const syncTime = (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) ? r.callbackEndedAt - r.callbackStartedAt : 0;

      const classColors = { typed: '#50c878', user: '#7ec8e3', internal: '#888' };
      const classLabels = { typed: 'API call', user: 'User code', internal: 'Runtime' };

      document.getElementById('selected-details').innerHTML = `
        <div class="detail-item"><strong>ID:</strong> #${r.asyncId} ‚Üí #${r.triggerId || 'root'}</div>
        <div class="detail-item"><strong>Type:</strong> ${r.type} <span style="color: ${classColors[r._classification]}; font-size: 0.7rem;">(${classLabels[r._classification]})</span></div>
        <div class="detail-item"><strong>Created:</strong> ${(r.createdAt / 1e6).toFixed(3)}ms</div>
        ${r.callbackStartedAt > 0 ? `<div class="detail-item"><strong>Callback:</strong> ${(r.callbackStartedAt / 1e6).toFixed(3)} ‚Üí ${(r.callbackEndedAt / 1e6).toFixed(3)}ms</div>` : ''}
        ${children.length > 0 ? `<div class="detail-item"><strong>Children:</strong> ${children.length}</div>` : ''}
      `;

      const breakdownDiv = document.getElementById('timing-breakdown');
      if (asyncWait > 0 || syncTime > 0) {
        const total = asyncWait + syncTime;
        const asyncPct = total > 0 ? (asyncWait / total) * 100 : 0;
        const syncPct = total > 0 ? (syncTime / total) * 100 : 0;
        breakdownDiv.innerHTML = `
          <div class="timing-bar">
            ${asyncWait > 0 ? `<div class="segment" style="width: ${asyncPct}%; background: rgba(233,69,96,0.4);">‚è≥${(asyncWait/1e6).toFixed(1)}</div>` : ''}
            ${syncTime > 0 ? `<div class="segment" style="width: ${syncPct}%; background: ${TYPE_COLORS[r.type]};">‚ö°${(syncTime/1e6).toFixed(1)}</div>` : ''}
          </div>
          <div class="detail-item"><strong>Wait:</strong> ${(asyncWait / 1e6).toFixed(3)}ms (${asyncPct.toFixed(0)}%)</div>
          <div class="detail-item"><strong>Sync:</strong> ${(syncTime / 1e6).toFixed(3)}ms (${syncPct.toFixed(0)}%)</div>
        `;
      } else {
        breakdownDiv.innerHTML = `<div class="detail-item"><strong>Total:</strong> ${(totalDuration / 1e6).toFixed(3)}ms</div>`;
      }

      const st = traceData.stackTraceMap.get(r.stackTraceId);
      document.getElementById('stack-trace').innerHTML = (st && st.frames.length > 0) ?
        st.frames.map((f, i) => `<div class="stack-frame">${i === 0 ? '‚Üí ' : '  '}${f}</div>`).join('') :
        '<div class="stack-empty">No stack trace (internal runtime)</div>';

      const anns = traceData.annotationMap.get(r.asyncId);
      document.getElementById('annotations').innerHTML = (anns && anns.length > 0) ?
        anns.map(a => `<div class="detail-item"><strong>${a.key}:</strong> ${a.value}</div>`).join('') :
        '<div class="detail-item" style="color: #666;">-</div>';
    }

    function navigateToParent() {
      if (!selectedResource || selectedResource.triggerId === 0) return;
      const parent = traceData.resourceMap.get(selectedResource.triggerId);
      if (parent) selectResource(parent);
    }

    function navigateToChildren() {
      if (!selectedResource) return;
      const children = traceData.childrenMap.get(selectedResource.asyncId) || [];
      if (children.length > 0) {
        const child = traceData.resourceMap.get(children[0]);
        if (child) selectResource(child);
      }
    }

    function openAIAnalysis() {
      if (!traceData) {
        alert('Please load a trace first');
        return;
      }

      const prompt = generateAnalysisPrompt();
      document.getElementById('ai-prompt').value = prompt;

      // Generate Claude link (URL-encoded prompt)
      const claudeUrl = 'https://claude.ai/new?q=' + encodeURIComponent(prompt.substring(0, 8000));
      document.getElementById('ai-claude-link').href = claudeUrl;

      document.getElementById('ai-modal').style.display = 'flex';
    }

    function generateAnalysisPrompt() {
      const duration = traceData.requestDurationNs / 1e6;
      const resourceCount = traceData.resources.length;

      // Calculate timing stats
      let totalSync = 0, totalAsync = 0;
      traceData.resources.forEach(r => {
        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          totalSync += r.callbackEndedAt - r.callbackStartedAt;
        }
        if (r.callbackStartedAt > 0 && r.createdAt > 0) {
          totalAsync += r.callbackStartedAt - r.createdAt;
        }
      });

      // Count by type and classification
      const typeCounts = {};
      const classCounts = { typed: 0, user: 0, internal: 0 };
      traceData.resources.forEach(r => {
        typeCounts[r.type] = (typeCounts[r.type] || 0) + 1;
        classCounts[r._classification]++;
      });

      // Find critical path (longest chain)
      let maxDepth = 0;
      let deepestResource = null;
      traceData.resources.forEach(r => {
        const depth = traceData.depthMap.get(r.asyncId) || 0;
        if (depth > maxDepth) {
          maxDepth = depth;
          deepestResource = r;
        }
      });

      // Build critical path
      const criticalPath = [];
      let current = deepestResource;
      while (current) {
        criticalPath.unshift(current);
        if (current.triggerId === 0) break;
        current = traceData.resourceMap.get(current.triggerId);
      }

      // Find high-latency edges (>1ms)
      const highLatencyEdges = [];
      traceData.resources.forEach(r => {
        if (r.triggerId !== 0) {
          const parent = traceData.resourceMap.get(r.triggerId);
          if (parent) {
            const parentEnd = parent.callbackEndedAt > 0 ? parent.callbackEndedAt : parent.createdAt;
            const latency = (r.createdAt - parentEnd) / 1e6;
            if (latency > 1) {
              highLatencyEdges.push({
                from: parent,
                to: r,
                latencyMs: latency
              });
            }
          }
        }
      });
      highLatencyEdges.sort((a, b) => b.latencyMs - a.latencyMs);

      // Get annotations summary
      const annotationsSummary = [];
      const seenUrls = new Set();
      traceData.annotations.forEach(a => {
        if (a.key === 'url' && !seenUrls.has(a.value)) {
          seenUrls.add(a.value);
          annotationsSummary.push(`  - ${a.value}`);
        }
      });

      // Get unique stack traces with counts
      const stackCounts = {};
      traceData.resources.forEach(r => {
        const st = traceData.stackTraceMap.get(r.stackTraceId);
        if (st && st.frames.length > 0) {
          const key = st.frames[0];
          stackCounts[key] = (stackCounts[key] || 0) + 1;
        }
      });
      const topStacks = Object.entries(stackCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);

      // Generate the prompt
      let prompt = `Please analyze this Cloudflare Worker async trace and provide specific optimization recommendations.

## Trace Summary

- **Total Duration:** ${duration.toFixed(2)}ms
- **Resources:** ${resourceCount} total
  - Typed (API calls): ${classCounts.typed}
  - User code promises: ${classCounts.user}
  - Internal runtime: ${classCounts.internal}
- **Sync Time:** ${(totalSync / 1e6).toFixed(2)}ms (${((totalSync / (totalSync + totalAsync)) * 100 || 0).toFixed(0)}%)
- **Async Wait:** ${(totalAsync / 1e6).toFixed(2)}ms (${((totalAsync / (totalSync + totalAsync)) * 100 || 0).toFixed(0)}%)
- **Max Depth:** ${maxDepth} levels

## Resource Types

`;
      Object.entries(typeCounts)
        .sort((a, b) => b[1] - a[1])
        .forEach(([type, count]) => {
          prompt += `- ${type}: ${count}\n`;
        });

      prompt += `
## Critical Path (${criticalPath.length} resources, depth ${maxDepth})

`;
      criticalPath.forEach((r, i) => {
        const st = traceData.stackTraceMap.get(r.stackTraceId);
        const frame = st && st.frames.length > 0 ? st.frames[0] : '(no stack)';
        const latency = i > 0 ? ((r.createdAt - criticalPath[i-1].createdAt) / 1e6).toFixed(2) : '0.00';
        prompt += `${i + 1}. [${r.type}] ${frame} (+${latency}ms)\n`;
      });

      if (highLatencyEdges.length > 0) {
        prompt += `
## High Latency Edges (>1ms)

`;
        highLatencyEdges.slice(0, 10).forEach(edge => {
          const fromSt = traceData.stackTraceMap.get(edge.from.stackTraceId);
          const toSt = traceData.stackTraceMap.get(edge.to.stackTraceId);
          const fromFrame = fromSt && fromSt.frames.length > 0 ? fromSt.frames[0] : edge.from.type;
          const toFrame = toSt && toSt.frames.length > 0 ? toSt.frames[0] : edge.to.type;
          prompt += `- ${edge.latencyMs.toFixed(2)}ms: ${fromFrame} ‚Üí ${toFrame}\n`;
        });
      }

      if (annotationsSummary.length > 0) {
        prompt += `
## URLs/Endpoints Referenced

${annotationsSummary.slice(0, 15).join('\n')}
`;
      }

      if (topStacks.length > 0) {
        prompt += `
## Top Stack Locations (by frequency)

`;
        topStacks.forEach(([stack, count]) => {
          prompt += `- ${count}x: ${stack}\n`;
        });
      }

      // Add detected patterns (from pattern detection analysis)
      // We need to run pattern detection first
      const savedShowPatterns = showPatterns;
      showPatterns = true;
      detectPatterns();
      showPatterns = savedShowPatterns;

      if (detectedPatterns.length > 0) {
        prompt += `
## Detected Issues (by severity)

`;
        // Group patterns by severity
        const bySeverity = { high: [], medium: [], low: [] };
        detectedPatterns.forEach(p => {
          bySeverity[p.severity || 'medium'].push(p);
        });

        if (bySeverity.high.length > 0) {
          prompt += `### üî¥ High Severity (${bySeverity.high.length})\n`;
          bySeverity.high.forEach(p => {
            prompt += `- **[${p.type}]** ${p.message}\n`;
          });
          prompt += `\n`;
        }

        if (bySeverity.medium.length > 0) {
          prompt += `### üü° Medium Severity (${bySeverity.medium.length})\n`;
          bySeverity.medium.forEach(p => {
            prompt += `- **[${p.type}]** ${p.message}\n`;
          });
          prompt += `\n`;
        }

        if (bySeverity.low.length > 0) {
          prompt += `### üü¢ Low Severity (${bySeverity.low.length})\n`;
          bySeverity.low.forEach(p => {
            prompt += `- **[${p.type}]** ${p.message}\n`;
          });
          prompt += `\n`;
        }

        // Pattern type legend
        prompt += `**Pattern Types:**
- \`sequential-await\`: Fetches that could use Promise.all()
- \`duplicate-fetch\`: Same URL fetched multiple times
- \`waterfall-fetch\`: Fetches chained in sequence
- \`deep-chain\`: Deeply nested promise chains
- \`unresolved-promise\`: Promises never resolved
- \`long-async-gap\`: Operations waiting too long
- \`redundant-timers\`: Duplicate timers
- \`cache-miss\`: Slow cache operations (likely misses)
- \`sync-flood\`: Long sync execution blocking event loop
- \`promise-flood\`: Many promises created in short window
- \`callback-storm\`: Many callbacks firing simultaneously
- \`unbatched-ops\`: KV/DO operations that could be batched
- \`fetch-flood\`: Too many concurrent fetches
- \`hot-callback\`: Single callback spawning many children
`;
      }

      // Add stream operations summary
      const streamTypes = ['stream-read', 'stream-write', 'stream-pipe-to', 'stream-pipe-through'];
      const streamCounts = {};
      streamTypes.forEach(type => {
        const count = typeCounts[type] || 0;
        if (count > 0) streamCounts[type] = count;
      });

      if (Object.keys(streamCounts).length > 0) {
        prompt += `
## Stream Operations

`;
        Object.entries(streamCounts).forEach(([type, count]) => {
          prompt += `- ${type}: ${count}\n`;
        });
      }

      // Add KJ‚ÜîJS bridge analysis
      const kjToJsCount = typeCounts['kj-to-js'] || 0;
      const jsToKjCount = typeCounts['js-to-kj'] || 0;

      if (kjToJsCount > 0 || jsToKjCount > 0) {
        prompt += `
## KJ‚ÜîJS Bridge Transitions

`;
        if (kjToJsCount > 0) prompt += `- KJ‚ÜíJS transitions: ${kjToJsCount} (KJ promises resolving to JS)\n`;
        if (jsToKjCount > 0) prompt += `- JS‚ÜíKJ transitions: ${jsToKjCount} (JS promises awaiting KJ)\n`;
        prompt += `\nThese represent cross-boundary calls between the JavaScript runtime and the C++ I/O layer.\n`;
      }

      // Add temporal edges analysis
      const savedShowTemporalEdges = showTemporalEdges;
      showTemporalEdges = true;
      computeTemporalEdges();
      showTemporalEdges = savedShowTemporalEdges;

      if (temporalEdges.length > 0) {
        // Find resources that spawn many temporal children
        const temporalParents = {};
        temporalEdges.forEach(edge => {
          temporalParents[edge.from] = (temporalParents[edge.from] || 0) + 1;
        });

        const topTemporalParents = Object.entries(temporalParents)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 5);

        if (topTemporalParents.some(([_, count]) => count > 2)) {
          prompt += `
## Temporal Execution Patterns

`;
          prompt += `Found ${temporalEdges.length} timing-based relationships (callbacks starting during other callbacks).\n\n`;
          prompt += `Top spawning callbacks:\n`;
          topTemporalParents.forEach(([id, count]) => {
            if (count > 1) {
              const r = traceData.resourceMap.get(parseInt(id));
              if (r) {
                const st = traceData.stackTraceMap.get(r.stackTraceId);
                const frame = st && st.frames.length > 0 ? st.frames[0] : '(no stack)';
                prompt += `- [${r.type}] ${frame}: spawns ${count} callbacks\n`;
              }
            }
          });
        }
      }

      // Add bottleneck details
      const savedShowBottlenecks = showBottlenecks;
      showBottlenecks = true;
      detectBottlenecks();
      showBottlenecks = savedShowBottlenecks;

      if (detectedBottlenecks.length > 0) {
        prompt += `
## Top Bottlenecks (by time)

`;
        detectedBottlenecks.forEach((id, i) => {
          const r = traceData.resourceMap.get(id);
          if (r) {
            const st = traceData.stackTraceMap.get(r.stackTraceId);
            const frame = st && st.frames.length > 0 ? st.frames[0] : '(no stack)';
            let syncTime = 0, asyncWait = 0;
            if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
              syncTime = (r.callbackEndedAt - r.callbackStartedAt) / 1e6;
            }
            if (r.callbackStartedAt > 0 && r.createdAt > 0) {
              asyncWait = (r.callbackStartedAt - r.createdAt) / 1e6;
            }
            prompt += `${i + 1}. [${r.type}] ${frame}\n`;
            prompt += `   - Sync execution: ${syncTime.toFixed(2)}ms\n`;
            prompt += `   - Async wait: ${asyncWait.toFixed(2)}ms\n`;
          }
        });
      }

      prompt += `
## Analysis Request

Based on this trace data, please analyze starting with **high severity issues first**:

1. **Address high severity issues first** - Focus on patterns marked with üî¥. These have the biggest impact:
   - \`sync-flood\`: Event loop blockers preventing other callbacks from running
   - \`sequential-await\`: Opportunities to use Promise.all()
   - \`unbatched-ops\`: KV/DO operations that could use batch APIs

2. **Check for serialization issues** - Are there operations that could run in parallel but are running sequentially? Pay special attention to any detected sequential-await or waterfall patterns.

3. **Evaluate event loop health** - Is sync execution blocking the event loop? Are there operations that should be async but are running synchronously?

4. **Check for memory pressure risks** - Are there promise-flood or callback-storm patterns that could cause memory issues under load?

5. **Look for redundant operations** - Are there duplicate fetches or unnecessary API calls? Check the detected patterns section for duplicates.

6. **Assess fetch concurrency** - If fetch-flood is detected, could this hit connection limits? Consider request coalescing or batching.

7. **Analyze stream operations** - If streams are involved, are they being used efficiently? Are there opportunities to pipeline or parallelize stream processing?

8. **Review KJ‚ÜîJS transitions** - Are there excessive bridge transitions that could indicate inefficient async patterns?

9. **Provide specific code recommendations** - Give concrete code examples showing how to improve the most impactful issues. Prioritize high severity patterns.

10. **Estimate potential improvement** - If your recommendations are implemented, roughly how much latency reduction might be achieved?

Please be specific and actionable in your recommendations. Address issues in severity order (high ‚Üí medium ‚Üí low). Reference specific resource types, stack locations, and timing data from the trace.`;

      return prompt;
    }
  </script>
</body>
</html>
