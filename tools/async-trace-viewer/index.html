<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Async Trace Viewer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #eee;
      display: flex;
      flex-direction: column;
    }

    header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
      background: #16213e;
      padding: 0.75rem 1.5rem;
      border-bottom: 1px solid #0f3460;
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    h1 { font-size: 1.1rem; color: #e94560; }

    .view-select {
      margin-left: 1rem;
      padding: 0.4rem 0.8rem;
      background: #0f3460;
      color: #e94560;
      border: 1px solid #e94560;
      border-radius: 4px;
      font-size: 0.85rem;
      cursor: pointer;
      min-width: 120px;
    }

    .view-select:focus {
      outline: none;
      box-shadow: 0 0 0 2px rgba(233, 69, 96, 0.3);
    }

    .view-select option {
      background: #16213e;
      color: #eee;
    }

    .view-help {
      display: none;
    }

    .view-help.active {
      display: block;
    }

    .controls {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      margin-left: auto;
    }

    .controls input[type="file"] { display: none; }

    .controls button, .controls .file-label, .controls select {
      background: #0f3460;
      color: white;
      border: 1px solid #e94560;
      padding: 0.35rem 0.6rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.75rem;
    }

    .controls button:hover, .controls .file-label:hover { background: #e94560; }

    /* Analysis dropdown menu */
    .dropdown {
      position: relative;
      display: inline-block;
    }

    .dropdown-btn {
      background: #0f3460;
      color: white;
      border: 1px solid #e94560;
      padding: 0.35rem 0.6rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.75rem;
    }

    .dropdown-btn:hover, .dropdown-btn.active {
      background: #e94560;
    }

    .dropdown-content {
      display: none;
      position: absolute;
      top: 100%;
      right: 0;
      background: #16213e;
      border: 1px solid #0f3460;
      border-radius: 4px;
      min-width: 200px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      z-index: 1001;
      padding: 0.25rem 0;
    }

    .dropdown-content.show {
      display: block;
    }

    .dropdown-item {
      display: flex;
      align-items: center;
      padding: 0.5rem 0.75rem;
      cursor: pointer;
      font-size: 0.8rem;
      color: #ccc;
      gap: 0.5rem;
    }

    .dropdown-item:hover {
      background: rgba(233, 69, 96, 0.2);
    }

    .dropdown-item input[type="checkbox"] {
      width: 14px;
      height: 14px;
      accent-color: #e94560;
    }

    .dropdown-item .hotkey {
      margin-left: auto;
      background: #0f3460;
      padding: 0.1rem 0.35rem;
      border-radius: 3px;
      font-size: 0.65rem;
      color: #888;
    }

    .dropdown-divider {
      height: 1px;
      background: #0f3460;
      margin: 0.25rem 0;
    }

    .threshold-section {
      padding: 0.5rem;
    }

    .threshold-header {
      font-size: 0.7rem;
      font-weight: bold;
      color: #e94560;
      margin-bottom: 0.4rem;
      text-transform: uppercase;
    }

    .threshold-item {
      display: flex;
      align-items: center;
      gap: 0.3rem;
      font-size: 0.7rem;
      color: #aaa;
      margin-bottom: 0.3rem;
    }

    .threshold-item span:first-child {
      flex: 0 0 90px;
    }

    .threshold-item input[type="range"] {
      flex: 1;
      height: 4px;
      -webkit-appearance: none;
      background: #0f3460;
      border-radius: 2px;
      cursor: pointer;
    }

    .threshold-item input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 12px;
      height: 12px;
      background: #e94560;
      border-radius: 50%;
      cursor: pointer;
    }

    .threshold-item span:last-child {
      flex: 0 0 40px;
      text-align: right;
      color: #7ec8e3;
    }

    .main-container {
      display: flex;
      flex: 1;
      overflow: hidden;
      margin-top: 52px; /* Account for fixed header */
      height: calc(100vh - 52px);
    }

    .view-container {
      flex: 1 1 0;
      overflow: auto;
      padding: 1rem;
      display: none;
      min-height: 0; /* Allow flex shrinking */
    }

    .view-container.active { display: block; }
    #waterfall-view.active { display: flex; flex-direction: column; }
    #breakdown-view.active { display: flex; flex-direction: column; }
    #latency-view.active { display: flex; flex-direction: column; }
    #gaps-view.active { display: flex; flex-direction: column; }
    #heatmap-view.active { display: flex; flex-direction: column; }

    /* Waterfall styles */
    .waterfall { position: relative; min-height: 100%; }

    .time-axis {
      position: sticky;
      top: 0;
      background: #1a1a2e;
      z-index: 100;
      height: 28px;
      border-bottom: 1px solid #333;
      margin-bottom: 4px;
    }

    .time-tick {
      position: absolute;
      font-size: 9px;
      color: #666;
      transform: translateX(-50%);
    }

    .time-tick::after {
      content: '';
      position: absolute;
      left: 50%;
      top: 14px;
      width: 1px;
      height: 6px;
      background: #444;
    }

    /* Type filter dropdown */
    #type-filter-dropdown .dropdown-content {
      right: auto;
      left: 0;
    }

    .type-filter-item {
      display: flex;
      align-items: center;
      padding: 0.4rem 0.75rem;
      cursor: pointer;
      font-size: 0.8rem;
      color: #ccc;
      gap: 0.5rem;
    }

    .type-filter-item:hover {
      background: rgba(233, 69, 96, 0.2);
    }

    .type-filter-item input[type="checkbox"] {
      width: 14px;
      height: 14px;
      accent-color: #e94560;
    }

    .type-filter-item .type-color {
      width: 12px;
      height: 12px;
      border-radius: 2px;
      flex-shrink: 0;
    }

    .type-filter-item .type-count {
      margin-left: auto;
      color: #666;
      font-size: 0.7rem;
    }

    /* Stack trace expansion */
    .resource-row-wrapper {
      margin: 1px 0;
    }

    .resource-row {
      display: flex;
      align-items: center;
      height: 22px;
    }

    .stack-trace-expand {
      width: 14px;
      height: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: #666;
      font-size: 10px;
      flex-shrink: 0;
      margin-right: 2px;
      border-radius: 2px;
    }

    .stack-trace-expand:hover {
      background: rgba(233, 69, 96, 0.3);
      color: #e94560;
    }

    .stack-trace-expand.expanded {
      color: #e94560;
    }

    .stack-trace-expand.no-stack {
      visibility: hidden;
    }

    .stack-trace-panel {
      display: none;
      margin-left: 180px;
      padding: 6px 10px;
      background: rgba(0, 0, 0, 0.3);
      border-left: 2px solid #e94560;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 11px;
      color: #aaa;
    }

    .stack-trace-panel.show {
      display: block;
    }

    .stack-trace-panel .stack-frame {
      padding: 2px 0;
      white-space: nowrap;
    }

    .stack-trace-panel .stack-frame:hover {
      color: #fff;
      background: rgba(233, 69, 96, 0.1);
    }

    .stack-trace-panel .stack-function {
      color: #7ec8e3;
    }

    .stack-trace-panel .stack-location {
      color: #888;
    }

    .stack-trace-panel .no-stack-msg {
      color: #666;
      font-style: italic;
    }

    .resource-row:hover { background: rgba(233, 69, 96, 0.1); }
    .resource-row.selected { background: rgba(233, 69, 96, 0.2); }
    .resource-row.highlighted { background: rgba(126, 200, 227, 0.15); }
    .resource-row.hover-self { background: rgba(255, 255, 100, 0.25); }
    .resource-row.hover-parent { background: rgba(100, 200, 255, 0.25); border-left: 3px solid #64c8ff; }
    .resource-row.hover-child { background: rgba(100, 255, 150, 0.2); border-left: 3px solid #64ff96; }
    .resource-row.time-cursor-active { background: rgba(255, 107, 107, 0.2); }
    .resource-row.critical-path {
      background: rgba(255, 100, 50, 0.25);
      border-left: 3px solid #ff6432;
    }
    .resource-row.critical-path .resource-bar {
      box-shadow: 0 0 8px rgba(255, 100, 50, 0.6);
    }
    .resource-row.internal { opacity: 0.4; }
    .resource-row.internal:hover { opacity: 0.7; }
    .resource-row.bottleneck {
      background: rgba(255, 200, 50, 0.25);
      border-left: 3px solid #ffc832;
    }
    .resource-row.bottleneck .resource-bar {
      box-shadow: 0 0 8px rgba(255, 200, 50, 0.6);
    }
    .resource-row.pattern-match {
      background: rgba(200, 100, 255, 0.25);
      border-left: 3px solid #c864ff;
    }
    .resource-row.pattern-match .resource-bar {
      box-shadow: 0 0 8px rgba(200, 100, 255, 0.6);
    }
    /* Severity-based pattern highlighting */
    .resource-row.pattern-high {
      background: rgba(255, 0, 255, 0.3);
      border-left: 4px solid #ff00ff;
    }
    .resource-row.pattern-high .resource-bar {
      box-shadow: 0 0 12px rgba(255, 0, 255, 0.8);
    }
    .resource-row.pattern-medium {
      background: rgba(204, 102, 255, 0.25);
      border-left: 3px solid #cc66ff;
    }
    .resource-row.pattern-medium .resource-bar {
      box-shadow: 0 0 8px rgba(204, 102, 255, 0.6);
    }
    .resource-row.pattern-low {
      background: rgba(153, 102, 204, 0.15);
      border-left: 2px solid #9966cc;
    }
    .resource-row.pattern-low .resource-bar {
      box-shadow: 0 0 5px rgba(153, 102, 204, 0.4);
    }

    #critical-path-btn.active {
      background: #ff6432 !important;
      border-color: #ff6432 !important;
    }

    .resource-label {
      width: 180px;
      min-width: 180px;
      padding-right: 8px;
      font-size: 10px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display: flex;
      align-items: center;
      gap: 3px;
    }

    .resource-label .indent {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-left: 1px solid #444;
      border-bottom: 1px solid #444;
    }

    .type-badge {
      padding: 1px 3px;
      border-radius: 2px;
      font-size: 8px;
      font-weight: bold;
    }

    .resource-timeline {
      flex: 1;
      position: relative;
      height: 100%;
    }

    .resource-bar {
      position: absolute;
      height: 14px;
      top: 4px;
      border-radius: 2px;
      cursor: pointer;
      display: flex;
      align-items: center;
      font-size: 8px;
      color: white;
      overflow: hidden;
    }

    .resource-bar .async-wait {
      height: 100%;
      opacity: 0.5;
    }

    .resource-bar .sync-time { height: 100%; }

    /* Accessibility mode styles */
    body.accessibility-mode .resource-bar .async-wait {
      opacity: 0.6;
      background-image: repeating-linear-gradient(
        45deg,
        transparent,
        transparent 3px,
        rgba(255,255,255,0.3) 3px,
        rgba(255,255,255,0.3) 6px
      ) !important;
    }

    body.accessibility-mode .resource-bar .sync-time {
      border: 2px solid rgba(255,255,255,0.5);
      box-sizing: border-box;
    }

    .resource-bar .bar-label {
      position: absolute;
      left: 3px;
      z-index: 1;
      text-shadow: 0 0 2px rgba(0,0,0,0.9);
    }

    /* Bubble view styles */
    #bubble-canvas, #parallelism-canvas, #dag-canvas, #breakdown-canvas, #latency-canvas, #gaps-canvas, #replay-canvas, #heatmap-canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* DAG view controls */
    .dag-controls {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
    }

    .dag-layout-toggle {
      display: flex;
      background: rgba(22, 33, 62, 0.9);
      border-radius: 4px;
      overflow: hidden;
      border: 1px solid #0f3460;
    }

    .dag-layout-btn {
      padding: 6px 12px;
      background: transparent;
      border: none;
      color: #888;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .dag-layout-btn:hover {
      color: #ccc;
      background: rgba(233, 69, 96, 0.2);
    }

    .dag-layout-btn.active {
      background: #e94560;
      color: white;
    }

    .tooltip {
      position: fixed;
      background: rgba(22, 33, 62, 0.95);
      border: 1px solid #e94560;
      border-radius: 4px;
      padding: 0.5rem;
      font-size: 0.75rem;
      pointer-events: none;
      z-index: 1000;
      max-width: 280px;
    }

    .tooltip-title {
      font-weight: bold;
      color: #e94560;
      margin-bottom: 0.3rem;
    }

    /* Sidebar styles */
    .sidebar {
      width: 300px;
      flex-shrink: 0;
      background: #16213e;
      border-left: 1px solid #0f3460;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 0.75rem;
      font-size: 0.8rem;
      height: 100%;
      min-height: 0; /* Allow flex shrinking for proper scroll */
    }

    .sidebar h2 { font-size: 0.9rem; margin-bottom: 0.5rem; color: #e94560; }

    .sidebar-section {
      margin-bottom: 0.5rem;
      border-bottom: 1px solid #0f3460;
      padding-bottom: 0.5rem;
    }

    .sidebar-section:last-child {
      border-bottom: none;
    }

    .sidebar-section h3 {
      font-size: 0.8rem;
      margin: 0.4rem 0;
      color: #aaa;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      user-select: none;
    }

    .sidebar-section h3:hover {
      color: #e94560;
    }

    .sidebar-section h3::after {
      content: '‚ñº';
      font-size: 0.6rem;
      transition: transform 0.2s;
    }

    .sidebar-section.collapsed h3::after {
      transform: rotate(-90deg);
    }

    .sidebar-section.collapsed .section-content {
      display: none;
    }

    .section-content {
      margin-top: 0.4rem;
    }

    .stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.4rem;
      margin-bottom: 0.75rem;
    }

    .stat-item {
      background: #0f3460;
      padding: 0.4rem;
      border-radius: 4px;
      text-align: center;
    }

    .stat-value { font-size: 1.1rem; color: #e94560; font-weight: bold; }
    .stat-label { font-size: 0.65rem; color: #aaa; }

    .detail-item {
      padding: 0.3rem 0.4rem;
      background: #0f3460;
      border-radius: 3px;
      margin-bottom: 0.3rem;
      font-size: 0.75rem;
    }

    .detail-item strong { color: #e94560; }

    .stack-trace-container {
      max-height: 150px;
      overflow-y: auto;
      background: #0a1628;
      border-radius: 4px;
      padding: 0.4rem;
    }

    .stack-frame {
      font-family: monospace;
      font-size: 0.7rem;
      color: #7ec8e3;
      padding: 0.2rem 0;
      border-bottom: 1px solid #1a1a2e;
      word-break: break-all;
    }

    .stack-frame:last-child {
      border-bottom: none;
    }

    .stack-empty {
      color: #666;
      font-style: italic;
      font-size: 0.7rem;
    }

    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      margin-bottom: 0.5rem;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      font-size: 0.65rem;
    }

    .legend-color {
      width: 10px;
      height: 10px;
      border-radius: 2px;
    }

    .chain-nav {
      display: flex;
      gap: 0.4rem;
      margin-bottom: 0.5rem;
    }

    .chain-nav button {
      flex: 1;
      padding: 0.3rem;
      background: #0f3460;
      border: 1px solid #e94560;
      color: white;
      border-radius: 3px;
      cursor: pointer;
      font-size: 0.7rem;
    }

    .chain-nav button:hover { background: #e94560; }
    .chain-nav button:disabled { opacity: 0.5; cursor: not-allowed; }

    .timing-bar {
      height: 18px;
      display: flex;
      border-radius: 3px;
      overflow: hidden;
      margin-bottom: 0.25rem;
    }

    .timing-bar .segment {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 8px;
      color: white;
    }

    .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #666;
    }

    .textarea-container {
      padding: 0.75rem;
      display: none;
      background: #16213e;
    }

    .textarea-container.show { display: block; }

    .textarea-container textarea {
      width: 100%;
      height: 120px;
      background: #0f3460;
      color: white;
      border: 1px solid #e94560;
      border-radius: 4px;
      padding: 0.5rem;
      font-family: monospace;
      font-size: 0.75rem;
    }

    /* Modal styles */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 2000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal-content {
      background: #16213e;
      border: 1px solid #e94560;
      border-radius: 8px;
      max-width: 800px;
      max-height: 85vh;
      width: 90%;
      display: flex;
      flex-direction: column;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      border-bottom: 1px solid #0f3460;
    }

    .modal-header h2 {
      margin: 0;
      font-size: 1.2rem;
      color: #e94560;
    }

    .modal-close {
      background: none;
      border: none;
      color: #888;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0;
      line-height: 1;
    }

    .modal-close:hover { color: #e94560; }

    .modal-body {
      padding: 1.5rem;
      overflow-y: auto;
      font-size: 0.85rem;
      line-height: 1.5;
    }

    .guide-section {
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid #0f3460;
    }

    .guide-section:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }

    .guide-section h3 {
      color: #7ec8e3;
      margin: 0 0 0.5rem 0;
      font-size: 1rem;
    }

    .guide-section p { margin: 0.4rem 0; }
    .guide-section ul, .guide-section ol {
      margin: 0.5rem 0;
      padding-left: 1.5rem;
    }
    .guide-section li { margin: 0.25rem 0; }
    .guide-section code {
      background: #0f3460;
      padding: 0.1rem 0.3rem;
      border-radius: 3px;
      font-size: 0.8rem;
    }

    .guide-example {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      margin: 0.75rem 0;
    }

    .guide-bad, .guide-good {
      padding: 0.5rem;
      border-radius: 4px;
      font-size: 0.8rem;
    }

    .guide-bad {
      background: rgba(233, 69, 96, 0.15);
      border: 1px solid rgba(233, 69, 96, 0.3);
    }

    .guide-good {
      background: rgba(80, 200, 120, 0.15);
      border: 1px solid rgba(80, 200, 120, 0.3);
    }

    .guide-bad pre, .guide-good pre {
      margin: 0.5rem 0 0 0;
      font-size: 0.75rem;
      white-space: pre-wrap;
      color: #ccc;
    }

    .guide-tip {
      background: rgba(255, 215, 0, 0.1);
      border-left: 3px solid #ffd700;
      padding: 0.4rem 0.6rem;
      margin: 0.5rem 0;
      font-size: 0.8rem;
    }

    .guide-table {
      width: 100%;
      border-collapse: collapse;
      margin: 0.5rem 0;
      font-size: 0.8rem;
    }

    .guide-table th, .guide-table td {
      padding: 0.4rem 0.6rem;
      text-align: left;
      border: 1px solid #0f3460;
    }

    .guide-table th {
      background: #0f3460;
      color: #7ec8e3;
    }

    .guide-table tr:nth-child(even) {
      background: rgba(15, 52, 96, 0.3);
    }

    @media (max-width: 600px) {
      .guide-example {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>üî¨ Async Trace Viewer</h1>
    <select id="view-select" class="view-select">
      <option value="waterfall">1: Waterfall</option>
      <option value="dag">2: Graph</option>
      <option value="replay">3: Replay</option>
      <option value="parallelism">4: Parallelism</option>
      <option value="breakdown">5: Breakdown</option>
      <option value="latency">6: Latency</option>
      <option value="gaps">7: Gaps</option>
      <option value="heatmap">8: Heatmap</option>
    </select>
    <div class="controls">
      <label class="file-label" for="file-input">üìÅ Load</label>
      <input type="file" id="file-input" accept=".json">
      <button id="paste-btn">üìã Paste</button>
      <select id="demo-select">
        <option value="">Demo...</option>
        <option value="timer">Timer</option>
        <option value="async-patterns">Async Patterns</option>
        <option value="chat-room">Chat Room</option>
        <option value="good-parallel">Good: Parallel Fetches</option>
        <option value="bad-sequential">Bad: Sequential Fetches</option>
        <option value="bad-duplicates">Bad: Duplicate Fetches</option>
        <option value="waterfall-fetches">Bad: Waterfall Fetches</option>
        <option value="unresolved-promises">Bad: Unresolved Promises</option>
        <option value="long-async-gaps">Bad: Long Async Gaps</option>
        <option value="redundant-timers">Bad: Redundant Timers</option>
        <option value="cache-misses">Bad: Cache Misses</option>
        <option value="streams-pipeline">Streams Pipeline</option>
        <option value="pathological">üíÄ Pathological Streams</option>
        <option value="nextjs-ssr">Next.js SSR (Product Page)</option>
        <option value="graphql-api">GraphQL API (User Dashboard)</option>
        <option value="api-gateway">API Gateway (Fan-out)</option>
        <option value="ecommerce-checkout">E-commerce Checkout</option>
        <option value="image-pipeline">Image Upload Pipeline</option>
        <option value="webhook-fanout">Webhook Fan-out</option>
        <option value="auth-flow">Authentication Flow</option>
        <option value="chat-message">Chat Message Send</option>
        <option disabled>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</option>
        <option value="antipattern-n-plus-one">üíÄ N+1 Query Problem</option>
        <option value="antipattern-waterfall">üíÄ Waterfall (Serial Fetches)</option>
        <option value="antipattern-promise-hell">üíÄ Promise Chain Hell</option>
        <option value="antipattern-await-loop">üíÄ Await in Loop</option>
        <option disabled>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</option>
        <option value="real-helloworld">Real: Hello World (ESM)</option>
        <option value="real-helloworld-sw">Real: Hello World (SW)</option>
        <option value="real-async-context">Real: Async Context</option>
        <option value="real-durable-objects">Real: Durable Objects</option>
        <option value="real-nodejs-compat-fs">Real: Node.js FS</option>
        <option value="real-nodejs-compat-streams">Real: Node.js Streams</option>
        <option value="real-tcp">Real: TCP Socket (Gopher)</option>
        <option value="real-eventsource">Real: EventSource (SSE)</option>
        <option value="real-nodejs-compat-http">Real: Node.js HTTP</option>
      </select>
      <div class="dropdown" id="analysis-dropdown">
        <button class="dropdown-btn" id="analysis-btn">üî¨ Analysis ‚ñæ</button>
        <div class="dropdown-content" id="analysis-menu">
          <label class="dropdown-item" id="critical-path-item">
            <input type="checkbox" id="critical-path-check"> üî• Critical Path <span class="hotkey">C</span>
          </label>
          <label class="dropdown-item" id="bottleneck-item">
            <input type="checkbox" id="bottleneck-check"> üê¢ Bottlenecks <span class="hotkey">B</span>
          </label>
          <label class="dropdown-item" id="pattern-item">
            <input type="checkbox" id="pattern-check"> üîç Patterns <span class="hotkey">T</span>
          </label>
          <label class="dropdown-item" id="click-filter-item">
            <input type="checkbox" id="click-filter-check"> üéØ Click Filter <span class="hotkey">F</span>
          </label>
          <label class="dropdown-item" id="stack-group-item">
            <input type="checkbox" id="stack-group-check"> üìö Stack Group <span class="hotkey">G</span>
          </label>
          <label class="dropdown-item" id="temporal-edges-item">
            <input type="checkbox" id="temporal-edges-check"> ‚è±Ô∏è Temporal Edges <span class="hotkey">E</span>
          </label>
          <label class="dropdown-item" id="hide-internal-item">
            <input type="checkbox" id="hide-internal-check"> üîí Hide Internal <span class="hotkey">H</span>
          </label>
          <div class="dropdown-divider"></div>
          <label class="dropdown-item" id="accessibility-item">
            <input type="checkbox" id="accessibility-check"> ‚ôø High Contrast <span class="hotkey">A</span>
          </label>
          <div class="dropdown-divider"></div>
          <div class="threshold-section">
            <div class="threshold-header">Pattern Thresholds</div>
            <div class="threshold-item">
              <span>Sync block:</span>
              <input type="range" id="threshold-sync" min="10" max="200" value="50">
              <span id="threshold-sync-val">50ms</span>
            </div>
            <div class="threshold-item">
              <span>Long gap:</span>
              <input type="range" id="threshold-gap" min="100" max="2000" step="50" value="500">
              <span id="threshold-gap-val">500ms</span>
            </div>
            <div class="threshold-item">
              <span>Promise flood:</span>
              <input type="range" id="threshold-promise" min="5" max="50" value="20">
              <span id="threshold-promise-val">20</span>
            </div>
            <div class="threshold-item">
              <span>Callback storm:</span>
              <input type="range" id="threshold-callback" min="3" max="30" value="10">
              <span id="threshold-callback-val">10</span>
            </div>
            <div class="threshold-item">
              <span>Unbatched ops:</span>
              <input type="range" id="threshold-unbatched" min="2" max="10" value="3">
              <span id="threshold-unbatched-val">3</span>
            </div>
            <div class="threshold-item">
              <span>Fetch concurrency:</span>
              <input type="range" id="threshold-fetch" min="3" max="20" value="6">
              <span id="threshold-fetch-val">6</span>
            </div>
            <button id="restore-thresholds-btn" style="margin-top: 0.5rem; width: 100%; padding: 0.3rem; font-size: 0.65rem; background: #333; border: 1px solid #555; color: #aaa; border-radius: 3px; cursor: pointer;">Restore Defaults</button>
          </div>
        </div>
      </div>
      <button id="tutorial-btn" style="background: #e94560;">‚ùì Guide</button>
      <button id="ai-analyze-btn" style="background: #50c878;">ü§ñ Analyze</button>
    </div>
  </header>

  <div class="textarea-container" id="paste-container">
    <textarea id="json-input" placeholder="Paste async trace JSON..."></textarea>
    <button id="load-json-btn" style="margin-top: 0.4rem;">Load</button>
  </div>

  <div class="main-container">
    <div class="view-container active" id="waterfall-view" style="overflow: hidden; padding: 0;">
      <div id="waterfall-controls" style="display: flex; gap: 12px; padding: 6px 10px; background: #16213e; border-bottom: 1px solid #0f3460; align-items: center; flex-shrink: 0; flex-wrap: wrap;">
        <label style="color: #aaa; font-size: 11px;">
          Sort:
          <select id="sort-mode" style="background: #0f3460; color: #e0e0e0; border: 1px solid #444; border-radius: 3px; padding: 2px 4px; font-size: 10px;">
            <option value="tree">Tree</option>
            <option value="creation">Time</option>
            <option value="duration">Duration</option>
          </select>
        </label>
        <div class="dropdown" id="type-filter-dropdown">
          <button class="dropdown-btn" id="type-filter-btn" style="font-size: 10px; padding: 2px 6px;">üè∑Ô∏è Types ‚ñæ</button>
          <div class="dropdown-content" id="type-filter-menu"></div>
        </div>
      </div>
      <div class="empty-state" id="waterfall-empty" style="flex: 1;">
        <div style="font-size: 2rem; margin-bottom: 0.5rem;">üìä</div>
        <div>Load a trace to visualize</div>
      </div>
      <div id="waterfall-container" style="display: none; position: relative; flex: 1; overflow: auto;">
        <div id="concurrency-graph" style="height: 50px; margin-left: 180px; margin-bottom: 4px; position: relative; background: rgba(0,0,0,0.3); border-radius: 4px;">
          <canvas id="concurrency-canvas" style="width: 100%; height: 100%;"></canvas>
          <div id="time-cursor" style="position: absolute; top: 0; bottom: 0; width: 2px; background: #ff6b6b; pointer-events: none; display: none; z-index: 20;">
            <div id="time-cursor-label" style="position: absolute; top: 50%; left: 8px; transform: translateY(-50%); font-size: 10px; color: #ff6b6b; white-space: nowrap; background: rgba(0,0,0,0.8); padding: 1px 4px; border-radius: 2px; z-index: 25;"></div>
          </div>
        </div>
        <div class="waterfall" id="waterfall" style="position: relative;"></div>
        <svg id="waterfall-arrows" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5;"></svg>
      </div>
    </div>

    <div class="view-container" id="dag-view" style="overflow: hidden; padding: 0; position: relative;">
      <canvas id="dag-canvas"></canvas>
      <div class="dag-controls">
        <div class="dag-layout-toggle">
          <button class="dag-layout-btn active" data-layout="bubble">Bubble</button>
          <button class="dag-layout-btn" data-layout="hierarchical">Hierarchical</button>
          <button class="dag-layout-btn" data-layout="force">Force</button>
        </div>
      </div>
    </div>

    <div class="view-container" id="parallelism-view" style="overflow: hidden; padding: 0;">
      <canvas id="parallelism-canvas"></canvas>
    </div>

    <div class="view-container" id="breakdown-view" style="overflow: hidden; padding: 0;">
      <div id="breakdown-controls" style="display: flex; gap: 10px; padding: 6px 10px; background: #16213e; border-bottom: 1px solid #0f3460; align-items: center; flex-shrink: 0;">
        <label style="color: #aaa; font-size: 11px;">Group by:</label>
        <select id="breakdown-group-select" style="font-size: 11px; padding: 2px 6px; background: #0f3460; color: #e0e0e0; border: 1px solid #1a1a2e; border-radius: 3px;">
          <option value="type">Type</option>
          <option value="classification">Classification</option>
          <option value="trigger">Trigger Chain</option>
          <option value="stack">Stack Location</option>
        </select>
        <label style="color: #aaa; font-size: 11px; margin-left: 10px;">View:</label>
        <select id="breakdown-viz-select" style="font-size: 11px; padding: 2px 6px; background: #0f3460; color: #e0e0e0; border: 1px solid #1a1a2e; border-radius: 3px;">
          <option value="treemap">Treemap</option>
          <option value="sunburst">Sunburst</option>
        </select>
        <div id="breakdown-breadcrumb" style="margin-left: 15px; color: #7ec8e3; font-size: 11px; cursor: pointer;"></div>
      </div>
      <canvas id="breakdown-canvas" style="flex: 1;"></canvas>
    </div>

    <div class="view-container" id="latency-view" style="overflow: hidden; padding: 0;">
      <div id="latency-controls" style="display: flex; gap: 10px; padding: 6px 10px; background: #16213e; border-bottom: 1px solid #0f3460; align-items: center; flex-shrink: 0;">
        <label style="color: #aaa; font-size: 11px;">View:</label>
        <select id="latency-mode-select" style="font-size: 11px; padding: 2px 6px; background: #0f3460; color: #e0e0e0; border: 1px solid #1a1a2e; border-radius: 3px;">
          <option value="histogram">Histogram</option>
          <option value="cdf">CDF (Cumulative)</option>
        </select>
        <label style="color: #aaa; font-size: 11px; margin-left: 10px;">
          <input type="checkbox" id="latency-outliers-checkbox" checked style="margin-right: 4px;">
          Highlight Outliers
        </label>
      </div>
      <canvas id="latency-canvas" style="flex: 1;"></canvas>
    </div>

    <div class="view-container" id="gaps-view" style="overflow: hidden; padding: 0;">
      <div id="gaps-controls" style="display: flex; gap: 12px; padding: 6px 10px; background: #16213e; border-bottom: 1px solid #0f3460; align-items: center; flex-shrink: 0; flex-wrap: wrap;">
        <label style="color: #aaa; font-size: 11px;">
          Min gap:
          <input type="range" id="gaps-threshold-slider" min="0.1" max="5" step="0.1" value="0.5" style="width: 80px; vertical-align: middle;">
          <span id="gaps-threshold-value" style="color: #e0e0e0;">0.5%</span>
        </label>
        <label style="color: #aaa; font-size: 11px;">
          <input type="checkbox" id="gaps-show-minor" style="margin-right: 4px;">
          Show minor gaps
        </label>
        <label style="color: #aaa; font-size: 11px;">
          <input type="checkbox" id="gaps-show-classification" checked style="margin-right: 4px;">
          Classify gaps
        </label>
        <label style="color: #aaa; font-size: 11px;">
          <input type="checkbox" id="gaps-show-recommendations" checked style="margin-right: 4px;">
          Show recommendations
        </label>
      </div>
      <canvas id="gaps-canvas" style="flex: 1;"></canvas>
    </div>

    <div class="view-container" id="replay-view" style="overflow: hidden; padding: 0;">
      <canvas id="replay-canvas"></canvas>
    </div>

    <div class="view-container" id="heatmap-view" style="overflow: hidden; padding: 0;">
      <div id="heatmap-controls" style="display: flex; gap: 12px; padding: 6px 10px; background: #16213e; border-bottom: 1px solid #0f3460; align-items: center; flex-shrink: 0; flex-wrap: wrap;">
        <label style="color: #aaa; font-size: 11px;">
          Buckets (‚Üê/‚Üí):
          <input type="range" id="heatmap-bucket-slider" min="10" max="120" step="10" value="40" style="width: 80px; vertical-align: middle;">
          <span id="heatmap-bucket-value" style="color: #e0e0e0; min-width: 24px; display: inline-block;">40</span>
        </label>
        <label style="color: #aaa; font-size: 11px;">
          Colors:
          <select id="heatmap-color-select" style="background: #0f3460; color: #e0e0e0; border: 1px solid #444; border-radius: 3px; padding: 2px 4px; font-size: 10px;">
            <option value="type">Per-type</option>
            <option value="heat">Heat gradient</option>
            <option value="mono">Monochrome</option>
          </select>
        </label>
        <label style="color: #aaa; font-size: 11px;">
          Activity:
          <select id="heatmap-activity-select" style="background: #0f3460; color: #e0e0e0; border: 1px solid #444; border-radius: 3px; padding: 2px 4px; font-size: 10px;">
            <option value="combined">Combined</option>
            <option value="sync">Sync only</option>
            <option value="async">Async only</option>
            <option value="count">Count</option>
          </select>
        </label>
        <label style="color: #aaa; font-size: 11px;">
          Sort:
          <select id="heatmap-sort-select" style="background: #0f3460; color: #e0e0e0; border: 1px solid #444; border-radius: 3px; padding: 2px 4px; font-size: 10px;">
            <option value="activity">By activity</option>
            <option value="alpha">Alphabetical</option>
            <option value="peak">By peak</option>
            <option value="first">By first occurrence</option>
          </select>
        </label>
      </div>
      <canvas id="heatmap-canvas" style="flex: 1;"></canvas>
    </div>

    <div class="sidebar">
      <div class="sidebar-section">
        <h3>Overview</h3>
        <div class="section-content">
          <div class="stats">
            <div class="stat-item">
              <div class="stat-value" id="stat-duration">-</div>
              <div class="stat-label">Duration (ms)</div>
            </div>
            <div class="stat-item">
              <div class="stat-value" id="stat-resources">-</div>
              <div class="stat-label">Resources</div>
            </div>
            <div class="stat-item">
              <div class="stat-value" id="stat-sync">-</div>
              <div class="stat-label">Sync (ms)</div>
            </div>
            <div class="stat-item">
              <div class="stat-value" id="stat-async">-</div>
              <div class="stat-label">Async (ms)</div>
            </div>
          </div>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Activity Timeline</h3>
        <div class="section-content">
          <canvas id="timeline-chart" height="40" style="width: 100%; background: #0f3460; border-radius: 4px;"></canvas>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Type Distribution</h3>
        <div class="section-content">
          <canvas id="type-chart" height="80" style="width: 100%; background: #0f3460; border-radius: 4px; margin-bottom: 0.5rem;"></canvas>
          <div id="type-breakdown" style="font-size: 0.7rem;"></div>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Time Breakdown</h3>
        <div class="section-content">
          <canvas id="time-chart" height="24" style="width: 100%; border-radius: 4px;"></canvas>
          <div id="time-breakdown" style="font-size: 0.7rem; margin-top: 0.25rem;"></div>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Runtime Overhead</h3>
        <div class="section-content">
          <canvas id="overhead-chart" height="24" style="width: 100%; border-radius: 4px;"></canvas>
          <div id="overhead-breakdown" style="font-size: 0.7rem; margin-top: 0.25rem;">
            <div style="color: #666;">Load a trace to analyze</div>
          </div>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Critical Path</h3>
        <div class="section-content">
          <div id="critical-path-info" style="font-size: 0.7rem;">
            <div class="detail-item" style="color: #666;">Click üî• to show</div>
          </div>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Analysis</h3>
        <div class="section-content">
          <div id="analysis-info" style="font-size: 0.7rem;">
            <div class="detail-item" style="color: #666;">Enable üê¢ or üîç toggles</div>
          </div>
          <div id="click-filter-status" style="display: none; margin-top: 0.5rem;">
            <div class="detail-item" style="color: #e94560;">
              <strong>üéØ Filtered to resource</strong>
              <button id="clear-filter-btn" style="margin-left: 0.5rem; padding: 2px 6px; font-size: 0.65rem;">Clear</button>
            </div>
          </div>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Legend</h3>
        <div class="section-content">
          <div class="legend" id="legend"></div>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Selected</h3>
        <div class="section-content">
          <div class="chain-nav">
            <button id="nav-parent" disabled>‚Üë Parent</button>
            <button id="nav-children" disabled>‚Üì Children</button>
          </div>
          <div id="selected-details">
            <div class="detail-item" style="color: #666;">Click a resource</div>
          </div>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Timing</h3>
        <div class="section-content">
          <div id="timing-breakdown">
            <div class="detail-item" style="color: #666;">Select a resource</div>
          </div>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Stack Trace</h3>
        <div class="section-content">
          <div id="stack-trace" class="stack-trace-container">
            <div class="stack-empty">Click a resource to see its stack</div>
          </div>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Annotations</h3>
        <div class="section-content">
          <div id="annotations">
            <div class="detail-item" style="color: #666;">-</div>
          </div>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>How to Read</h3>
        <div class="section-content">
          <div id="help-hints">
            <div class="view-help" data-view="waterfall">
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4;">
            <strong>Waterfall View:</strong><br>
            ‚Ä¢ Bars show resource lifetime<br>
            ‚Ä¢ Faded = async wait, Solid = sync<br>
            ‚Ä¢ Black markers = callback start/end<br>
            ‚Ä¢ ‚ñ∂ expands stack trace inline<br>
            ‚Ä¢ Hover row to highlight parent/children
          </div>
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4; margin-top: 0.3rem;">
            <strong>Concurrency Graph:</strong><br>
            ‚Ä¢ Graph above shows in-flight ops<br>
            ‚Ä¢ Hover graph for time cursor<br>
            ‚Ä¢ Shows active count at time point
          </div>
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4; margin-top: 0.3rem;">
            <strong>Controls:</strong><br>
            ‚Ä¢ Types dropdown filters by type<br>
            ‚Ä¢ Tree mode shows dependency arrows<br>
            ‚Ä¢ Click bar to select resource
          </div>
        </div>
        <div class="view-help" data-view="dag">
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4;">
            <strong>Graph View:</strong><br>
            ‚Ä¢ Dependency graph with arrows<br>
            ‚Ä¢ <span style="color: #50c878;">Green</span> = hover path highlight<br>
            ‚Ä¢ Hover shows ancestors + descendants<br>
            ‚Ä¢ Non-path nodes dim automatically
          </div>
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4; margin-top: 0.3rem;">
            <strong>Layout Toggle (‚Üê/‚Üí arrows):</strong><br>
            ‚Ä¢ Bubble = variable size by sync time<br>
            &nbsp;&nbsp;(shows latency labels on edges)<br>
            ‚Ä¢ Hierarchical = tree structure<br>
            ‚Ä¢ Force = physics simulation
          </div>
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4; margin-top: 0.3rem;">
            <strong>Controls:</strong><br>
            ‚Ä¢ Drag nodes to rearrange<br>
            ‚Ä¢ Shift+drag to pan, scroll to zoom<br>
            ‚Ä¢ Click node to select
          </div>
        </div>
        <div class="view-help" data-view="parallelism">
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4;">
            <strong>Parallelism View:</strong><br>
            ‚Ä¢ <span style="opacity: 0.9;">Solid</span> = executing, <span style="opacity: 0.4;">faded</span> = waiting<br>
            ‚Ä¢ <span style="color: #00e5ff;">Cyan dashed</span> = ideal parallelism<br>
            ‚Ä¢ <span style="color: #ff6600;">Orange line</span> = critical path (when enabled)<br>
            ‚Ä¢ Hover for details, click for breakdown
          </div>
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4; margin-top: 0.3rem;">
            <strong>Sidebar Metrics:</strong><br>
            ‚Ä¢ Utilization = actual vs ideal<br>
            ‚Ä¢ Efficiency = work done vs time spent<br>
            ‚Ä¢ Top bottlenecks = resources causing serialization
          </div>
        </div>
        <div class="view-help" data-view="breakdown">
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4;">
            <strong>Breakdown View:</strong><br>
            ‚Ä¢ Group by: Type, Classification, Trigger, Stack<br>
            ‚Ä¢ Treemap or Sunburst visualization<br>
            ‚Ä¢ ‚ñ∂ indicator = click to drill down<br>
            ‚Ä¢ Breadcrumb nav, Shift+R = reset drill-down
          </div>
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4; margin-top: 0.3rem;">
            <strong>Metrics:</strong><br>
            ‚Ä¢ üî• = on critical path (when enabled)<br>
            ‚Ä¢ ‚ö† = bottleneck (when enabled)<br>
            ‚Ä¢ Wall-clock = actual time contribution
          </div>
        </div>
        <div class="view-help" data-view="latency">
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4;">
            <strong>Latency View:</strong><br>
            ‚Ä¢ Histogram or CDF (toggle in controls)<br>
            ‚Ä¢ <span style="color: #50c878;">p50</span> / <span style="color: #ffd700;">p90</span> / <span style="color: #ff6347;">p99</span> percentile lines<br>
            ‚Ä¢ Hover bars for details, click for resources
          </div>
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4; margin-top: 0.3rem;">
            <strong>Highlights:</strong><br>
            ‚Ä¢ <span style="color: #ff6347;">Red border</span> = outliers (>3œÉ)<br>
            ‚Ä¢ <span style="color: #ff6600;">Orange dash</span> = critical path<br>
            ‚Ä¢ Sidebar shows stats & type breakdown
          </div>
        </div>
        <div class="view-help" data-view="gaps">
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4;">
            <strong>Gaps View:</strong><br>
            ‚Ä¢ <span style="color: #50c878;">Green</span> = sync execution<br>
            ‚Ä¢ Colored gaps = idle time by cause<br>
            ‚Ä¢ Hover for details, click for breakdown
          </div>
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4; margin-top: 0.3rem;">
            <strong>Gap Classification:</strong><br>
            ‚Ä¢ <span style="color: #e94560;">Red</span> = fetch wait<br>
            ‚Ä¢ <span style="color: #ffd700;">Gold</span> = timer delay<br>
            ‚Ä¢ <span style="color: #7ec8e3;">Blue</span> = storage I/O<br>
            ‚Ä¢ <span style="color: #9966cc;">Purple</span> = promise wait
          </div>
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4; margin-top: 0.3rem;">
            <strong>Controls & Highlights:</strong><br>
            ‚Ä¢ Threshold slider filters minor gaps<br>
            ‚Ä¢ <span style="color: #ff6600;">Orange dash</span> = critical path gap<br>
            ‚Ä¢ Sidebar shows top gaps + recommendations
          </div>
        </div>
        <div class="view-help" data-view="replay">
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4;">
            <strong>Replay View:</strong><br>
            ‚Ä¢ Watch request unfold in real-time<br>
            ‚Ä¢ ‚è≥ = waiting, ‚ö° = executing, ‚úì = done<br>
            ‚Ä¢ <span style="color: #50c878;">Green dots</span> on bar = creation events<br>
            ‚Ä¢ <span style="color: #e94560;">Red triangles</span> = callback starts
          </div>
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4; margin-top: 0.3rem;">
            <strong>Badges & Effects:</strong><br>
            ‚Ä¢ <span style="color: #ff6432;">Orange #</span> = ops waiting on this<br>
            ‚Ä¢ üî• = critical path node<br>
            ‚Ä¢ <span style="color: #9966cc;">Purple ?</span> = unresolved promise<br>
            ‚Ä¢ Fading rings = execution trails
          </div>
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4; margin-top: 0.3rem;">
            <strong>Toggle Buttons:</strong><br>
            ‚Ä¢ üîÅ Loop (Shift+L) = restart when done<br>
            ‚Ä¢ üëª Ghost (Shift+O) = pulse on changes<br>
            &nbsp;&nbsp;<span style="color:#50c878;">green</span>=new, <span style="color:#ffaa00;">orange</span>=exec, <span style="color:#e94560;">color</span>=end
          </div>
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4; margin-top: 0.3rem;">
            <strong>Controls:</strong><br>
            ‚Ä¢ Space = play/pause, R = reset<br>
            ‚Ä¢ ‚Üê/‚Üí step, Shift+‚Üê/‚Üí to events<br>
            ‚Ä¢ Ctrl+Shift+‚Üê/‚Üí critical path only<br>
            ‚Ä¢ -/+ speed (0.25x, 0.5x, 1x, 2x)
          </div>
        </div>
        <div class="view-help" data-view="heatmap">
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4;">
            <strong>Heatmap View:</strong><br>
            ‚Ä¢ Grid: rows=types, columns=time<br>
            ‚Ä¢ Hover for details, click for breakdown<br>
            ‚Ä¢ Controls: buckets, colors, activity, sort
          </div>
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4; margin-top: 0.3rem;">
            <strong>Activity Modes:</strong><br>
            ‚Ä¢ Combined = sync + async weighted<br>
            ‚Ä¢ Sync/Async = individual activity<br>
            ‚Ä¢ Count = resource count only
          </div>
          <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4; margin-top: 0.3rem;">
            <strong>Highlights:</strong><br>
            ‚Ä¢ <span style="color: #ff6600;">Orange row</span> = critical path type<br>
            ‚Ä¢ Hot spots = busy periods<br>
            ‚Ä¢ Diagonal = cascading ops
          </div>
        </div>
            <div class="view-help" data-view="all">
              <div class="detail-item" style="font-size: 0.7rem; line-height: 1.4; margin-top: 0.3rem;">
                <strong>Resource Types:</strong><br>
                ‚Ä¢ <span style="color: #50c878;">Typed</span> = API calls (fetch, timer, cache)<br>
                ‚Ä¢ <span style="color: #7ec8e3;">User</span> = Promises from your code<br>
                ‚Ä¢ <span style="color: #888;">Internal</span> = Runtime machinery
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="tooltip" class="tooltip" style="display: none;"></div>

  <!-- AI Analysis Modal -->
  <div id="ai-modal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 900px;">
      <div class="modal-header">
        <h2>ü§ñ AI Performance Analysis</h2>
        <button class="modal-close" id="ai-close">‚úï</button>
      </div>
      <div class="modal-body">
        <p style="margin-bottom: 1rem;">Copy the analysis prompt below and paste it into Claude, ChatGPT, or your preferred AI assistant:</p>

        <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
          <button id="ai-copy-btn" style="background: #0f3460; border: 1px solid #e94560; color: white; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer;">üìã Copy to Clipboard</button>
          <a id="ai-claude-link" href="#" target="_blank" style="background: #e94560; color: white; padding: 0.5rem 1rem; border-radius: 4px; text-decoration: none; display: inline-block;">Open in Claude ‚Üí</a>
        </div>

        <textarea id="ai-prompt" readonly style="width: 100%; height: 400px; background: #0a1628; color: #7ec8e3; border: 1px solid #0f3460; border-radius: 4px; padding: 1rem; font-family: monospace; font-size: 0.75rem; resize: vertical;"></textarea>

        <div id="ai-copy-status" style="margin-top: 0.5rem; color: #50c878; display: none;">‚úì Copied to clipboard!</div>
      </div>
    </div>
  </div>

  <!-- Tutorial Modal -->
  <div id="tutorial-modal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 900px;">
      <div class="modal-header">
        <h2>üî¨ Async Trace Optimization Guide</h2>
        <button class="modal-close" id="tutorial-close">‚úï</button>
      </div>
      <div class="modal-body">
        <div class="guide-section">
          <h3>Keyboard Shortcuts</h3>
          <table class="guide-table">
            <tr><th>Key</th><th>Action</th></tr>
            <tr><td colspan="2" style="font-weight:bold; background:#0f3460; color:#7ec8e3;">Navigation</td></tr>
            <tr><td><code>1</code>-<code>8</code></td><td>Switch views (Waterfall, Graph, Replay, Parallelism, Breakdown, Latency, Gaps, Heatmap)</td></tr>
            <tr><td><code>?</code></td><td>Show this help guide</td></tr>
            <tr><td><code>O</code> or <code>L</code></td><td>Open file dialog to load trace</td></tr>
            <tr><td><code>P</code> or <code>V</code></td><td>Toggle paste JSON area</td></tr>
            <tr><td><code>Esc</code></td><td>Close modals / dropdowns</td></tr>
            <tr><td colspan="2" style="font-weight:bold; background:#0f3460; color:#7ec8e3;">Analysis (via dropdown)</td></tr>
            <tr><td><code>C</code></td><td>Toggle critical path highlight</td></tr>
            <tr><td><code>B</code></td><td>Toggle bottleneck detection</td></tr>
            <tr><td><code>T</code></td><td>Toggle pattern detection</td></tr>
            <tr><td><code>F</code></td><td>Toggle click-to-filter mode</td></tr>
            <tr><td><code>G</code></td><td>Toggle stack trace grouping</td></tr>
            <tr><td><code>E</code></td><td>Toggle temporal edges</td></tr>
            <tr><td><code>H</code></td><td>Toggle hide internal resources</td></tr>
            <tr><td><code>A</code></td><td>Toggle high contrast / accessibility mode</td></tr>
            <tr><td colspan="2" style="font-weight:bold; background:#0f3460; color:#7ec8e3;">View-Specific</td></tr>
            <tr><td><code>‚Üê</code> / <code>‚Üí</code></td><td>Switch Graph layout: Bubble ‚Üí Hierarchical ‚Üí Force (Graph view only)</td></tr>
            <tr><td colspan="2" style="font-weight:bold; background:#0f3460; color:#7ec8e3;">Replay View Controls</td></tr>
            <tr><td><code>Space</code></td><td>Play/Pause animation</td></tr>
            <tr><td><code>R</code></td><td>Reset animation to start</td></tr>
            <tr><td><code>‚Üê</code> / <code>‚Üí</code></td><td>Step through timeline (1% increments)</td></tr>
            <tr><td><code>Shift+‚Üê</code> / <code>‚Üí</code></td><td>Jump to next/previous significant event</td></tr>
            <tr><td><code>Ctrl+Shift+‚Üê</code> / <code>‚Üí</code></td><td>Jump to next/previous critical path event</td></tr>
            <tr><td><code>-</code> / <code>+</code></td><td>Decrease/increase speed (0.25x, 0.5x, 1x, 2x)</td></tr>
            <tr><td><code>Shift+L</code></td><td>Toggle loop mode</td></tr>
            <tr><td><code>Shift+O</code></td><td>Toggle ghost mode (state change pulses)</td></tr>
            <tr><td colspan="2" style="font-weight:bold; background:#0f3460; color:#7ec8e3;">Other</td></tr>
            <tr><td><code>I</code></td><td>Open AI analysis prompt</td></tr>
            <tr><td><code>Shift+R</code></td><td>Refresh/reset current view</td></tr>
          </table>
        </div>

        <div class="guide-section">
          <h3>Visualization Views</h3>
          <table class="guide-table">
            <tr><th>View</th><th>Best For</th><th>What to Look For</th></tr>
            <tr><td><strong>1: Waterfall</strong></td><td>Timeline overview</td><td>Concurrency graph, stack traces (‚ñ∂), type filters, hover for parent/child</td></tr>
            <tr><td><strong>2: Graph</strong></td><td>Causality & dependencies</td><td>3 layouts (Bubble/Hierarchical/Force), path highlight on hover, ‚Üê/‚Üí to switch</td></tr>
            <tr><td><strong>3: Replay</strong></td><td>Understanding flow</td><td>Animated playback, lifecycle badges (‚è≥‚ö°‚úì), loop (Shift+L), ghost (Shift+O) for state pulses</td></tr>
            <tr><td><strong>4: Parallelism</strong></td><td>Concurrency level</td><td>Solid=executing, faded=waiting, cyan line=ideal, hover/click for details, sidebar efficiency metrics</td></tr>
            <tr><td><strong>5: Breakdown</strong></td><td>Time allocation</td><td>Treemap/Sunburst, group by Type/Class/Trigger/Stack, click to drill down, ‚ñ∂=can drill, Shift+R=reset</td></tr>
            <tr><td><strong>6: Latency</strong></td><td>Wait distribution</td><td>Histogram/CDF toggle, hover/click bars, outlier detection (red), critical path (orange)</td></tr>
            <tr><td><strong>7: Gaps</strong></td><td>Idle time analysis</td><td>Color-coded gaps by cause, hover/click for details, threshold slider, recommendations in sidebar</td></tr>
            <tr><td><strong>8: Heatmap</strong></td><td>Activity density</td><td>Hover/click cells, bucket/color/activity/sort controls, critical path rows highlighted</td></tr>
          </table>
        </div>

        <div class="guide-section">
          <h3>1. Identify Serialization Bottlenecks</h3>
          <p><strong>Views:</strong> Graph (2) with Bubble layout, Parallelism (4)</p>
          <p><strong>Pattern:</strong> Long vertical chains or parallelism = 1</p>
          <div class="guide-example">
            <div class="guide-bad">
              <strong>‚ùå Bad: Sequential</strong>
              <pre>const a = await fetch('/api/a');
const b = await fetch('/api/b');
const c = await fetch('/api/c');</pre>
            </div>
            <div class="guide-good">
              <strong>‚úì Good: Parallel</strong>
              <pre>const [a, b, c] = await Promise.all([
  fetch('/api/a'),
  fetch('/api/b'),
  fetch('/api/c')
]);</pre>
            </div>
          </div>
          <p class="guide-tip">üí° In Parallelism view, hover over any time bucket for details. The cyan dashed line shows ideal parallelism - compare to see utilization. Sidebar shows efficiency metrics and top bottlenecks.</p>
        </div>

        <div class="guide-section">
          <h3>2. Find Async Bottlenecks (Long Waits)</h3>
          <p><strong>Views:</strong> Graph (2) with Bubble layout, Latency (6)</p>
          <p><strong>Pattern:</strong> <span style="color: #ffd700;">Gold edge labels</span> (>1ms) or right-tail outliers in histogram</p>
          <p><strong>Questions to ask:</strong></p>
          <ul>
            <li>Can this fetch response be cached?</li>
            <li>Is this KV/D1/DO call necessary?</li>
            <li>Can non-critical work use <code>ctx.waitUntil()</code>?</li>
          </ul>
          <p class="guide-tip">üí° Enable outlier detection to highlight >3œÉ items. Click histogram bars to see individual resources.</p>
          <p style="margin-top: 0.5rem;"><strong>Reading the CDF (Cumulative Distribution):</strong></p>
          <ul>
            <li><strong>Y-axis</strong> = "% of operations completing within X time"</li>
            <li><strong>Steep curve</strong> = most operations have similar latency (good)</li>
            <li><strong>Long flat tail</strong> = some operations much slower (investigate)</li>
            <li><strong>p50 at 1ms, p99 at 100ms</strong> = high variance, find outliers</li>
            <li><strong>Orange line</strong> (when critical path on) = critical path latencies</li>
          </ul>
          <p class="guide-tip">üí° CDF is useful for SLO analysis: "What % of requests complete under 50ms?" Read the Y value at X=50ms.</p>
        </div>

        <div class="guide-section">
          <h3>3. Analyze CPU vs I/O Balance</h3>
          <p><strong>Views:</strong> Breakdown (5), sidebar Time Breakdown</p>
          <table class="guide-table">
            <tr><th>Ratio</th><th>Meaning</th><th>Action</th></tr>
            <tr><td>90% async (faded)</td><td>I/O bound (typical)</td><td>Optimize fetch/cache</td></tr>
            <tr><td>50/50</td><td>Mixed workload</td><td>Profile both paths</td></tr>
            <tr><td>90% sync (solid)</td><td>CPU bound</td><td>Optimize JS, use streams</td></tr>
          </table>
          <p class="guide-tip">üí° In Breakdown view, use different grouping modes to find hotspots. Click items with ‚ñ∂ to drill down into details. Toggle Sunburst for hierarchical view. Shift+R resets to top level.</p>
        </div>

        <div class="guide-section">
          <h3>4. Find Idle Gaps</h3>
          <p><strong>View:</strong> Gaps (7)</p>
          <p><strong>Pattern:</strong> <span style="color: #ff6432;">Orange sections</span> where no work is happening</p>
          <ul>
            <li><strong>Gaps with waiters</strong> = blocking operation, check what's pending</li>
            <li><strong>Large gaps</strong> = optimization opportunity</li>
            <li><strong>Many small gaps</strong> = fragmented execution, consider batching</li>
          </ul>
          <p class="guide-tip">üí° Hover over gaps to see which operations were waiting during that time.</p>
        </div>

        <div class="guide-section">
          <h3>5. Reduce Runtime Overhead</h3>
          <p><strong>Pattern:</strong> Many dimmed (internal) promises</p>
          <p>Use <strong>Hide Internal</strong> (H key or Analysis menu) to focus on your code.</p>
          <ul>
            <li>Deeply nested <code>.then()</code> chains create overhead</li>
            <li>Flatten with <code>async/await</code></li>
            <li>Reduce intermediate transformations</li>
          </ul>
        </div>

        <div class="guide-section">
          <h3>6. Find Redundant Operations</h3>
          <p><strong>Pattern:</strong> Multiple fetch/cache with same URL annotation</p>
          <div class="guide-example">
            <div class="guide-bad">
              <strong>‚ùå Duplicate fetches</strong>
              <pre>const userA = await fetch('/user/123');
// later...
const userB = await fetch('/user/123');</pre>
            </div>
            <div class="guide-good">
              <strong>‚úì Cache in variable</strong>
              <pre>const user = await fetch('/user/123');
// reuse `user` throughout</pre>
            </div>
          </div>
        </div>

        <div class="guide-section">
          <h3>7. Find Critical Path</h3>
          <p><strong>View:</strong> Waterfall (1) with üî• button, Graph (2)</p>
          <p>The critical path determines total request time.</p>
          <ol>
            <li>Click üî• in toolbar to highlight critical path</li>
            <li>Or: Find resource with latest <code>callbackEndedAt</code></li>
            <li>Navigate up to root using ‚Üë button</li>
            <li>Sum of edge latencies = minimum request time</li>
          </ol>
          <p class="guide-tip">üí° Only optimizing operations on the critical path improves overall latency.</p>
        </div>

        <div class="guide-section">
          <h3>8. Watch Request Flow</h3>
          <p><strong>View:</strong> Replay (3)</p>
          <p>Use replay to understand how your request executes:</p>
          <ul>
            <li><strong>Glowing circles</strong> = currently executing</li>
            <li><strong>Dashed outline</strong> = waiting for I/O</li>
            <li><strong>Faded circles</strong> = completed</li>
            <li><strong>Arrows</strong> = causality (parent triggered child)</li>
            <li><strong>‚Üê/‚Üí</strong> = step through timeline (1% increments)</li>
            <li><strong>Shift+‚Üê/‚Üí</strong> = jump to next/previous event</li>
          </ul>
          <p class="guide-tip">üí° Use Shift+arrows to step through events one at a time.</p>
        </div>

        <div class="guide-section">
          <h3>Visual Patterns Quick Reference</h3>
          <table class="guide-table">
            <tr><th>Visual Pattern</th><th>Where</th><th>Meaning</th><th>Fix</th></tr>
            <tr><td>Tall narrow tree</td><td>Bubble</td><td>Sequential ops</td><td>Promise.all</td></tr>
            <tr><td style="color: #ffd700;">Gold edges</td><td>Bubble</td><td>High latency</td><td>Cache/batch</td></tr>
            <tr><td style="color: #ff6432;">Orange bars</td><td>Parallelism</td><td>Serialization</td><td>Parallelize</td></tr>
            <tr><td style="color: #ff6432;">Orange gaps</td><td>Gaps</td><td>Idle time</td><td>Start work earlier</td></tr>
            <tr><td>Right tail</td><td>Latency</td><td>Outliers</td><td>Investigate slow ops</td></tr>
            <tr><td>Large solid boxes</td><td>Breakdown</td><td>CPU heavy</td><td>Optimize algorithm</td></tr>
            <tr><td>Large faded boxes</td><td>Breakdown</td><td>I/O heavy</td><td>Cache/parallelize</td></tr>
            <tr><td>Wide shallow tree</td><td>Bubble</td><td>Parallelism ‚úì</td><td>Already good</td></tr>
          </table>
        </div>

        <div class="guide-section">
          <h3>Accessibility Mode</h3>
          <p>Press <code>A</code> or click the <strong>‚ôø High Contrast</strong> button to enable accessibility mode.</p>
          <p>In this mode:</p>
          <ul>
            <li><strong>Patterns</strong> - Different resource types get distinct patterns (dots, stripes, crosshatch) in addition to colors</li>
            <li><strong>Higher contrast</strong> - Faded portions are more visible with diagonal stripes</li>
            <li><strong>Sync/Async dividers</strong> - Clear white lines separate sync and async portions in Breakdown view</li>
            <li><strong>Bordered sync regions</strong> - Sync execution shown with white borders in Waterfall</li>
          </ul>
          <p class="guide-tip">üí° Accessibility mode helps users who have difficulty distinguishing colors.</p>
        </div>

        <div class="guide-section">
          <h3>Pattern Detection &amp; Thresholds</h3>
          <p>Press <code>T</code> or enable <strong>üîç Patterns</strong> to detect anti-patterns based on "Broken Promises" concepts.</p>
          <p><strong>Severity Levels:</strong></p>
          <ul>
            <li><span style="color: #ff00ff;">üî¥ High</span> - Significant impact: sequential-await, sync-flood, unbatched-ops</li>
            <li><span style="color: #cc66ff;">üü° Medium</span> - Worth investigating: waterfall-fetch, promise-flood, callback-storm, fetch-flood</li>
            <li><span style="color: #9966cc;">üü¢ Low</span> - Minor issues: unresolved-promise, redundant-timers, hot-callback</li>
          </ul>
          <p><strong>Configurable Thresholds</strong> (in Analysis dropdown):</p>
          <table class="guide-table">
            <tr><th>Threshold</th><th>Default</th><th>Detects</th></tr>
            <tr><td>Sync block</td><td>50ms</td><td>Event loop blocking operations</td></tr>
            <tr><td>Long gap</td><td>500ms</td><td>Operations waiting too long</td></tr>
            <tr><td>Promise flood</td><td>20</td><td>Too many promises created in 1ms</td></tr>
            <tr><td>Callback storm</td><td>10</td><td>Too many callbacks in 1ms</td></tr>
            <tr><td>Unbatched ops</td><td>3</td><td>KV/DO ops that could be batched</td></tr>
            <tr><td>Fetch concurrency</td><td>6</td><td>Parallel fetches (connection risk)</td></tr>
          </table>
          <p class="guide-tip">üí° Adjust thresholds based on your workload - lower values detect more issues, higher values reduce noise.</p>
        </div>

        <div class="guide-section">
          <h3>Recommended Workflow</h3>
          <ol>
            <li><strong>Overview</strong> ‚Üí Start with Waterfall (1) to see timeline</li>
            <li><strong>Parallelism check</strong> ‚Üí Switch to Parallelism (4), look for orange serialization</li>
            <li><strong>Time allocation</strong> ‚Üí Check Breakdown (5) for where time goes</li>
            <li><strong>Causality</strong> ‚Üí Use Bubble (2) to understand dependencies</li>
            <li><strong>Critical path</strong> ‚Üí Click üî• to highlight what matters</li>
            <li><strong>Latency outliers</strong> ‚Üí Check Latency (6) histogram for anomalies</li>
            <li><strong>Idle time</strong> ‚Üí Review Gaps (7) for wasted time</li>
            <li><strong>Understand flow</strong> ‚Üí Use Replay (8) to watch execution</li>
            <li><strong>Implement fix</strong> ‚Üí Re-trace and compare</li>
          </ol>
        </div>
      </div>
    </div>
  </div>

  <script>
    const TYPE_COLORS = {
      'root': '#e94560',
      'js-promise': '#7ec8e3',
      'kj-promise': '#50c878',
      'fetch': '#ff6347',
      'cache-get': '#00ced1',
      'cache-put': '#20b2aa',
      'timer': '#ffd700',
      'stream-read': '#87ceeb',
      'stream-write': '#4682b4',
      'websocket': '#dc143c',
      'other': '#808080'
    };

    let traceData = null;
    let selectedResource = null;
    let highlightedChain = new Set();
    let criticalPathSet = new Set();  // Resources on the critical path
    let showCriticalPath = false;
    let criticalPathInfo = null;  // { path: [], totalLatency: 0 }
    let currentView = 'waterfall';

    // DAG view state
    let dagNodes = [];
    let dagSimulationRunning = false;
    let dagDragNode = null;
    let dagPanX = 0, dagPanY = 0;
    let dagZoom = 1;
    let dagIsPanning = false;
    let dagLastMouseX = 0, dagLastMouseY = 0;
    let dagLayoutMode = 'bubble';  // 'bubble', 'force', or 'hierarchical'
    let dagHoveredNode = null;  // Currently hovered node for path highlighting
    let dagPathNodes = new Set();  // Nodes in the path to/from hovered node
    let dagPathEdges = new Set();  // Edges in the path (stored as "fromId-toId")

    // Pan and zoom state for bubble view
    let panX = 0, panY = 0;
    let zoom = 1;
    let isPanning = false;
    let lastMouseX = 0, lastMouseY = 0;

    // Replay state
    let replayTime = 0;
    let replayPlaying = false;
    let replaySpeed = 1;
    let replayAnimationId = null;
    let replayPeakParallelism = 0;
    let replayEventLog = [];  // Array of { time, type, message, color }
    let replayLastEventTime = 0;  // Track last processed event time
    let replayLiveAlerts = [];  // Array of { message, color, expireTime }
    let replayAlertedPatterns = new Set();  // Track patterns already alerted
    let replayLoop = false;  // Loop mode - restart when complete
    let replayLoopPauseUntil = 0;  // Timestamp when loop pause ends
    let replayGhostMode = false;  // Ghost mode - show previous states
    let replayTrail = [];  // Execution trail - { asyncId, fadeStart, x, y, color }
    let replayLayoutMode = 'grid';  // 'grid', 'bubble', or 'rings'
    let replayBubbleNodes = new Map();  // asyncId -> { x, y, targetX, targetY, radius, targetRadius }
    let replayBubbleViewport = { x: 0, y: 0, scale: 1 };  // Pan/zoom for bubble view
    let replayBubbleLastLayout = null;  // Cache last layout computation time
    // Replay sidebar section collapse state
    let replaySidebarCollapsed = {
      metrics: false,
      overhead: false,
      criticalPath: false,
      alerts: false,
      eventFeed: false
    };

    // Accessibility mode - uses patterns instead of colors
    let accessibilityMode = false;

    // Analysis toggles
    let showBottlenecks = false;
    let showPatterns = false;
    let clickToFilterEnabled = false;
    let stackTraceGrouping = false;
    let showTemporalEdges = false;
    let hideInternal = false;
    let clickFilterResourceId = null;  // Currently filtered resource
    let detectedBottlenecks = [];  // Top N slowest resources
    let detectedPatterns = [];  // Detected anti-patterns
    let temporalEdges = [];  // Edges based on callback timing

    // Type filter state - which resource types are visible
    let typeFilters = {};  // { 'js-promise': true, 'fetch': true, ... }
    let expandedStackTraces = new Set();  // asyncIds with expanded stack traces

    // Gaps view state for hover interaction
    let gapsData = [];  // Computed gaps from last render
    let gapsRenderParams = null;  // Rendering parameters for hit detection
    let cachedTotalSync = 0;  // Cached for sidebar re-renders
    let cachedTotalAsync = 0;
    let gapsHoverIndex = -1;  // Currently hovered gap index
    let gapsShowClassification = true;  // Show gap classification
    let gapsShowRecommendations = true;  // Show optimization recommendations
    let gapsThresholdPercent = 0.5;  // Minimum gap threshold (% of total duration)
    let gapsShowMinor = false;  // Show minor gaps below threshold

    // Breakdown view state
    let breakdownGroupBy = 'type';  // 'type', 'classification', 'trigger', 'stack'
    let breakdownVizMode = 'treemap';  // 'treemap', 'sunburst'
    let breakdownDrillPath = [];  // Stack of drill-down selections: [{groupBy, value, label}]
    let breakdownHoverItem = null;  // Currently hovered item for tooltip
    let breakdownData = null;  // Cached breakdown data for interaction
    let breakdownTooltip = null;  // Tooltip element

    // Latency view state
    let latencyMode = 'histogram';  // 'histogram' or 'cdf'
    let latencyShowOutliers = true;
    let latencyBucketData = null;  // Cached bucket data for hit detection
    let latencyHoverBucket = -1;
    let latencyTooltip = null;

    // Heatmap view state
    let heatmapHoverCell = null;  // {typeIdx, bucket} or null
    let heatmapBucketCount = 40;  // Default bucket count
    let heatmapColorScheme = 'type';  // 'type', 'heat', 'mono'
    let heatmapActivityMode = 'combined';  // 'combined', 'sync', 'async', 'count'
    let heatmapSortMode = 'activity';  // 'activity', 'alpha', 'peak', 'first'
    let heatmapData = null;  // Cached data for hover detection
    let heatmapRenderParams = null;  // Render params for coordinate mapping
    let heatmapTooltip = null;

    // Pattern detection thresholds (configurable via UI)
    const DEFAULT_PATTERN_THRESHOLDS = {
      syncBlockMs: 50,       // Event loop blocking threshold (ms)
      longGapMs: 500,        // Long async gap threshold (ms)
      promiseFlood: 20,      // Promise accumulation threshold (count per ms)
      callbackStorm: 10,     // Callback storm threshold (count per ms)
      unbatchedOps: 3,       // Unbatched operations threshold (count)
      fetchFlood: 6,         // Concurrent fetch risk threshold (count)
      hotCallback: 5         // Hot callback threshold (children count)
    };
    let patternThresholds = { ...DEFAULT_PATTERN_THRESHOLDS };

    // Sidebar section collapsed states
    let sidebarCollapsed = {};

    // Settings persistence
    const SETTINGS_KEY = 'async-trace-viewer-settings';

    function saveSettings() {
      const settings = {
        currentView,
        showCriticalPath,
        showBottlenecks,
        showPatterns,
        clickToFilterEnabled,
        stackTraceGrouping,
        showTemporalEdges,
        hideInternal,
        accessibilityMode,
        patternThresholds,
        sidebarCollapsed,
        replaySpeed,
        replayLoop,
        replayGhostMode,
        replayLayoutMode,
        breakdownGroupBy,
        breakdownVizMode
      };
      try {
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
      } catch (e) {
        // Ignore storage errors
      }
    }

    function loadSettings() {
      try {
        const saved = localStorage.getItem(SETTINGS_KEY);
        if (!saved) return;
        const settings = JSON.parse(saved);

        // Restore view
        if (settings.currentView) {
          currentView = settings.currentView;
          document.getElementById('view-select').value = currentView;
          document.querySelectorAll('.view-container').forEach(v => v.classList.remove('active'));
          document.getElementById(currentView + '-view').classList.add('active');
        }

        // Restore analysis toggles
        if (settings.showCriticalPath !== undefined) {
          showCriticalPath = settings.showCriticalPath;
          document.getElementById('critical-path-check').checked = showCriticalPath;
        }
        if (settings.showBottlenecks !== undefined) {
          showBottlenecks = settings.showBottlenecks;
          document.getElementById('bottleneck-check').checked = showBottlenecks;
        }
        if (settings.showPatterns !== undefined) {
          showPatterns = settings.showPatterns;
          document.getElementById('pattern-check').checked = showPatterns;
        }
        if (settings.clickToFilterEnabled !== undefined) {
          clickToFilterEnabled = settings.clickToFilterEnabled;
          document.getElementById('click-filter-check').checked = clickToFilterEnabled;
        }
        if (settings.stackTraceGrouping !== undefined) {
          stackTraceGrouping = settings.stackTraceGrouping;
          document.getElementById('stack-group-check').checked = stackTraceGrouping;
        }
        if (settings.showTemporalEdges !== undefined) {
          showTemporalEdges = settings.showTemporalEdges;
          document.getElementById('temporal-edges-check').checked = showTemporalEdges;
        }
        if (settings.hideInternal !== undefined) {
          hideInternal = settings.hideInternal;
          document.getElementById('hide-internal-check').checked = hideInternal;
        }
        if (settings.accessibilityMode !== undefined) {
          accessibilityMode = settings.accessibilityMode;
          document.getElementById('accessibility-check').checked = accessibilityMode;
        }

        // Restore pattern thresholds
        if (settings.patternThresholds) {
          Object.assign(patternThresholds, settings.patternThresholds);
          // Update slider UI (IDs must match setupThresholdSlider calls)
          const sliders = [
            ['threshold-sync', 'syncBlockMs', 'ms'],
            ['threshold-gap', 'longGapMs', 'ms'],
            ['threshold-promise', 'promiseFlood', ''],
            ['threshold-callback', 'callbackStorm', ''],
            ['threshold-unbatched', 'unbatchedOps', ''],
            ['threshold-fetch', 'fetchFlood', '']
          ];
          sliders.forEach(([id, key, suffix]) => {
            const slider = document.getElementById(id);
            const valueSpan = document.getElementById(id + '-val');
            if (slider && patternThresholds[key] !== undefined) {
              slider.value = patternThresholds[key];
              if (valueSpan) valueSpan.textContent = patternThresholds[key] + suffix;
            }
          });
        }

        // Restore sidebar collapsed states
        if (settings.sidebarCollapsed) {
          sidebarCollapsed = settings.sidebarCollapsed;
          document.querySelectorAll('.sidebar-section h3').forEach(header => {
            const sectionName = header.textContent.trim();
            if (sidebarCollapsed[sectionName]) {
              header.parentElement.classList.add('collapsed');
            }
          });
        }

        // Restore replay speed
        if (settings.replaySpeed !== undefined) {
          const validSpeeds = [0.25, 0.5, 1, 2];
          if (validSpeeds.includes(settings.replaySpeed)) {
            replaySpeed = settings.replaySpeed;
          }
        }

        // Restore replay loop
        if (settings.replayLoop !== undefined) {
          replayLoop = settings.replayLoop;
        }

        // Restore replay ghost mode
        if (settings.replayGhostMode !== undefined) {
          replayGhostMode = settings.replayGhostMode;
        }

        // Restore replay layout mode
        if (settings.replayLayoutMode !== undefined) {
          const validModes = ['grid', 'bubble', 'rings'];
          if (validModes.includes(settings.replayLayoutMode)) {
            replayLayoutMode = settings.replayLayoutMode;
          }
        }

        // Restore breakdown view settings
        if (settings.breakdownGroupBy !== undefined) {
          const validGroups = ['type', 'classification', 'trigger', 'stack'];
          if (validGroups.includes(settings.breakdownGroupBy)) {
            breakdownGroupBy = settings.breakdownGroupBy;
          }
        }
        if (settings.breakdownVizMode !== undefined) {
          const validModes = ['treemap', 'sunburst'];
          if (validModes.includes(settings.breakdownVizMode)) {
            breakdownVizMode = settings.breakdownVizMode;
          }
        }

        updateControlStates();
        updateAnalysisButtonState();
      } catch (e) {
        // Ignore parse errors
      }
    }

    // Pattern cache for accessibility mode
    const patternCache = new Map();

    function getPattern(ctx, type, color) {
      const key = `${type}-${color}-${accessibilityMode}`;
      if (patternCache.has(key)) return patternCache.get(key);

      const patternCanvas = document.createElement('canvas');
      const pctx = patternCanvas.getContext('2d');
      patternCanvas.width = 12;
      patternCanvas.height = 12;

      // Different patterns for different resource types
      const patterns = {
        'root': 'solid',
        'js-promise': 'dots',
        'fetch': 'diagonal',
        'timer': 'horizontal',
        'cache-get': 'vertical',
        'cache-put': 'crosshatch',
        'kv-get': 'zigzag',
        'kv-put': 'diamond',
      };

      const patternType = patterns[type] || 'dots';

      pctx.fillStyle = color;
      pctx.fillRect(0, 0, 12, 12);

      if (accessibilityMode) {
        pctx.strokeStyle = 'rgba(255,255,255,0.6)';
        pctx.lineWidth = 1.5;

        switch (patternType) {
          case 'dots':
            pctx.fillStyle = 'rgba(255,255,255,0.5)';
            pctx.beginPath();
            pctx.arc(3, 3, 1.5, 0, Math.PI * 2);
            pctx.arc(9, 9, 1.5, 0, Math.PI * 2);
            pctx.fill();
            break;
          case 'diagonal':
            pctx.beginPath();
            pctx.moveTo(0, 12);
            pctx.lineTo(12, 0);
            pctx.stroke();
            break;
          case 'horizontal':
            pctx.beginPath();
            pctx.moveTo(0, 6);
            pctx.lineTo(12, 6);
            pctx.stroke();
            break;
          case 'vertical':
            pctx.beginPath();
            pctx.moveTo(6, 0);
            pctx.lineTo(6, 12);
            pctx.stroke();
            break;
          case 'crosshatch':
            pctx.beginPath();
            pctx.moveTo(0, 6);
            pctx.lineTo(12, 6);
            pctx.moveTo(6, 0);
            pctx.lineTo(6, 12);
            pctx.stroke();
            break;
          case 'zigzag':
            pctx.beginPath();
            pctx.moveTo(0, 6);
            pctx.lineTo(4, 2);
            pctx.lineTo(8, 10);
            pctx.lineTo(12, 6);
            pctx.stroke();
            break;
          case 'diamond':
            pctx.beginPath();
            pctx.moveTo(6, 1);
            pctx.lineTo(11, 6);
            pctx.lineTo(6, 11);
            pctx.lineTo(1, 6);
            pctx.closePath();
            pctx.stroke();
            break;
        }
      }

      const pattern = ctx.createPattern(patternCanvas, 'repeat');
      patternCache.set(key, pattern);
      return pattern;
    }

    function clearPatternCache() {
      patternCache.clear();
    }

    // Check if a hex color is light (for choosing text color)
    function isLightColor(hexColor) {
      // Handle hex colors like #7ec8e3
      const hex = hexColor.replace('#', '');
      const r = parseInt(hex.substr(0, 2), 16);
      const g = parseInt(hex.substr(2, 2), 16);
      const b = parseInt(hex.substr(4, 2), 16);
      // Calculate relative luminance (per WCAG)
      const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
      return luminance > 0.5;
    }

    document.addEventListener('DOMContentLoaded', () => {
      // Canvas and ctx are used by multiple views, will be set per-view as needed

      // Load saved settings before setting up event handlers
      loadSettings();

      // View switching
      document.getElementById('view-select').addEventListener('change', (e) => {
        currentView = e.target.value;
        document.querySelectorAll('.view-container').forEach(v => v.classList.remove('active'));
        document.getElementById(currentView + '-view').classList.add('active');
        updateViewHelp();
        updateControlStates();
        saveSettings();
        // Clean up tooltips when switching views
        hideParallelismTooltip();
        parallelismHoverBucket = -1;
        hideBreakdownTooltip();
        breakdownHoverItem = null;
        if (traceData) {
          // Reset replay state when switching to replay view
          if (currentView === 'replay') {
            renderReplay();
          } else {
            render();
          }
        }
      });

      // Initialize help visibility
      updateViewHelp();
      updateControlStates();

      // Collapsible sidebar sections
      document.querySelectorAll('.sidebar-section h3').forEach(header => {
        header.addEventListener('click', () => {
          header.parentElement.classList.toggle('collapsed');
          const sectionName = header.textContent.trim();
          const isCollapsed = header.parentElement.classList.contains('collapsed');
          sidebarCollapsed[sectionName] = isCollapsed;
          saveSettings();

          // Re-render charts when section is expanded (delay to allow layout update)
          if (!isCollapsed && traceData) {
            setTimeout(() => {
              if (sectionName === 'Activity Timeline') {
                renderTimelineChart();
              } else if (sectionName === 'Type Distribution') {
                renderTypeChart();
              } else if (sectionName === 'Time Breakdown') {
                renderTimeBreakdownChart(cachedTotalSync, cachedTotalAsync);
              } else if (sectionName === 'Runtime Overhead') {
                renderRuntimeOverheadChart();
              }
            }, 10);
          }
        });
      });

      document.getElementById('file-input').addEventListener('change', handleFileInput);
      document.getElementById('paste-btn').addEventListener('click', () => {
        document.getElementById('paste-container').classList.toggle('show');
      });
      document.getElementById('load-json-btn').addEventListener('click', loadFromTextarea);
      document.getElementById('demo-select').addEventListener('change', loadDemoData);
      document.getElementById('sort-mode').addEventListener('change', render);
      document.getElementById('nav-parent').addEventListener('click', navigateToParent);
      document.getElementById('nav-children').addEventListener('click', navigateToChildren);

      // Analysis dropdown toggle
      document.getElementById('analysis-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        const menu = document.getElementById('analysis-menu');
        const btn = document.getElementById('analysis-btn');
        menu.classList.toggle('show');
        btn.classList.toggle('active', menu.classList.contains('show'));
        // Close type filter dropdown
        document.getElementById('type-filter-menu').classList.remove('show');
        document.getElementById('type-filter-btn').classList.remove('active');
      });

      // Type filter dropdown toggle
      document.getElementById('type-filter-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        const dropdown = document.getElementById('type-filter-dropdown');
        if (dropdown.classList.contains('disabled')) return;
        const menu = document.getElementById('type-filter-menu');
        const btn = document.getElementById('type-filter-btn');
        menu.classList.toggle('show');
        btn.classList.toggle('active', menu.classList.contains('show'));
        // Close analysis dropdown
        document.getElementById('analysis-menu').classList.remove('show');
        document.getElementById('analysis-btn').classList.remove('active');
      });

      // Close dropdowns when clicking outside
      document.addEventListener('click', (e) => {
        if (!e.target.closest('#analysis-dropdown')) {
          document.getElementById('analysis-menu').classList.remove('show');
          document.getElementById('analysis-btn').classList.remove('active');
        }
        if (!e.target.closest('#type-filter-dropdown')) {
          document.getElementById('type-filter-menu').classList.remove('show');
          document.getElementById('type-filter-btn').classList.remove('active');
        }
      });

      // Analysis checkbox handlers
      document.getElementById('critical-path-check').addEventListener('change', toggleCriticalPath);
      document.getElementById('bottleneck-check').addEventListener('change', toggleBottlenecks);
      document.getElementById('pattern-check').addEventListener('change', togglePatterns);
      document.getElementById('click-filter-check').addEventListener('change', toggleClickFilter);
      document.getElementById('stack-group-check').addEventListener('change', toggleStackGrouping);
      document.getElementById('temporal-edges-check').addEventListener('change', toggleTemporalEdges);
      document.getElementById('hide-internal-check').addEventListener('change', toggleHideInternal);
      document.getElementById('accessibility-check').addEventListener('change', toggleAccessibility);

      // Threshold slider handlers
      function setupThresholdSlider(id, key, suffix = '') {
        const slider = document.getElementById(id);
        const valueSpan = document.getElementById(id + '-val');
        slider.addEventListener('input', () => {
          patternThresholds[key] = parseInt(slider.value);
          valueSpan.textContent = slider.value + suffix;
          saveSettings();
          if (showPatterns && traceData) {
            detectPatterns();
            render();
          }
        });
      }
      setupThresholdSlider('threshold-sync', 'syncBlockMs', 'ms');
      setupThresholdSlider('threshold-gap', 'longGapMs', 'ms');
      setupThresholdSlider('threshold-promise', 'promiseFlood', '');
      setupThresholdSlider('threshold-callback', 'callbackStorm', '');
      setupThresholdSlider('threshold-unbatched', 'unbatchedOps', '');
      setupThresholdSlider('threshold-fetch', 'fetchFlood', '');

      // Restore defaults button for thresholds
      document.getElementById('restore-thresholds-btn').addEventListener('click', () => {
        patternThresholds = { ...DEFAULT_PATTERN_THRESHOLDS };
        const sliders = [
          ['threshold-sync', 'syncBlockMs', 'ms'],
          ['threshold-gap', 'longGapMs', 'ms'],
          ['threshold-promise', 'promiseFlood', ''],
          ['threshold-callback', 'callbackStorm', ''],
          ['threshold-unbatched', 'unbatchedOps', ''],
          ['threshold-fetch', 'fetchFlood', '']
        ];
        sliders.forEach(([id, key, suffix]) => {
          const slider = document.getElementById(id);
          const valueSpan = document.getElementById(id + '-val');
          slider.value = patternThresholds[key];
          valueSpan.textContent = patternThresholds[key] + suffix;
        });
        saveSettings();
        if (showPatterns && traceData) {
          detectPatterns();
          render();
        }
      });

      // Tutorial modal
      document.getElementById('tutorial-btn').addEventListener('click', () => {
        document.getElementById('tutorial-modal').style.display = 'flex';
      });
      document.getElementById('tutorial-close').addEventListener('click', () => {
        document.getElementById('tutorial-modal').style.display = 'none';
      });
      document.getElementById('tutorial-modal').addEventListener('click', (e) => {
        if (e.target.id === 'tutorial-modal') {
          document.getElementById('tutorial-modal').style.display = 'none';
        }
      });
      document.addEventListener('keydown', (e) => {
        // Don't handle hotkeys when typing in input fields
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

        if (e.key === 'Escape') {
          document.getElementById('tutorial-modal').style.display = 'none';
          document.getElementById('ai-modal').style.display = 'none';
          document.getElementById('paste-container').classList.remove('show');
          document.getElementById('analysis-menu').classList.remove('show');
          document.getElementById('analysis-btn').classList.remove('active');
          return;
        }

        // Help hotkey: ?
        if (e.key === '?') {
          document.getElementById('tutorial-modal').style.display = 'flex';
          return;
        }

        // Load hotkey: O (Open) or L (Load) - Shift versions used for Replay toggles
        if ((e.key === 'o' || e.key === 'O' || e.key === 'l' || e.key === 'L') && !e.shiftKey) {
          document.getElementById('file-input').click();
          return;
        }

        // Paste hotkey: P or V
        if (e.key === 'p' || e.key === 'P' || e.key === 'v' || e.key === 'V') {
          document.getElementById('paste-container').classList.toggle('show');
          if (document.getElementById('paste-container').classList.contains('show')) {
            document.getElementById('json-input').focus();
          }
          return;
        }

        // Critical path hotkey: C
        if (e.key === 'c' || e.key === 'C') {
          toggleCriticalPath(true);
          return;
        }

        // AI Analyze hotkey: I
        if (e.key === 'i' || e.key === 'I') {
          openAIAnalysis();
          return;
        }

        // View hotkeys: 1-8 for different views (Graph combines DAG layouts including Bubble)
        const viewKeys = {
          '1': 'waterfall',
          '2': 'dag',
          '3': 'replay',
          '4': 'parallelism',
          '5': 'breakdown',
          '6': 'latency',
          '7': 'gaps',
          '8': 'heatmap'
        };

        if (viewKeys[e.key]) {
          const newView = viewKeys[e.key];
          currentView = newView;
          document.getElementById('view-select').value = newView;
          document.querySelectorAll('.view-container').forEach(v => v.classList.remove('active'));
          document.getElementById(newView + '-view').classList.add('active');
          updateViewHelp();
          updateControlStates();
          // Clean up tooltips when switching views
          hideParallelismTooltip();
          parallelismHoverBucket = -1;
          hideBreakdownTooltip();
          breakdownHoverItem = null;
          if (traceData) {
            // Reset replay state when switching to replay view
            if (newView === 'replay') {
              renderReplay();
            } else {
              render();
            }
          }
          return;
        }

        // Heatmap bucket adjustment: Left/Right arrows (only when heatmap view is active)
        if (currentView === 'heatmap' && (e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
          const slider = document.getElementById('heatmap-bucket-slider');
          const step = parseInt(slider.step);
          const min = parseInt(slider.min);
          const max = parseInt(slider.max);
          let newValue = heatmapBucketCount;
          if (e.key === 'ArrowRight') {
            newValue = Math.min(max, heatmapBucketCount + step);
          } else {
            newValue = Math.max(min, heatmapBucketCount - step);
          }
          if (newValue !== heatmapBucketCount) {
            heatmapBucketCount = newValue;
            slider.value = newValue;
            document.getElementById('heatmap-bucket-value').textContent = newValue;
            if (traceData) renderHeatmap();
          }
          return;
        }

        // DAG layout toggle: Left/Right arrows (only when DAG view is active)
        if (currentView === 'dag' && (e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
          const layouts = ['bubble', 'hierarchical', 'force'];
          const currentIndex = layouts.indexOf(dagLayoutMode);
          let newIndex;
          if (e.key === 'ArrowRight') {
            newIndex = (currentIndex + 1) % layouts.length;
          } else {
            newIndex = (currentIndex - 1 + layouts.length) % layouts.length;
          }
          const newLayout = layouts[newIndex];
          if (newLayout !== dagLayoutMode) {
            dagLayoutMode = newLayout;
            document.querySelectorAll('.dag-layout-btn').forEach(b => {
              b.classList.toggle('active', b.dataset.layout === newLayout);
            });
            dagNodes = [];
            dagSimulationRunning = false;
            if (traceData) {
              initDAGNodes();
            }
          }
          return;
        }

        // Replay timeline stepping: Left/Right arrows (only when replay view is active)
        if (currentView === 'replay' && (e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
          if (!traceData) return;

          if (e.ctrlKey && e.shiftKey) {
            // Ctrl+Shift+Arrow: Jump to critical path events only
            if (criticalPathSet.size === 0) return; // No critical path calculated
            const events = [];
            traceData.resources.forEach(r => {
              if (!criticalPathSet.has(r.asyncId)) return;
              if (r.createdAt > 0) events.push(r.createdAt);
              if (r.callbackStartedAt > 0) events.push(r.callbackStartedAt);
              if (r.callbackEndedAt > 0) events.push(r.callbackEndedAt);
            });
            const uniqueEvents = [...new Set(events)].sort((a, b) => a - b);

            if (e.key === 'ArrowRight') {
              const nextEvent = uniqueEvents.find(t => t > replayTime);
              if (nextEvent !== undefined) {
                replayTime = nextEvent;
              } else {
                replayTime = traceData.requestDurationNs;
              }
            } else {
              const prevEvents = uniqueEvents.filter(t => t < replayTime);
              if (prevEvents.length > 0) {
                replayTime = prevEvents[prevEvents.length - 1];
              } else {
                replayTime = 0;
              }
            }
          } else if (e.shiftKey) {
            // Shift+Arrow: Jump to next/previous significant event
            // Collect all significant timestamps
            const events = [];
            traceData.resources.forEach(r => {
              if (r.createdAt > 0) events.push(r.createdAt);
              if (r.callbackStartedAt > 0) events.push(r.callbackStartedAt);
              if (r.callbackEndedAt > 0) events.push(r.callbackEndedAt);
            });
            // Sort and deduplicate
            const uniqueEvents = [...new Set(events)].sort((a, b) => a - b);

            if (e.key === 'ArrowRight') {
              // Find next event after current time
              const nextEvent = uniqueEvents.find(t => t > replayTime);
              if (nextEvent !== undefined) {
                replayTime = nextEvent;
              } else {
                replayTime = traceData.requestDurationNs;
              }
            } else {
              // Find previous event before current time
              const prevEvents = uniqueEvents.filter(t => t < replayTime);
              if (prevEvents.length > 0) {
                replayTime = prevEvents[prevEvents.length - 1];
              } else {
                replayTime = 0;
              }
            }
          } else {
            // Regular arrow: Step by 1% increments
            const stepSize = traceData.requestDurationNs / 100;
            if (e.key === 'ArrowRight') {
              replayTime = Math.min(replayTime + stepSize, traceData.requestDurationNs);
            } else {
              replayTime = Math.max(replayTime - stepSize, 0);
            }
          }

          // Pause if playing
          if (replayPlaying) {
            stopReplayAnimation();
          }
          renderReplayFrame();
          return;
        }

        // Replay speed toggle: -/+ keys (only when replay view is active)
        if (currentView === 'replay' && (e.key === '-' || e.key === '+' || e.key === '=')) {
          const speeds = [0.25, 0.5, 1, 2];
          const currentIndex = speeds.indexOf(replaySpeed);
          let newIndex;
          if (e.key === '+' || e.key === '=') {
            newIndex = Math.min(currentIndex + 1, speeds.length - 1);
          } else {
            newIndex = Math.max(currentIndex - 1, 0);
          }
          replaySpeed = speeds[newIndex];
          saveSettings();
          renderReplayFrame();
          return;
        }

        // Replay loop toggle: Shift+L (only when replay view is active)
        if (currentView === 'replay' && e.shiftKey && (e.key === 'l' || e.key === 'L')) {
          replayLoop = !replayLoop;
          saveSettings();
          renderReplayFrame();
          return;
        }

        // Replay ghost mode toggle: Shift+O (only when replay view is active)
        if (currentView === 'replay' && e.shiftKey && (e.key === 'o' || e.key === 'O')) {
          replayGhostMode = !replayGhostMode;
          saveSettings();
          renderReplayFrame();
          return;
        }

        // Accessibility mode toggle: A
        if (e.key === 'a' || e.key === 'A') {
          toggleAccessibility(true);
          return;
        }

        // Bottleneck detection toggle: B
        if (e.key === 'b' || e.key === 'B') {
          toggleBottlenecks(true);
          return;
        }

        // Pattern detection toggle: T
        if (e.key === 't' || e.key === 'T') {
          togglePatterns(true);
          return;
        }

        // Click-to-filter toggle: F
        if (e.key === 'f' || e.key === 'F') {
          toggleClickFilter(true);
          return;
        }

        // Stack trace grouping toggle: G
        if (e.key === 'g' || e.key === 'G') {
          toggleStackGrouping(true);
          return;
        }

        // Temporal edges toggle: E
        if (e.key === 'e' || e.key === 'E') {
          toggleTemporalEdges(true);
          return;
        }

        // Hide internal toggle: H
        if (e.key === 'h' || e.key === 'H') {
          toggleHideInternal(true);
          return;
        }

        // Refresh/Reset current view: Shift+R
        if (e.shiftKey && (e.key === 'r' || e.key === 'R')) {
          if (traceData) {
            // Reset view-specific state
            if (currentView === 'dag') {
              dagPanX = 0; dagPanY = 0; dagZoom = 1;
              dagNodes = [];
            } else if (currentView === 'replay') {
              stopReplayAnimation();
              replayTime = 0;
            } else if (currentView === 'breakdown') {
              breakdownDrillPath = [];
              breakdownData = null;
            }
            render();
          }
          return;
        }

        // Replay controls: Space = play/pause, R = reset
        if (currentView === 'replay' && traceData) {
          if (e.key === ' ' || e.key === 'Space') {
            e.preventDefault();
            if (replayPlaying) {
              stopReplayAnimation();
            } else {
              if (replayTime >= traceData.requestDurationNs) {
                replayTime = 0;
                replayTrail = [];
              }
              startReplayAnimation();
            }
            renderReplayFrame();
          } else if (e.key === 'r' || e.key === 'R') {
            stopReplayAnimation();
            replayTime = 0;
            replayTrail = [];
            renderReplayFrame();
          }
        }
      });

      // AI Analysis modal
      document.getElementById('ai-analyze-btn').addEventListener('click', openAIAnalysis);
      document.getElementById('ai-close').addEventListener('click', () => {
        document.getElementById('ai-modal').style.display = 'none';
      });
      document.getElementById('ai-modal').addEventListener('click', (e) => {
        if (e.target.id === 'ai-modal') {
          document.getElementById('ai-modal').style.display = 'none';
        }
      });
      document.getElementById('ai-copy-btn').addEventListener('click', () => {
        const prompt = document.getElementById('ai-prompt').value;
        navigator.clipboard.writeText(prompt).then(() => {
          const status = document.getElementById('ai-copy-status');
          status.style.display = 'block';
          setTimeout(() => status.style.display = 'none', 2000);
        });
      });

      // Clear filter button
      document.getElementById('clear-filter-btn').addEventListener('click', () => {
        clickFilterResourceId = null;
        document.getElementById('click-filter-check').checked = false;
        clickToFilterEnabled = false;
        updateAnalysisInfo();
        updateAnalysisButtonState();
        if (traceData) render();
      });

      // DAG layout toggle buttons
      document.querySelectorAll('.dag-layout-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const newLayout = btn.dataset.layout;
          if (newLayout === dagLayoutMode) return;

          dagLayoutMode = newLayout;
          document.querySelectorAll('.dag-layout-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');

          // Re-initialize nodes with new layout
          dagNodes = [];
          dagSimulationRunning = false;
          if (traceData) {
            initDAGNodes();
          }
        });
      });

      // DAG canvas event handlers
      const dagCanvas = document.getElementById('dag-canvas');

      dagCanvas.addEventListener('mousedown', (e) => {
        const rect = dagCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left - dagPanX) / dagZoom;
        const y = (e.clientY - rect.top - dagPanY) / dagZoom;

        // Check if clicking on a node
        const clickedNode = dagNodes.find(n => {
          const dx = x - n.x, dy = y - n.y;
          return Math.sqrt(dx*dx + dy*dy) <= n.radius;
        });

        if (clickedNode && !e.shiftKey) {
          dagDragNode = clickedNode;
          clickedNode.fixed = true;
          dagCanvas.style.cursor = 'grabbing';
        } else if (e.shiftKey || e.button === 1) {
          dagIsPanning = true;
          dagLastMouseX = e.clientX;
          dagLastMouseY = e.clientY;
          dagCanvas.style.cursor = 'grabbing';
        }
      });

      dagCanvas.addEventListener('mousemove', (e) => {
        const rect = dagCanvas.getBoundingClientRect();

        if (dagDragNode) {
          dagDragNode.x = (e.clientX - rect.left - dagPanX) / dagZoom;
          dagDragNode.y = (e.clientY - rect.top - dagPanY) / dagZoom;
          renderDAG();
        } else if (dagIsPanning) {
          dagPanX += e.clientX - dagLastMouseX;
          dagPanY += e.clientY - dagLastMouseY;
          dagLastMouseX = e.clientX;
          dagLastMouseY = e.clientY;
          renderDAG();
        } else {
          // Hover detection
          const x = (e.clientX - rect.left - dagPanX) / dagZoom;
          const y = (e.clientY - rect.top - dagPanY) / dagZoom;
          const hovered = dagNodes.find(n => {
            const dx = x - n.x, dy = y - n.y;
            return Math.sqrt(dx*dx + dy*dy) <= n.radius;
          });

          if (hovered) {
            dagCanvas.style.cursor = 'pointer';
            const r = hovered.resource;
            const tooltip = document.getElementById('tooltip');
            const patternHTML = getPatternTooltipHTML(r.asyncId);
            const criticalPathHTML = getCriticalPathTooltipHTML(r.asyncId);

            // Stack trace preview
            const st = traceData.stackTraceMap.get(r.stackTraceId);
            const stackPreview = (st && st.frames.length > 0)
              ? `<div style="margin-top: 0.3rem; font-family: monospace; font-size: 0.65rem; color: #7ec8e3;">
                   ${st.frames.slice(0, 3).map(f => `<div>‚Üí ${f}</div>`).join('')}
                   ${st.frames.length > 3 ? `<div style="color: #666;">...${st.frames.length - 3} more</div>` : ''}
                 </div>`
              : '';

            // Classification label
            const classLabel = r._classification === 'typed' ? 'API' : (r._classification === 'user' ? 'User' : 'Internal');

            // Timing info
            const createdMs = (r.createdAt / 1e6).toFixed(2);
            const callbackMs = r.callbackStartedAt > 0 ? (r.callbackStartedAt / 1e6).toFixed(2) : null;
            const syncTimeMs = (r.callbackStartedAt > 0 && r.callbackEndedAt > 0)
              ? ((r.callbackEndedAt - r.callbackStartedAt) / 1e6).toFixed(2)
              : null;

            tooltip.innerHTML = `
              <div class="tooltip-title">${r.type} #${r.asyncId} <span style="color: #888; font-size: 0.7rem;">(${classLabel})</span></div>
              <div>Created: ${createdMs}ms</div>
              ${callbackMs ? `<div>Callback: ${callbackMs}ms</div>` : ''}
              ${syncTimeMs ? `<div>Sync time: ${syncTimeMs}ms</div>` : ''}
              <div>Children: ${(traceData.childrenMap.get(r.asyncId) || []).length}</div>
              ${stackPreview}
              ${criticalPathHTML}
              ${patternHTML}
            `;
            tooltip.style.display = 'block';
            tooltip.style.left = (e.clientX + 10) + 'px';
            tooltip.style.top = (e.clientY + 10) + 'px';

            // Path highlighting
            if (dagHoveredNode !== hovered) {
              dagHoveredNode = hovered;
              computeDAGPath(r.asyncId);
              renderDAG();
            }
          } else {
            dagCanvas.style.cursor = 'default';
            document.getElementById('tooltip').style.display = 'none';

            // Clear path highlighting
            if (dagHoveredNode !== null) {
              clearDAGPath();
              renderDAG();
            }
          }
        }
      });

      dagCanvas.addEventListener('mouseup', (e) => {
        if (dagDragNode) {
          dagDragNode.fixed = false;
          dagDragNode = null;
        }
        dagIsPanning = false;
        dagCanvas.style.cursor = 'default';
      });

      dagCanvas.addEventListener('click', (e) => {
        if (dagDragNode) return;  // Was dragging, not clicking

        const rect = dagCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left - dagPanX) / dagZoom;
        const y = (e.clientY - rect.top - dagPanY) / dagZoom;

        const clicked = dagNodes.find(n => {
          const dx = x - n.x, dy = y - n.y;
          return Math.sqrt(dx*dx + dy*dy) <= n.radius;
        });

        if (clicked) {
          selectResource(clicked.resource);
          // Handle click-to-filter
          if (clickToFilterEnabled) {
            applyClickFilter(clicked.resource.asyncId);
          }
        }
      });

      dagCanvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const rect = dagCanvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const oldZoom = dagZoom;
        const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
        dagZoom = Math.max(0.1, Math.min(5, dagZoom * zoomDelta));

        dagPanX = mouseX - (mouseX - dagPanX) * (dagZoom / oldZoom);
        dagPanY = mouseY - (mouseY - dagPanY) * (dagZoom / oldZoom);

        renderDAG();
      });

      dagCanvas.addEventListener('mouseleave', () => {
        document.getElementById('tooltip').style.display = 'none';
        dagIsPanning = false;
        if (dagDragNode) {
          dagDragNode.fixed = false;
          dagDragNode = null;
        }
        // Clear path highlighting
        if (dagHoveredNode !== null) {
          clearDAGPath();
          renderDAG();
        }
      });

      // Gaps canvas event handlers
      const gapsCanvas = document.getElementById('gaps-canvas');

      gapsCanvas.addEventListener('mousemove', (e) => {
        if (!gapsRenderParams || !gapsData.length) return;

        const rect = gapsCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const { padding, barWidth, numBuckets } = gapsRenderParams;

        // Check if we're in the chart area
        if (x < padding.left || x > gapsCanvas.width - padding.right ||
            y < padding.top || y > gapsCanvas.height - padding.bottom) {
          document.getElementById('tooltip').style.display = 'none';
          gapsCanvas.style.cursor = 'default';
          return;
        }

        // Find which gap (if any) we're hovering over
        const hoveredGap = gapsData.find(gap => {
          const gapX = padding.left + gap.startBucket * barWidth;
          const gapWidth = (gap.endBucket - gap.startBucket) * barWidth;
          return x >= gapX && x <= gapX + gapWidth;
        });

        if (hoveredGap) {
          gapsCanvas.style.cursor = 'pointer';
          const tooltip = document.getElementById('tooltip');

          // Build waiting resources summary
          const waitingByType = {};
          hoveredGap.waitingResources.forEach(r => {
            waitingByType[r.type] = (waitingByType[r.type] || 0) + 1;
          });
          const waitingSummary = Object.entries(waitingByType)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5)
            .map(([type, count]) => `<div style="color: #7ec8e3; font-size: 0.7rem;">‚Ä¢ ${type}: ${count}</div>`)
            .join('');

          tooltip.innerHTML = `
            <div class="tooltip-title">Idle Gap</div>
            <div>Duration: ${hoveredGap.durationMs.toFixed(2)}ms</div>
            <div>Time: ${(hoveredGap.startNs / 1e6).toFixed(2)}ms - ${(hoveredGap.endNs / 1e6).toFixed(2)}ms</div>
            <div style="margin-top: 0.3rem; font-weight: bold; color: #ff6432;">${hoveredGap.waitingResources.length} operations waiting:</div>
            ${waitingSummary || '<div style="color: #666; font-size: 0.7rem;">No async operations waiting</div>'}
            ${Object.keys(waitingByType).length > 5 ? `<div style="color: #888; font-size: 0.65rem;">...and ${Object.keys(waitingByType).length - 5} more types</div>` : ''}
          `;
          tooltip.style.display = 'block';
          tooltip.style.left = (e.clientX + 10) + 'px';
          tooltip.style.top = (e.clientY + 10) + 'px';
        } else {
          document.getElementById('tooltip').style.display = 'none';
          gapsCanvas.style.cursor = 'default';
        }
      });

      gapsCanvas.addEventListener('mouseleave', () => {
        document.getElementById('tooltip').style.display = 'none';
      });

      window.addEventListener('resize', () => {
        if (traceData) {
          if (currentView === 'dag') {
            renderDAG();
          } else if (currentView === 'parallelism') {
            renderParallelism();
          } else if (currentView === 'breakdown') {
            renderBreakdown();
          } else if (currentView === 'latency') {
            renderLatency();
          } else if (currentView === 'gaps') {
            renderGaps();
          } else if (currentView === 'replay') {
            renderReplayFrame();
          }
        }
      });
    });

    function handleFileInput(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          traceData = JSON.parse(e.target.result);
          processAndRender();
        } catch (err) {
          alert('Invalid JSON: ' + err.message);
        }
      };
      reader.readAsText(file);
    }

    function loadFromTextarea() {
      try {
        traceData = JSON.parse(document.getElementById('json-input').value);
        processAndRender();
        document.getElementById('paste-container').classList.remove('show');
      } catch (err) {
        alert('Invalid JSON: ' + err.message);
      }
    }

    async function loadDemoData() {
      const demo = document.getElementById('demo-select').value;
      if (!demo) return;
      const files = {
          'timer': 'sample-trace.json',
          'async-patterns': 'sample-async-patterns.json',
          'chat-room': 'sample-chat-room.json',
          'good-parallel': 'sample-good-parallel.json',
          'bad-sequential': 'sample-bad-sequential.json',
          'bad-duplicates': 'sample-bad-duplicates.json',
          'waterfall-fetches': 'sample-waterfall-fetches.json',
          'unresolved-promises': 'sample-unresolved-promises.json',
          'long-async-gaps': 'sample-long-async-gaps.json',
          'redundant-timers': 'sample-redundant-timers.json',
          'cache-misses': 'sample-cache-misses.json',
          'streams-pipeline': 'sample-streams-pipeline.json',
          'pathological': 'sample-pathological-streams.json',
          'nextjs-ssr': 'sample-nextjs-ssr.json',
          'graphql-api': 'sample-graphql-api.json',
          'api-gateway': 'sample-api-gateway.json',
          'ecommerce-checkout': 'sample-ecommerce-checkout.json',
          'image-pipeline': 'sample-image-pipeline.json',
          'webhook-fanout': 'sample-webhook-fanout.json',
          'auth-flow': 'sample-auth-flow.json',
          'chat-message': 'sample-chat-message.json',
          // Pathological anti-patterns
          'antipattern-n-plus-one': 'sample-antipattern-n-plus-one.json',
          'antipattern-waterfall': 'sample-antipattern-waterfall.json',
          'antipattern-promise-hell': 'sample-antipattern-promise-hell.json',
          'antipattern-await-loop': 'sample-antipattern-await-in-loop.json',
          // Real traces captured from workerd samples
          'real-helloworld': 'sample-real-helloworld.json',
          'real-helloworld-sw': 'sample-real-helloworld-sw.json',
          'real-async-context': 'sample-real-async-context.json',
          'real-durable-objects': 'sample-real-durable-objects.json',
          'real-nodejs-compat-fs': 'sample-real-nodejs-compat-fs.json',
          'real-nodejs-compat-streams': 'sample-real-nodejs-compat-streams.json',
          'real-tcp': 'sample-real-tcp.json',
          'real-eventsource': 'sample-real-eventsource.json',
          'real-nodejs-compat-http': 'sample-real-nodejs-compat-http.json'
        };
      try {
        const response = await fetch(files[demo] + '?t=' + Date.now());
        traceData = await response.json();
        processAndRender();
      } catch (err) {
        alert('Failed to load: ' + err.message);
      }
    }

    // Check if a stack frame is from an internal module
    // Frame format: "functionName @ module:line:col" or just "functionName @ module"
    function isInternalFrame(frame) {
      if (!frame) return true;
      const atIndex = frame.indexOf(' @ ');
      if (atIndex === -1) return false; // Can't determine, assume user
      const moduleAndLocation = frame.slice(atIndex + 3);
      // Internal module prefixes that indicate runtime/platform code
      const internalPrefixes = [
        'node-internal:',
        'node:',
        'cloudflare-internal:',
        'cloudflare:',
        'workerd-internal:',
        'workerd:',
      ];
      return internalPrefixes.some(prefix => moduleAndLocation.startsWith(prefix));
    }

    // Classify a resource as 'typed', 'user', or 'internal'
    function classifyResource(r) {
      // Internal bridge types are runtime machinery, not user-facing APIs
      const internalTypes = ['kj-to-js', 'js-to-kj'];
      if (internalTypes.includes(r.type)) {
        return 'internal';
      }
      // Typed resources are explicit API operations (not js-promise or internal bridges)
      if (r.type !== 'js-promise') {
        return 'typed';
      }
      // JS promises with stack traces pointing to user code = user
      const st = traceData.stackTraceMap.get(r.stackTraceId);
      if (st && st.frames && st.frames.length > 0) {
        // Check if any frame is in user code (not internal)
        const hasUserFrame = st.frames.some(f => !isInternalFrame(f));
        if (hasUserFrame) return 'user';
      }
      // JS promises with empty stack traces or only internal frames = internal runtime machinery
      return 'internal';
    }

    function shouldShowResource(r) {
      // Check type filter first
      if (typeFilters[r.type] === false) return false;

      // Hide internal resources if enabled
      if (hideInternal && r._classification === 'internal') {
        return false;
      }
      return true;
    }

    // Initialize type filter dropdown based on trace data
    function initTypeFilters() {
      const menu = document.getElementById('type-filter-menu');
      menu.innerHTML = '';
      typeFilters = {};

      if (!traceData) return;

      // Get unique types from trace data
      const typeCounts = new Map();
      traceData.resources.forEach(r => {
        typeCounts.set(r.type, (typeCounts.get(r.type) || 0) + 1);
      });

      // Sort by count descending
      const sortedTypes = [...typeCounts.entries()].sort((a, b) => b[1] - a[1]);

      // Add "Enable All" shortcut at the top
      const enableAllItem = document.createElement('div');
      enableAllItem.className = 'type-filter-item';
      enableAllItem.style.borderBottom = '1px solid #333';
      enableAllItem.style.marginBottom = '4px';
      enableAllItem.style.paddingBottom = '8px';
      enableAllItem.innerHTML = '<span style="color: #e94560;">‚úì Enable All</span>';
      enableAllItem.addEventListener('click', () => {
        Object.keys(typeFilters).forEach(type => {
          typeFilters[type] = true;
        });
        menu.querySelectorAll('input[type="checkbox"]').forEach(cb => {
          cb.checked = true;
        });
        updateTypeFilterButton();
        render();
      });
      menu.appendChild(enableAllItem);

      sortedTypes.forEach(([type, count]) => {
        typeFilters[type] = true;  // All enabled by default

        const item = document.createElement('label');
        item.className = 'type-filter-item';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = true;
        checkbox.dataset.type = type;

        const colorBox = document.createElement('span');
        colorBox.className = 'type-color';
        colorBox.style.background = TYPE_COLORS[type] || '#808080';

        const nameSpan = document.createElement('span');
        nameSpan.textContent = type;

        const countSpan = document.createElement('span');
        countSpan.className = 'type-count';
        countSpan.textContent = count;

        checkbox.addEventListener('change', () => {
          typeFilters[type] = checkbox.checked;
          updateTypeFilterButton();
          render();
        });

        item.appendChild(checkbox);
        item.appendChild(colorBox);
        item.appendChild(nameSpan);
        item.appendChild(countSpan);
        menu.appendChild(item);
      });

      updateTypeFilterButton();
    }

    // Update the type filter button text to show active filter count
    function updateTypeFilterButton() {
      const btn = document.getElementById('type-filter-btn');
      const totalTypes = Object.keys(typeFilters).length;
      const enabledTypes = Object.values(typeFilters).filter(v => v).length;
      if (enabledTypes === totalTypes) {
        btn.textContent = 'üè∑Ô∏è Types ‚ñæ';
      } else {
        btn.textContent = `üè∑Ô∏è Types (${enabledTypes}/${totalTypes}) ‚ñæ`;
      }
    }

    function processAndRender() {
      dagNodes = [];  // Invalidate DAG layout when loading new data
      dagPanX = 0; dagPanY = 0; dagZoom = 1;  // Reset DAG pan/zoom
      panX = 0; panY = 0; zoom = 1;  // Reset pan/zoom

      traceData.resourceMap = new Map();
      traceData.resources.forEach(r => traceData.resourceMap.set(r.asyncId, r));

      traceData.stackTraceMap = new Map();
      traceData.stackTraces.forEach(st => traceData.stackTraceMap.set(st.id, st));

      traceData.annotationMap = new Map();
      traceData.annotations.forEach(a => {
        if (!traceData.annotationMap.has(a.asyncId)) traceData.annotationMap.set(a.asyncId, []);
        traceData.annotationMap.get(a.asyncId).push(a);
      });

      // Classify each resource
      traceData.resources.forEach(r => {
        r._classification = classifyResource(r);
      });

      // Initialize type filter buttons
      initTypeFilters();
      expandedStackTraces.clear();

      traceData.childrenMap = new Map();
      traceData.resources.forEach(r => {
        if (r.triggerId !== 0) {
          if (!traceData.childrenMap.has(r.triggerId)) traceData.childrenMap.set(r.triggerId, []);
          traceData.childrenMap.get(r.triggerId).push(r.asyncId);
        }
      });

      traceData.depthMap = new Map();
      function calcDepth(id, depth) {
        traceData.depthMap.set(id, depth);
        (traceData.childrenMap.get(id) || []).forEach(cid => calcDepth(cid, depth + 1));
      }
      const root = traceData.resources.find(r => r.type === 'root');
      if (root) calcDepth(root.asyncId, 0);

      updateStats();
      updateLegend();
      renderRuntimeOverheadChart();
      computeCriticalPath();
      updateCriticalPathInfo();
      // Run detection if enabled
      if (showBottlenecks) detectBottlenecks();
      if (showPatterns) detectPatterns();
      if (showTemporalEdges) computeTemporalEdges();
      // Reset click filter on new data
      clickFilterResourceId = null;
      // Update analysis sidebar with new data
      updateAnalysisInfo();
      // Reset replay state when loading new data
      if (currentView === 'replay') {
        renderReplay();
      } else {
        render();
      }
    }

    // Compute the critical path - the chain of resources that determines minimum latency.
    // The critical path is the longest sequential chain through the dependency graph,
    // where "length" is measured by cumulative time (creation to callback end).
    function computeCriticalPath() {
      if (!traceData) return;

      criticalPathSet.clear();
      criticalPathInfo = null;

      // For each resource, compute the longest path FROM ROOT ending at that resource.
      // pathLength[id] = { length: cumulative time, predecessor: id that led here }
      const pathInfo = new Map();

      // Sort by creation time to process in roughly topological order
      const sorted = [...traceData.resources].sort((a, b) => a.createdAt - b.createdAt);

      sorted.forEach(r => {
        // When does this resource's work complete?
        const myEnd = r.callbackEndedAt > 0 ? r.callbackEndedAt :
                      (r.destroyedAt > 0 ? r.destroyedAt : traceData.requestDurationNs);

        // The "cost" of this resource (its contribution to latency)
        const myCost = myEnd - r.createdAt;

        // Find the best predecessor - the one that gives longest path to here
        let bestPredecessor = null;
        let bestPathLength = myCost;  // If no predecessor, path length is just my cost

        if (r.triggerId !== 0 && pathInfo.has(r.triggerId)) {
          const parentInfo = pathInfo.get(r.triggerId);
          const pathThroughParent = parentInfo.length + myCost;
          if (pathThroughParent > bestPathLength) {
            bestPathLength = pathThroughParent;
            bestPredecessor = r.triggerId;
          }
        }

        // For root, or orphans, path length starts at myCost
        pathInfo.set(r.asyncId, {
          length: bestPathLength,
          predecessor: bestPredecessor,
          endTime: myEnd
        });
      });

      // Find the resource with the longest path (this is the end of the critical path)
      let maxPathLength = 0;
      let lastResource = null;

      pathInfo.forEach((info, asyncId) => {
        if (info.length > maxPathLength) {
          maxPathLength = info.length;
          lastResource = traceData.resourceMap.get(asyncId);
        }
      });

      if (!lastResource) return;

      // Trace back to build the critical path
      const path = [];
      let current = lastResource;
      while (current) {
        path.unshift(current);
        criticalPathSet.add(current.asyncId);
        const info = pathInfo.get(current.asyncId);
        if (!info || info.predecessor === null) break;
        current = traceData.resourceMap.get(info.predecessor);
      }

      // Calculate timing breakdown on critical path
      let totalAsyncWait = 0;
      let totalSyncTime = 0;
      path.forEach(r => {
        if (r.callbackStartedAt > 0 && r.createdAt > 0) {
          totalAsyncWait += r.callbackStartedAt - r.createdAt;
        }
        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          totalSyncTime += r.callbackEndedAt - r.callbackStartedAt;
        }
      });

      criticalPathInfo = {
        path,
        totalAsyncWait,
        totalSyncTime,
        totalTime: maxPathLength
      };

      console.log(`Critical path: ${path.length} resources, ` +
        `total=${(maxPathLength/1e6).toFixed(2)}ms, ` +
        `async=${(totalAsyncWait/1e6).toFixed(2)}ms, ` +
        `sync=${(totalSyncTime/1e6).toFixed(2)}ms`);
    }

    function toggleCriticalPath(fromHotkey = false) {
      const checkbox = document.getElementById('critical-path-check');
      if (fromHotkey) {
        showCriticalPath = !showCriticalPath;
        checkbox.checked = showCriticalPath;
      } else {
        showCriticalPath = checkbox.checked;
      }
      updateCriticalPathInfo();
      updateAnalysisButtonState();
      saveSettings();
      render();
    }

    function toggleAccessibility(fromHotkey = false) {
      const checkbox = document.getElementById('accessibility-check');
      if (fromHotkey) {
        accessibilityMode = !accessibilityMode;
        checkbox.checked = accessibilityMode;
      } else {
        accessibilityMode = checkbox.checked;
      }
      clearPatternCache();
      document.body.classList.toggle('accessibility-mode', accessibilityMode);
      updateAnalysisButtonState();
      saveSettings();
      if (traceData) render();
    }

    function updateAnalysisButtonState() {
      const activeCount = [showCriticalPath, showBottlenecks, showPatterns, clickToFilterEnabled, stackTraceGrouping, showTemporalEdges, hideInternal, accessibilityMode].filter(x => x).length;
      const btn = document.getElementById('analysis-btn');
      if (activeCount > 0) {
        btn.textContent = `üî¨ Analysis (${activeCount}) ‚ñæ`;
        btn.classList.add('active');
      } else {
        btn.textContent = 'üî¨ Analysis ‚ñæ';
        btn.classList.remove('active');
      }
    }

    function updateCriticalPathInfo() {
      const container = document.getElementById('critical-path-info');

      if (!criticalPathInfo || criticalPathInfo.path.length === 0) {
        container.innerHTML = '<div class="detail-item" style="color: #666;">No path computed</div>';
        return;
      }

      const info = criticalPathInfo;
      const pathDesc = info.path.map(r => {
        const typeName = r.type.replace('js-', '').substring(0, 6);
        return `<span style="color: ${TYPE_COLORS[r.type] || '#808080'};">${typeName}</span>`;
      }).join(' ‚Üí ');

      container.innerHTML = `
        <div class="detail-item">
          <strong style="color: #ff6432;">üî• ${info.path.length} resources</strong>
        </div>
        <div class="detail-item">
          <strong>Async wait:</strong> ${(info.totalAsyncWait / 1e6).toFixed(2)}ms
        </div>
        <div class="detail-item">
          <strong>Sync time:</strong> ${(info.totalSyncTime / 1e6).toFixed(2)}ms
        </div>
        <div class="detail-item" style="word-break: break-all; line-height: 1.4;">
          ${pathDesc}
        </div>
        <div class="detail-item" style="color: #888; font-size: 0.65rem;">
          This is the minimum latency path.<br>
          Only optimizing this path reduces total time.
        </div>
      `;
    }

    // ==================== ANALYSIS INFO UPDATE ====================
    function updateAnalysisInfo() {
      const container = document.getElementById('analysis-info');
      const filterStatus = document.getElementById('click-filter-status');

      let html = '';

      // Show bottlenecks info
      if (showBottlenecks && detectedBottlenecks.length > 0) {
        html += `<div class="detail-item" style="color: #ffc832;"><strong>üê¢ Top ${detectedBottlenecks.length} Bottlenecks</strong></div>`;
        detectedBottlenecks.slice(0, 3).forEach(id => {
          const r = traceData?.resourceMap?.get(id);
          if (r) {
            let time = 0;
            if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
              time += r.callbackEndedAt - r.callbackStartedAt;
            }
            if (r.callbackStartedAt > 0 && r.createdAt > 0) {
              time += r.callbackStartedAt - r.createdAt;
            }
            html += `<div class="detail-item" style="padding-left: 0.5rem; word-wrap: break-word;">#${id} ${r.type} (${(time/1e6).toFixed(1)}ms)</div>`;
          }
        });
      }

      // Show patterns info
      if (showPatterns && detectedPatterns.length > 0) {
        html += `<div class="detail-item" style="color: #c864ff; margin-top: 0.3rem;"><strong>üîç ${detectedPatterns.length} Pattern(s) Found</strong></div>`;
        detectedPatterns.slice(0, 3).forEach(p => {
          const icon = p.type === 'sequential-await' ? '‚ö°' : p.type === 'duplicate-fetch' ? 'üîÑ' : 'üìö';
          html += `<div class="detail-item" style="padding-left: 0.5rem; word-wrap: break-word; line-height: 1.3;">${icon} ${p.message}</div>`;
        });
      }

      // Show temporal edges info
      if (showTemporalEdges && temporalEdges.length > 0) {
        html += `<div class="detail-item" style="color: #50c878; margin-top: 0.3rem;"><strong>‚è±Ô∏è ${temporalEdges.length} Temporal Edge(s)</strong></div>`;
        html += `<div class="detail-item" style="padding-left: 0.5rem; color: #888;">Callbacks that start during another callback</div>`;
      }

      if (!showBottlenecks && !showPatterns && !showTemporalEdges) {
        html = '<div class="detail-item" style="color: #666;">Enable üê¢, üîç, or ‚è±Ô∏è toggles</div>';
      } else if (html === '') {
        html = '<div class="detail-item" style="color: #50c878;">No issues detected!</div>';
      }

      container.innerHTML = html;

      // Update filter status
      if (clickToFilterEnabled && clickFilterResourceId !== null) {
        filterStatus.style.display = 'block';
      } else {
        filterStatus.style.display = 'none';
      }
    }

    // ==================== BOTTLENECK DETECTION ====================
    function toggleBottlenecks(fromHotkey = false) {
      const checkbox = document.getElementById('bottleneck-check');
      if (fromHotkey) {
        showBottlenecks = !showBottlenecks;
        checkbox.checked = showBottlenecks;
      } else {
        showBottlenecks = checkbox.checked;
      }
      updateAnalysisButtonState();
      saveSettings();
      if (traceData) {
        detectBottlenecks();
        updateAnalysisInfo();
        render();
      }
    }

    function detectBottlenecks() {
      if (!traceData) {
        detectedBottlenecks = [];
        return;
      }

      // Find top 5 resources by total time (sync + async wait)
      const resourceTimes = traceData.resources.map(r => {
        let totalTime = 0;
        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          totalTime += r.callbackEndedAt - r.callbackStartedAt;  // sync
        }
        if (r.callbackStartedAt > 0 && r.createdAt > 0) {
          totalTime += r.callbackStartedAt - r.createdAt;  // async wait
        }
        return { resource: r, totalTime };
      }).filter(rt => rt.totalTime > 0);

      resourceTimes.sort((a, b) => b.totalTime - a.totalTime);
      detectedBottlenecks = resourceTimes.slice(0, 5).map(rt => rt.resource.asyncId);
    }

    // ==================== PATTERN DETECTION ====================
    function togglePatterns(fromHotkey = false) {
      const checkbox = document.getElementById('pattern-check');
      if (fromHotkey) {
        showPatterns = !showPatterns;
        checkbox.checked = showPatterns;
      } else {
        showPatterns = checkbox.checked;
      }
      updateAnalysisButtonState();
      saveSettings();
      if (traceData) {
        detectPatterns();
        updateAnalysisInfo();
        render();
      }
    }

    function detectPatterns() {
      if (!traceData) {
        detectedPatterns = [];
        return;
      }

      detectedPatterns = [];

      // Build parent -> children map
      const childrenMap = new Map();
      traceData.resources.forEach(r => {
        if (!childrenMap.has(r.triggerId)) {
          childrenMap.set(r.triggerId, []);
        }
        childrenMap.get(r.triggerId).push(r);
      });

      // Pattern 1: Sequential fetches that could be parallel (Promise.all opportunity)
      // Look for fetch operations that execute one after another in time
      const fetches = traceData.resources.filter(r =>
        r.type === 'fetch' && r.callbackStartedAt > 0 && r.callbackEndedAt > 0
      );

      if (fetches.length >= 2) {
        // Sort by callback start time
        fetches.sort((a, b) => a.callbackStartedAt - b.callbackStartedAt);

        // Find sequential groups (each fetch starts after previous ends)
        let sequentialGroup = [fetches[0]];
        for (let i = 1; i < fetches.length; i++) {
          const prev = fetches[i - 1];
          const curr = fetches[i];
          // Check if current started after previous ended (with small tolerance)
          // Also check if current was CREATED after previous callback ended,
          // which indicates await pattern (not parallel)
          if (curr.createdAt > prev.callbackStartedAt) {
            // This fetch was created after the previous one started executing,
            // suggesting sequential await pattern
            sequentialGroup.push(curr);
          } else {
            // Parallel execution detected, check if previous group was sequential
            if (sequentialGroup.length >= 2) {
              detectedPatterns.push({
                type: 'sequential-await',
                message: `${sequentialGroup.length} sequential fetch operations could use Promise.all()`,
                resources: sequentialGroup.map(s => s.asyncId),
                severity: 'high'
              });
            }
            sequentialGroup = [curr];
          }
        }
        // Check final group
        if (sequentialGroup.length >= 2) {
          detectedPatterns.push({
            type: 'sequential-await',
            message: `${sequentialGroup.length} sequential fetch operations could use Promise.all()`,
            resources: sequentialGroup.map(s => s.asyncId),
            severity: 'high'
          });
        }
      }

      // Pattern 2: Duplicate fetches (same URL)
      const fetchUrls = new Map();
      traceData.resources.forEach(r => {
        if (r.type === 'fetch') {
          const urlAnnotation = (traceData.annotations || []).find(a =>
            a.asyncId === r.asyncId && a.key === 'url'
          );
          if (urlAnnotation) {
            const url = urlAnnotation.value;
            if (!fetchUrls.has(url)) {
              fetchUrls.set(url, []);
            }
            fetchUrls.get(url).push(r.asyncId);
          }
        }
      });

      fetchUrls.forEach((ids, url) => {
        if (ids.length > 1) {
          detectedPatterns.push({
            type: 'duplicate-fetch',
            message: `Duplicate fetch to ${url.substring(0, 40)}...`,
            resources: ids,
            severity: 'medium'
          });
        }
      });

      // Pattern 3: Long promise chains (deep nesting)
      const depths = new Map();
      function getDepth(asyncId) {
        if (depths.has(asyncId)) return depths.get(asyncId);
        const r = traceData.resources.find(res => res.asyncId === asyncId);
        if (!r || r.triggerId === 0) {
          depths.set(asyncId, 0);
          return 0;
        }
        const depth = 1 + getDepth(r.triggerId);
        depths.set(asyncId, depth);
        return depth;
      }

      traceData.resources.forEach(r => getDepth(r.asyncId));

      const maxDepth = Math.max(...depths.values());
      if (maxDepth > 10) {
        const deepResources = traceData.resources
          .filter(r => depths.get(r.asyncId) > 8)
          .map(r => r.asyncId);
        detectedPatterns.push({
          type: 'deep-chain',
          message: `Deep async chain (depth ${maxDepth}) - consider flattening`,
          resources: deepResources,
          severity: 'medium'
        });
      }

      // Pattern 4: Waterfall fetches (fetch triggered by another fetch's result)
      // These are fetches whose trigger chain includes another fetch
      const allFetches = traceData.resources.filter(r => r.type === 'fetch');
      const fetchIds = new Set(allFetches.map(f => f.asyncId));

      allFetches.forEach(fetch => {
        // Walk up the trigger chain to see if we hit another fetch
        let current = fetch;
        let depth = 0;
        while (current && current.triggerId !== 0 && depth < 20) {
          const parent = traceData.resources.find(r => r.asyncId === current.triggerId);
          if (parent && fetchIds.has(parent.asyncId)) {
            detectedPatterns.push({
              type: 'waterfall-fetch',
              message: `Waterfall: fetch #${fetch.asyncId} depends on fetch #${parent.asyncId}`,
              resources: [fetch.asyncId, parent.asyncId],
              severity: 'medium'
            });
            break;
          }
          current = parent;
          depth++;
        }
      });

      // Pattern 5: Unresolved promises (created but callback never started)
      const unresolvedPromises = traceData.resources.filter(r =>
        r.type === 'js-promise' &&
        r.createdAt > 0 &&
        r.callbackStartedAt === 0 &&
        r.destroyedAt === 0  // Still alive at end of request
      );
      if (unresolvedPromises.length > 0) {
        detectedPatterns.push({
          type: 'unresolved-promise',
          message: `${unresolvedPromises.length} promise(s) never resolved`,
          resources: unresolvedPromises.map(r => r.asyncId),
          severity: 'low'
        });
      }

      // Pattern 6: Long async gaps (waiting >threshold before callback)
      const longGapThreshold = patternThresholds.longGapMs * 1e6; // Convert ms to ns
      traceData.resources.forEach(r => {
        if (r.createdAt > 0 && r.callbackStartedAt > 0) {
          const waitTime = r.callbackStartedAt - r.createdAt;
          if (waitTime > longGapThreshold) {
            const waitMs = (waitTime / 1e6).toFixed(0);
            detectedPatterns.push({
              type: 'long-async-gap',
              message: `${r.type} #${r.asyncId} waited ${waitMs}ms before executing`,
              resources: [r.asyncId],
              severity: 'medium'
            });
          }
        }
      });

      // Pattern 7: Redundant timers (multiple timers with similar delays created together)
      const timers = traceData.resources.filter(r => r.type === 'timer');
      if (timers.length >= 2) {
        // Group timers by approximate delay (within 10ms) and creation time (within 5ms)
        const timerGroups = new Map();
        timers.forEach(t => {
          // Estimate delay from creation to callback
          const delay = t.callbackStartedAt > 0 ? t.callbackStartedAt - t.createdAt : 0;
          const delayBucket = Math.round(delay / 10e6) * 10; // Round to 10ms
          const createBucket = Math.round(t.createdAt / 5e6) * 5; // Round to 5ms
          const key = `${delayBucket}-${createBucket}`;
          if (!timerGroups.has(key)) timerGroups.set(key, []);
          timerGroups.get(key).push(t);
        });

        timerGroups.forEach((group, key) => {
          if (group.length >= 2) {
            detectedPatterns.push({
              type: 'redundant-timers',
              message: `${group.length} timers with similar delay created together`,
              resources: group.map(t => t.asyncId),
              severity: 'low'
            });
          }
        });
      }

      // Pattern 8: Cache misses (cache-get with long wait, suggesting network fetch)
      const cacheGets = traceData.resources.filter(r => r.type === 'cache-get');
      const cacheMissThreshold = 50 * 1e6; // 50ms suggests a miss (hit would be faster)
      cacheGets.forEach(cg => {
        if (cg.callbackStartedAt > 0 && cg.createdAt > 0) {
          const waitTime = cg.callbackStartedAt - cg.createdAt;
          if (waitTime > cacheMissThreshold) {
            const waitMs = (waitTime / 1e6).toFixed(0);
            detectedPatterns.push({
              type: 'cache-miss',
              message: `Cache miss: ${waitMs}ms wait suggests origin fetch`,
              resources: [cg.asyncId],
              severity: 'low'
            });
          }
        }
      });

      // ==================== NEW PATTERNS ====================

      // Pattern 9: Event loop blocking (sync execution > threshold)
      const syncBlockThreshold = patternThresholds.syncBlockMs * 1e6;
      traceData.resources.forEach(r => {
        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          const syncTime = r.callbackEndedAt - r.callbackStartedAt;
          if (syncTime > syncBlockThreshold) {
            detectedPatterns.push({
              type: 'sync-flood',
              message: `Event loop blocked: ${r.type} #${r.asyncId} ran ${(syncTime/1e6).toFixed(0)}ms sync`,
              resources: [r.asyncId],
              severity: 'high'
            });
          }
        }
      });

      // Pattern 10: Promise accumulation (many promises in short window)
      const promiseBuckets = new Map();
      traceData.resources.filter(r => r.type === 'js-promise').forEach(r => {
        const bucket = Math.floor(r.createdAt / 1e6); // 1ms buckets
        if (!promiseBuckets.has(bucket)) promiseBuckets.set(bucket, []);
        promiseBuckets.get(bucket).push(r.asyncId);
      });
      promiseBuckets.forEach((ids, bucket) => {
        if (ids.length >= patternThresholds.promiseFlood) {
          detectedPatterns.push({
            type: 'promise-flood',
            message: `Promise accumulation: ${ids.length} promises created within 1ms`,
            resources: ids,
            severity: 'medium'
          });
        }
      });

      // Pattern 11: Callback storm (many callbacks starting in short window)
      const callbackBuckets = new Map();
      traceData.resources.filter(r => r.callbackStartedAt > 0).forEach(r => {
        const bucket = Math.floor(r.callbackStartedAt / 1e6);
        if (!callbackBuckets.has(bucket)) callbackBuckets.set(bucket, []);
        callbackBuckets.get(bucket).push(r.asyncId);
      });
      callbackBuckets.forEach((ids, bucket) => {
        if (ids.length >= patternThresholds.callbackStorm) {
          detectedPatterns.push({
            type: 'callback-storm',
            message: `Callback storm: ${ids.length} callbacks fired within 1ms`,
            resources: ids,
            severity: 'medium'
          });
        }
      });

      // Pattern 12: Unbatched KV/DO operations
      const batchableTypes = ['kv-get', 'kv-put', 'kv-delete', 'do-get', 'do-put', 'do-delete'];
      batchableTypes.forEach(opType => {
        const ops = traceData.resources.filter(r => r.type === opType);
        if (ops.length < patternThresholds.unbatchedOps) return;

        // Group by creation time proximity (5ms window)
        const groups = [];
        let currentGroup = [];
        ops.sort((a, b) => a.createdAt - b.createdAt).forEach(op => {
          if (currentGroup.length === 0 || op.createdAt - currentGroup[0].createdAt < 5e6) {
            currentGroup.push(op);
          } else {
            if (currentGroup.length >= patternThresholds.unbatchedOps) groups.push([...currentGroup]);
            currentGroup = [op];
          }
        });
        if (currentGroup.length >= patternThresholds.unbatchedOps) groups.push(currentGroup);

        groups.forEach(group => {
          detectedPatterns.push({
            type: 'unbatched-ops',
            message: `Unbatched: ${group.length} ${opType} operations could be batched`,
            resources: group.map(r => r.asyncId),
            severity: 'high'
          });
        });
      });

      // Pattern 13: Concurrent fetch risk (too many parallel fetches)
      const fetchEvents = [];
      traceData.resources.filter(r => r.type === 'fetch').forEach(f => {
        if (f.createdAt > 0) fetchEvents.push({ time: f.createdAt, delta: 1, id: f.asyncId });
        const endTime = f.callbackEndedAt > 0 ? f.callbackEndedAt :
                        (f.destroyedAt > 0 ? f.destroyedAt : traceData.requestDurationNs);
        fetchEvents.push({ time: endTime, delta: -1, id: f.asyncId });
      });
      if (fetchEvents.length > 0) {
        fetchEvents.sort((a, b) => a.time - b.time);
        let concurrent = 0;
        let maxConcurrent = 0;
        let maxConcurrentFetches = [];
        let activeFetches = [];
        fetchEvents.forEach(e => {
          if (e.delta > 0) {
            activeFetches.push(e.id);
          } else {
            activeFetches = activeFetches.filter(id => id !== e.id);
          }
          concurrent += e.delta;
          if (concurrent > maxConcurrent) {
            maxConcurrent = concurrent;
            maxConcurrentFetches = [...activeFetches];
          }
        });
        if (maxConcurrent >= patternThresholds.fetchFlood) {
          detectedPatterns.push({
            type: 'fetch-flood',
            message: `High fetch concurrency: ${maxConcurrent} parallel fetches (connection limit risk)`,
            resources: maxConcurrentFetches,
            severity: 'medium'
          });
        }
      }

      // Pattern 14: Hot callback (single callback spawning many children)
      const childCounts = new Map();
      traceData.resources.forEach(r => {
        if (r.triggerId !== 0) {
          childCounts.set(r.triggerId, (childCounts.get(r.triggerId) || 0) + 1);
        }
      });
      childCounts.forEach((count, parentId) => {
        if (count > patternThresholds.hotCallback) {
          const parent = traceData.resourceMap.get(parentId);
          if (parent) {
            detectedPatterns.push({
              type: 'hot-callback',
              message: `Hot callback: ${parent.type} #${parentId} spawned ${count} children`,
              resources: [parentId],
              severity: 'low'
            });
          }
        }
      });

      // Deduplicate patterns by resource set
      const seen = new Set();
      detectedPatterns = detectedPatterns.filter(p => {
        const key = p.resources.sort().join(',');
        if (seen.has(key)) return false;
        seen.add(key);
        return true;
      });
    }

    // Get severity-based pattern style for a resource
    function getPatternSeverity(asyncId) {
      if (!showPatterns) return null;
      const pattern = detectedPatterns.find(p => p.resources.includes(asyncId));
      if (!pattern) return null;
      return pattern.severity || 'medium';
    }

    // Get severity-based styling colors and sizes
    function getPatternStyle(severity) {
      switch (severity) {
        case 'high':
          return { color: '#ff00ff', glow: 15, lineWidth: 3, alpha: 0.9 };
        case 'medium':
          return { color: '#cc66ff', glow: 10, lineWidth: 2, alpha: 0.7 };
        case 'low':
          return { color: '#9966cc', glow: 6, lineWidth: 1.5, alpha: 0.5 };
        default:
          return { color: '#cc66ff', glow: 10, lineWidth: 2, alpha: 0.7 };
      }
    }

    // Get all patterns that include a given resource
    function getPatternsForResource(asyncId) {
      if (!showPatterns || !detectedPatterns.length) return [];
      return detectedPatterns.filter(p => p.resources.includes(asyncId));
    }

    // Generate HTML for pattern list in tooltips
    function getPatternTooltipHTML(asyncId) {
      const patterns = getPatternsForResource(asyncId);
      if (patterns.length === 0) return '';

      const severityColors = {
        high: '#ff00ff',
        medium: '#cc66ff',
        low: '#9966cc'
      };
      const severityIcons = {
        high: 'üî¥',
        medium: 'üü°',
        low: 'üü¢'
      };

      const patternItems = patterns.map(p => {
        const severity = p.severity || 'medium';
        const color = severityColors[severity];
        const icon = severityIcons[severity];
        return `<div style="color: ${color}; font-size: 0.65rem;">${icon} ${p.type}: ${p.message.substring(0, 50)}${p.message.length > 50 ? '...' : ''}</div>`;
      }).join('');

      return `<div style="margin-top: 0.4rem; border-top: 1px solid #333; padding-top: 0.3rem;">
        <div style="font-weight: bold; font-size: 0.7rem; color: #e94560;">Detected Patterns:</div>
        ${patternItems}
      </div>`;
    }

    function getCriticalPathTooltipHTML(asyncId) {
      if (!showCriticalPath || !criticalPathSet.has(asyncId)) return '';
      if (!criticalPathInfo || !criticalPathInfo.path) return '';

      // Find position in critical path
      const path = criticalPathInfo.path;
      const pathIndex = path.findIndex(id => id === asyncId);
      const positionText = pathIndex >= 0
        ? `Step ${pathIndex + 1} of ${path.length}`
        : 'On critical path';

      return `<div style="margin-top: 0.4rem; border-top: 1px solid #333; padding-top: 0.3rem;">
        <div style="font-weight: bold; font-size: 0.7rem; color: #ff6432;">üî• Critical Path</div>
        <div style="font-size: 0.65rem; color: #ff8c5a;">${positionText}</div>
      </div>`;
    }

    // ==================== CLICK-TO-FILTER ====================
    function toggleClickFilter(fromHotkey = false) {
      const checkbox = document.getElementById('click-filter-check');
      if (fromHotkey) {
        clickToFilterEnabled = !clickToFilterEnabled;
        checkbox.checked = clickToFilterEnabled;
      } else {
        clickToFilterEnabled = checkbox.checked;
      }
      if (!clickToFilterEnabled) {
        clickFilterResourceId = null;
      }
      // Invalidate layout caches when filter changes
      dagNodes = [];
      updateAnalysisInfo();
      updateAnalysisButtonState();
      saveSettings();
      if (traceData) render();
    }

    function applyClickFilter(asyncId) {
      clickFilterResourceId = asyncId;
      // Invalidate layout caches when filter changes
      dagNodes = [];
      updateAnalysisInfo();
      render();
    }

    function getAncestors(asyncId) {
      const ancestors = new Set();
      let current = traceData.resources.find(r => r.asyncId === asyncId);
      while (current && current.triggerId !== 0) {
        ancestors.add(current.triggerId);
        current = traceData.resources.find(r => r.asyncId === current.triggerId);
      }
      return ancestors;
    }

    function getDescendants(asyncId) {
      const descendants = new Set();
      const queue = [asyncId];
      while (queue.length > 0) {
        const id = queue.shift();
        traceData.resources.forEach(r => {
          if (r.triggerId === id && !descendants.has(r.asyncId)) {
            descendants.add(r.asyncId);
            queue.push(r.asyncId);
          }
        });
      }
      return descendants;
    }

    function isResourceVisible(asyncId) {
      if (!clickToFilterEnabled || clickFilterResourceId === null) return true;
      if (asyncId === clickFilterResourceId) return true;
      const ancestors = getAncestors(clickFilterResourceId);
      const descendants = getDescendants(clickFilterResourceId);
      return ancestors.has(asyncId) || descendants.has(asyncId);
    }

    // ==================== STACK TRACE GROUPING ====================
    function toggleStackGrouping(fromHotkey = false) {
      const checkbox = document.getElementById('stack-group-check');
      if (fromHotkey) {
        stackTraceGrouping = !stackTraceGrouping;
        checkbox.checked = stackTraceGrouping;
      } else {
        stackTraceGrouping = checkbox.checked;
      }
      updateAnalysisButtonState();
      saveSettings();
      if (traceData) render();
    }

    function getStackGroups() {
      if (!traceData || !traceData.stackTraces) return new Map();

      const groups = new Map();
      traceData.resources.forEach(r => {
        const stackId = r.stackTraceId || 0;
        if (!groups.has(stackId)) {
          const stack = traceData.stackTraces.find(s => s.id === stackId);
          groups.set(stackId, {
            stackId,
            frames: stack ? stack.frames : [],
            resources: [],
            totalTime: 0
          });
        }
        const group = groups.get(stackId);
        group.resources.push(r);

        // Calculate time
        let time = 0;
        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          time += r.callbackEndedAt - r.callbackStartedAt;
        }
        if (r.callbackStartedAt > 0 && r.createdAt > 0) {
          time += r.callbackStartedAt - r.createdAt;
        }
        group.totalTime += time;
      });

      return groups;
    }

    // ==================== TEMPORAL EDGES ====================
    // Show edges based on callback timing: if resource B's callback starts
    // during resource A's callback, draw an edge from A to B.
    function toggleTemporalEdges(fromHotkey = false) {
      const checkbox = document.getElementById('temporal-edges-check');
      if (fromHotkey) {
        showTemporalEdges = !showTemporalEdges;
        checkbox.checked = showTemporalEdges;
      } else {
        showTemporalEdges = checkbox.checked;
      }
      updateAnalysisButtonState();
      saveSettings();
      if (traceData) {
        computeTemporalEdges();
        render();
      }
    }

    // ==================== HIDE INTERNAL ====================
    // Hide internal runtime machinery to focus on user code
    function toggleHideInternal(fromHotkey = false) {
      const checkbox = document.getElementById('hide-internal-check');
      if (fromHotkey) {
        hideInternal = !hideInternal;
        checkbox.checked = hideInternal;
      } else {
        hideInternal = checkbox.checked;
      }
      dagNodes = [];  // Re-initialize DAG when filter changes
      updateAnalysisButtonState();
      saveSettings();
      render();
    }

    function computeTemporalEdges() {
      if (!traceData) {
        temporalEdges = [];
        return;
      }

      temporalEdges = [];

      // Find resources with callback timing
      const withCallbacks = traceData.resources.filter(r =>
        r.callbackStartedAt > 0 && r.callbackEndedAt > 0
      );

      // For each resource with a callback, find other resources whose callbacks
      // START during this resource's callback window
      withCallbacks.forEach(parent => {
        withCallbacks.forEach(child => {
          if (parent.asyncId === child.asyncId) return;
          // Skip if there's already a triggerId relationship
          if (child.triggerId === parent.asyncId) return;

          // Check if child's callback starts during parent's callback
          if (child.callbackStartedAt >= parent.callbackStartedAt &&
              child.callbackStartedAt < parent.callbackEndedAt) {
            temporalEdges.push({
              from: parent.asyncId,
              to: child.asyncId,
              // Delay from parent callback start to child callback start
              delay: child.callbackStartedAt - parent.callbackStartedAt
            });
          }
        });
      });

      // Sort by from, then by delay for consistent rendering
      temporalEdges.sort((a, b) => {
        if (a.from !== b.from) return a.from - b.from;
        return a.delay - b.delay;
      });
    }

    function updateStats() {
      let totalSync = 0, totalAsync = 0;
      traceData.resources.forEach(r => {
        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          totalSync += r.callbackEndedAt - r.callbackStartedAt;
        }
        if (r.callbackStartedAt > 0 && r.createdAt > 0) {
          totalAsync += r.callbackStartedAt - r.createdAt;
        }
      });
      // Cache for sidebar re-renders
      cachedTotalSync = totalSync;
      cachedTotalAsync = totalAsync;

      document.getElementById('stat-duration').textContent = (traceData.requestDurationNs / 1e6).toFixed(1);
      document.getElementById('stat-resources').textContent = traceData.resources.length;
      document.getElementById('stat-sync').textContent = (totalSync / 1e6).toFixed(1);
      document.getElementById('stat-async').textContent = (totalAsync / 1e6).toFixed(1);

      // Render summary charts
      renderTimelineChart();
      renderTypeChart();
      renderTimeBreakdownChart(totalSync, totalAsync);
    }

    function renderTimelineChart() {
      const canvas = document.getElementById('timeline-chart');
      const ctx = canvas.getContext('2d');
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = 40 * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

      const width = rect.width;
      const height = 40;
      const duration = traceData.requestDurationNs;
      const bucketCount = Math.floor(width / 3);
      const buckets = new Array(bucketCount).fill(0);
      const syncBuckets = new Array(bucketCount).fill(0);

      // Count activity per time bucket
      traceData.resources.forEach(r => {
        const start = r.createdAt;
        const end = r.callbackEndedAt > 0 ? r.callbackEndedAt : (r.destroyedAt > 0 ? r.destroyedAt : duration);
        const startBucket = Math.floor((start / duration) * bucketCount);
        const endBucket = Math.min(bucketCount - 1, Math.floor((end / duration) * bucketCount));

        for (let i = startBucket; i <= endBucket; i++) {
          if (i >= 0 && i < bucketCount) buckets[i]++;
        }

        // Track sync time separately
        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          const syncStart = Math.floor((r.callbackStartedAt / duration) * bucketCount);
          const syncEnd = Math.min(bucketCount - 1, Math.floor((r.callbackEndedAt / duration) * bucketCount));
          for (let i = syncStart; i <= syncEnd; i++) {
            if (i >= 0 && i < bucketCount) syncBuckets[i]++;
          }
        }
      });

      const maxCount = Math.max(...buckets, 1);
      const barWidth = width / bucketCount;

      ctx.fillStyle = '#0f3460';
      ctx.fillRect(0, 0, width, height);

      // Draw async activity (all resources active)
      ctx.fillStyle = 'rgba(126, 200, 227, 0.4)';
      buckets.forEach((count, i) => {
        const barHeight = (count / maxCount) * (height - 4);
        ctx.fillRect(i * barWidth, height - 2 - barHeight, barWidth - 1, barHeight);
      });

      // Draw sync activity overlay
      ctx.fillStyle = 'rgba(233, 69, 96, 0.8)';
      syncBuckets.forEach((count, i) => {
        const barHeight = (count / maxCount) * (height - 4);
        ctx.fillRect(i * barWidth, height - 2 - barHeight, barWidth - 1, barHeight);
      });

      // Draw time markers
      ctx.fillStyle = '#666';
      ctx.font = '8px sans-serif';
      ctx.textAlign = 'center';
      for (let i = 0; i <= 4; i++) {
        const x = (i / 4) * width;
        const time = (i / 4) * duration / 1e6;
        ctx.fillText(time.toFixed(0) + 'ms', x, 10);
      }

      // Draw replay playhead when replay is active
      if (currentView === 'replay' && replayTime > 0 && duration > 0) {
        const playheadX = (replayTime / duration) * width;
        ctx.strokeStyle = 'rgba(233, 69, 96, 0.6)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(playheadX, 0);
        ctx.lineTo(playheadX, height);
        ctx.stroke();
      }
    }

    function renderTypeChart() {
      const canvas = document.getElementById('type-chart');
      const ctx = canvas.getContext('2d');
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = 80 * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

      const width = rect.width;
      const height = 80;

      // Count by type and calculate sync time per type
      const typeCounts = new Map();
      const typeSyncTime = new Map();
      traceData.resources.forEach(r => {
        typeCounts.set(r.type, (typeCounts.get(r.type) || 0) + 1);
        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          typeSyncTime.set(r.type, (typeSyncTime.get(r.type) || 0) + (r.callbackEndedAt - r.callbackStartedAt));
        }
      });

      const types = Array.from(typeCounts.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 6);

      const maxCount = Math.max(...types.map(t => t[1]), 1);
      const barHeight = (height - 20) / types.length;

      ctx.fillStyle = '#0f3460';
      ctx.fillRect(0, 0, width, height);

      // Draw horizontal bars
      types.forEach(([type, count], i) => {
        const y = 4 + i * barHeight;
        const barWidth = ((count / maxCount) * (width - 60));

        ctx.fillStyle = TYPE_COLORS[type] || '#808080';
        ctx.globalAlpha = 0.8;
        ctx.fillRect(55, y + 2, barWidth, barHeight - 4);
        ctx.globalAlpha = 1;

        // Type label
        ctx.fillStyle = '#aaa';
        ctx.font = '9px sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText(type.replace('js-', '').substring(0, 7), 52, y + barHeight / 2 + 3);

        // Count label
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'left';
        ctx.fillText(count.toString(), barWidth + 58, y + barHeight / 2 + 3);
      });

      // Update breakdown text
      const breakdown = document.getElementById('type-breakdown');
      const totalSyncTime = Array.from(typeSyncTime.values()).reduce((a, b) => a + b, 0);
      breakdown.innerHTML = types.map(([type, count]) => {
        const syncTime = typeSyncTime.get(type) || 0;
        const pct = totalSyncTime > 0 ? ((syncTime / totalSyncTime) * 100).toFixed(0) : 0;
        return `<span style="color: ${TYPE_COLORS[type] || '#808080'}">‚óè</span> ${type}: ${count} (${pct}% CPU)`;
      }).join('<br>');
    }

    function renderTimeBreakdownChart(totalSync, totalAsync) {
      const canvas = document.getElementById('time-chart');
      const ctx = canvas.getContext('2d');
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = 24 * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

      const width = rect.width;
      const height = 24;
      const total = totalSync + totalAsync;

      if (total === 0) return;

      const syncWidth = (totalSync / total) * width;
      const asyncWidth = (totalAsync / total) * width;

      // Async portion (waiting)
      ctx.fillStyle = 'rgba(126, 200, 227, 0.6)';
      ctx.fillRect(0, 0, asyncWidth, height);

      // Sync portion (executing)
      ctx.fillStyle = '#e94560';
      ctx.fillRect(asyncWidth, 0, syncWidth, height);

      // Labels
      ctx.fillStyle = '#fff';
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'center';

      if (asyncWidth > 50) {
        ctx.fillText(`Async ${(totalAsync / 1e6).toFixed(1)}ms`, asyncWidth / 2, height / 2 + 4);
      }
      if (syncWidth > 50) {
        ctx.fillText(`Sync ${(totalSync / 1e6).toFixed(1)}ms`, asyncWidth + syncWidth / 2, height / 2 + 4);
      }

      // Update breakdown text
      const syncPct = ((totalSync / total) * 100).toFixed(0);
      const asyncPct = ((totalAsync / total) * 100).toFixed(0);
      document.getElementById('time-breakdown').innerHTML =
        `<span style="color: #7ec8e3;">‚ñ†</span> Async wait: ${asyncPct}% | ` +
        `<span style="color: #e94560;">‚ñ†</span> Sync exec: ${syncPct}%`;
    }

    function renderRuntimeOverheadChart() {
      if (!traceData) return;

      // Calculate time by classification
      // 'typed' = API calls (fetch, cache, etc.) - user-initiated
      // 'user' = User code promises (have stack traces)
      // 'internal' = Runtime overhead (no stack, internal machinery)
      const timeByClass = {
        typed: { sync: 0, async: 0, count: 0 },
        user: { sync: 0, async: 0, count: 0 },
        internal: { sync: 0, async: 0, count: 0 }
      };

      traceData.resources.forEach(r => {
        const cls = r._classification || 'internal';
        if (!timeByClass[cls]) return;

        timeByClass[cls].count++;

        // Sync time (callback execution)
        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          timeByClass[cls].sync += r.callbackEndedAt - r.callbackStartedAt;
        }

        // Async time (waiting for callback)
        if (r.createdAt > 0 && r.callbackStartedAt > 0) {
          timeByClass[cls].async += r.callbackStartedAt - r.createdAt;
        }
      });

      // Calculate totals
      const userTime = timeByClass.typed.sync + timeByClass.typed.async +
                       timeByClass.user.sync + timeByClass.user.async;
      const runtimeTime = timeByClass.internal.sync + timeByClass.internal.async;
      const totalTime = userTime + runtimeTime;

      // Render chart
      const canvas = document.getElementById('overhead-chart');
      const ctx = canvas.getContext('2d');
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = 24 * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

      const width = rect.width;
      const height = 24;

      if (totalTime === 0) {
        ctx.fillStyle = '#333';
        ctx.fillRect(0, 0, width, height);
        document.getElementById('overhead-breakdown').innerHTML =
          '<div style="color: #666;">No timing data available</div>';
        return;
      }

      const userWidth = (userTime / totalTime) * width;
      const runtimeWidth = (runtimeTime / totalTime) * width;

      // User code portion (green)
      ctx.fillStyle = '#50c878';
      ctx.fillRect(0, 0, userWidth, height);

      // Runtime overhead portion (orange)
      ctx.fillStyle = '#ff8c00';
      ctx.fillRect(userWidth, 0, runtimeWidth, height);

      // Labels
      ctx.fillStyle = '#fff';
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'center';

      if (userWidth > 50) {
        ctx.fillText(`User ${(userTime / 1e6).toFixed(1)}ms`, userWidth / 2, height / 2 + 4);
      }
      if (runtimeWidth > 40) {
        ctx.fillText(`Runtime ${(runtimeTime / 1e6).toFixed(1)}ms`, userWidth + runtimeWidth / 2, height / 2 + 4);
      }

      // Update breakdown text with detailed stats
      const userPct = ((userTime / totalTime) * 100).toFixed(0);
      const runtimePct = ((runtimeTime / totalTime) * 100).toFixed(0);
      const userCount = timeByClass.typed.count + timeByClass.user.count;
      const runtimeCount = timeByClass.internal.count;

      document.getElementById('overhead-breakdown').innerHTML =
        `<span style="color: #50c878;">‚ñ†</span> User: ${userPct}% (${userCount} ops)<br>` +
        `<span style="color: #ff8c00;">‚ñ†</span> Runtime: ${runtimePct}% (${runtimeCount} ops)` +
        `<div style="margin-top: 0.25rem; font-size: 0.6rem; color: #888;">` +
        `API: ${timeByClass.typed.count} | User promises: ${timeByClass.user.count} | Internal: ${timeByClass.internal.count}` +
        `</div>`;
    }

    function updateLegend() {
      const types = new Set(traceData.resources.map(r => r.type));
      const legend = document.getElementById('legend');
      legend.innerHTML = '';
      types.forEach(type => {
        const item = document.createElement('div');
        item.className = 'legend-item';
        item.innerHTML = `<div class="legend-color" style="background: ${TYPE_COLORS[type] || '#808080'}"></div><span>${type}</span>`;
        legend.appendChild(item);
      });
    }

    function render() {
      if (currentView === 'waterfall') {
        renderWaterfall();
      } else if (currentView === 'dag') {
        renderDAG();
      } else if (currentView === 'parallelism') {
        renderParallelism();
      } else if (currentView === 'breakdown') {
        renderBreakdown();
      } else if (currentView === 'latency') {
        renderLatency();
      } else if (currentView === 'gaps') {
        renderGaps();
      } else if (currentView === 'replay') {
        renderReplayFrame();
      } else if (currentView === 'heatmap') {
        renderHeatmap();
      }
    }

    function updateViewHelp() {
      document.querySelectorAll('.view-help').forEach(el => {
        const view = el.dataset.view;
        el.classList.toggle('active', view === currentView || view === 'all');
      });
    }

    function updateControlStates() {
      // Controls are now in their respective views, nothing to update
    }

    // ==================== WATERFALL VIEW ====================
    // Track row positions for dependency arrows
    let waterfallRowPositions = new Map();
    let waterfallTimelineWidth = 0;
    let waterfallDuration = 0;

    function renderWaterfall() {
      document.getElementById('waterfall-empty').style.display = 'none';
      document.getElementById('waterfall-container').style.display = 'block';

      const container = document.getElementById('waterfall');
      container.innerHTML = '';
      waterfallRowPositions.clear();

      const sortMode = document.getElementById('sort-mode').value;
      let sorted = [...traceData.resources];

      if (sortMode === 'creation') {
        sorted.sort((a, b) => a.createdAt - b.createdAt);
      } else if (sortMode === 'duration') {
        sorted.sort((a, b) => {
          const durA = (a.callbackEndedAt || a.destroyedAt || traceData.requestDurationNs) - a.createdAt;
          const durB = (b.callbackEndedAt || b.destroyedAt || traceData.requestDurationNs) - b.createdAt;
          return durB - durA;
        });
      } else {
        sorted = [];
        function addToTree(id) {
          const r = traceData.resourceMap.get(id);
          if (r) {
            sorted.push(r);
            const children = (traceData.childrenMap.get(id) || []).slice().sort((a, b) => {
              return traceData.resourceMap.get(a).createdAt - traceData.resourceMap.get(b).createdAt;
            });
            children.forEach(addToTree);
          }
        }
        const root = traceData.resources.find(r => r.type === 'root');
        if (root) addToTree(root.asyncId);
        traceData.resources.forEach(r => { if (!sorted.includes(r)) sorted.push(r); });
      }

      const duration = traceData.requestDurationNs;
      const timelineWidth = Math.max(600, container.clientWidth - 200);
      waterfallDuration = duration;
      waterfallTimelineWidth = timelineWidth;

      // Time axis
      const axis = document.createElement('div');
      axis.className = 'time-axis';
      axis.style.width = (180 + timelineWidth) + 'px';
      for (let i = 0; i <= 10; i++) {
        const tick = document.createElement('div');
        tick.className = 'time-tick';
        tick.style.left = (180 + (i / 10) * timelineWidth) + 'px';
        tick.textContent = ((i / 10) * duration / 1e6).toFixed(1) + 'ms';
        axis.appendChild(tick);
      }
      container.appendChild(axis);

      // Rows
      sorted.forEach(r => {
        if (!shouldShowResource(r)) return;
        // Apply click-to-filter visibility
        if (clickToFilterEnabled && clickFilterResourceId !== null && !isResourceVisible(r.asyncId)) return;

        // Create wrapper for row + stack trace panel
        const wrapper = document.createElement('div');
        wrapper.className = 'resource-row-wrapper';

        const row = document.createElement('div');
        row.className = 'resource-row';
        row.dataset.asyncId = r.asyncId;
        if (selectedResource && selectedResource.asyncId === r.asyncId) row.classList.add('selected');
        if (highlightedChain.has(r.asyncId)) row.classList.add('highlighted');
        if (showCriticalPath && criticalPathSet.has(r.asyncId)) row.classList.add('critical-path');
        if (r._classification === 'internal') row.classList.add('internal');
        // Bottleneck highlighting
        if (showBottlenecks && detectedBottlenecks.includes(r.asyncId)) row.classList.add('bottleneck');
        // Pattern highlighting (severity-based)
        if (showPatterns) {
          const patternMatch = detectedPatterns.find(p => p.resources.includes(r.asyncId));
          if (patternMatch) {
            row.classList.add('pattern-match');
            row.classList.add(`pattern-${patternMatch.severity || 'medium'}`);
          }
        }

        // Hover highlighting for parent/children
        row.addEventListener('mouseenter', () => highlightRelatedRows(r.asyncId));
        row.addEventListener('mouseleave', () => clearRelatedHighlights());

        // Stack trace expand button
        const st = traceData.stackTraceMap.get(r.stackTraceId);
        const hasStack = st && st.frames && st.frames.length > 0;
        const expandBtn = document.createElement('div');
        expandBtn.className = 'stack-trace-expand' + (hasStack ? '' : ' no-stack');
        expandBtn.textContent = expandedStackTraces.has(r.asyncId) ? '‚ñº' : '‚ñ∂';
        if (expandedStackTraces.has(r.asyncId)) expandBtn.classList.add('expanded');
        row.appendChild(expandBtn);

        const label = document.createElement('div');
        label.className = 'resource-label';

        const depth = traceData.depthMap.get(r.asyncId) || 0;
        if (sortMode === 'tree' && depth > 0) {
          for (let i = 0; i < depth; i++) {
            const indent = document.createElement('span');
            indent.className = 'indent';
            label.appendChild(indent);
          }
        }

        const badge = document.createElement('span');
        badge.className = 'type-badge';
        badge.style.background = TYPE_COLORS[r.type] || '#808080';
        badge.textContent = r.type.replace('js-', '').substring(0, 5);
        label.appendChild(badge);

        const idSpan = document.createElement('span');
        idSpan.textContent = ` #${r.asyncId}`;
        idSpan.style.color = '#888';
        label.appendChild(idSpan);

        row.appendChild(label);

        const timeline = document.createElement('div');
        timeline.className = 'resource-timeline';
        timeline.style.width = timelineWidth + 'px';

        const bar = document.createElement('div');
        bar.className = 'resource-bar';

        const startTime = r.createdAt;
        const endTime = r.callbackEndedAt > 0 ? r.callbackEndedAt : (r.destroyedAt > 0 ? r.destroyedAt : duration);
        const left = (startTime / duration) * timelineWidth;
        const width = Math.max(2, ((endTime - startTime) / duration) * timelineWidth);

        bar.style.left = left + 'px';
        bar.style.width = width + 'px';
        bar.style.background = TYPE_COLORS[r.type] || '#808080';

        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          const asyncWait = r.callbackStartedAt - r.createdAt;
          const syncTime = r.callbackEndedAt - r.callbackStartedAt;
          const total = endTime - startTime;

          // Build tooltip for callback marker
          let markerTooltip = `Callback fired at ${(r.callbackStartedAt / 1e6).toFixed(2)}ms`;
          if (r.type === 'timer') {
            const delayAnnotation = (traceData.annotations || []).find(a => a.asyncId === r.asyncId && a.key === 'delay');
            if (delayAnnotation) {
              markerTooltip += ` (${delayAnnotation.value}ms delay)`;
            }
          }

          if (asyncWait > 0 && total > 0) {
            const asyncDiv = document.createElement('div');
            asyncDiv.className = 'async-wait';
            asyncDiv.style.width = ((asyncWait / total) * 100) + '%';
            asyncDiv.style.background = TYPE_COLORS[r.type] || '#808080';
            bar.appendChild(asyncDiv);
          }

          // Insert callback marker as inline element between async-wait and sync-time
          if (total > 0) {
            const marker = document.createElement('div');
            marker.className = 'callback-marker';
            marker.style.cssText = `width: 6px; height: 100%; background: linear-gradient(90deg, transparent 2px, #000 2px, #000 4px, transparent 4px); flex-shrink: 0; `;
            marker.title = markerTooltip;
            bar.appendChild(marker);
          }

          if (syncTime > 0 && total > 0) {
            const syncDiv = document.createElement('div');
            syncDiv.className = 'sync-time';
            syncDiv.style.width = ((syncTime / total) * 100) + '%';
            syncDiv.style.background = TYPE_COLORS[r.type] || '#808080';
            bar.appendChild(syncDiv);

            // Add callback end marker
            const endMarker = document.createElement('div');
            endMarker.className = 'callback-end-marker';
            endMarker.style.cssText = `width: 6px; height: 100%; background: linear-gradient(90deg, transparent 2px, #000 2px, #000 4px, transparent 4px); flex-shrink: 0; `;
            endMarker.title = `Callback ended at ${(r.callbackEndedAt / 1e6).toFixed(2)}ms (${(syncTime / 1e6).toFixed(2)}ms sync time)`;
            bar.appendChild(endMarker);
          }
        }

        const totalMs = (endTime - startTime) / 1e6;
        if (totalMs >= 0.5 && width > 30) {
          const barLabel = document.createElement('span');
          barLabel.className = 'bar-label';
          barLabel.textContent = totalMs.toFixed(1) + 'ms';
          bar.appendChild(barLabel);
        }

        // Add temporal edge indicators if enabled
        if (showTemporalEdges && temporalEdges.length > 0) {
          const outgoing = temporalEdges.filter(e => e.from === r.asyncId);
          const incoming = temporalEdges.filter(e => e.to === r.asyncId);

          if (outgoing.length > 0 || incoming.length > 0) {
            const edgeIndicator = document.createElement('div');
            edgeIndicator.className = 'temporal-edge-indicator';
            edgeIndicator.style.cssText = `position: absolute; right: 4px; top: 50%; transform: translateY(-50%); font-size: 10px; font-weight: bold; color: #fff; background: #2a9d4a; padding: 1px 4px; border-radius: 3px; pointer-events: auto;`;

            let tooltipParts = [];
            if (outgoing.length > 0) {
              tooltipParts.push(`Spawns ${outgoing.length} callback(s): #${outgoing.map(e => e.to).join(', #')}`);
            }
            if (incoming.length > 0) {
              const parent = traceData.resourceMap.get(incoming[0].from);
              tooltipParts.push(`Started during #${incoming[0].from} (${parent ? parent.type : 'unknown'})`);
            }
            edgeIndicator.title = tooltipParts.join('\n');

            if (outgoing.length > 0 && incoming.length > 0) {
              edgeIndicator.textContent = `‚è±‚Üî${outgoing.length}`;
            } else if (outgoing.length > 0) {
              edgeIndicator.textContent = `‚è±‚Üí${outgoing.length}`;
            } else {
              edgeIndicator.textContent = `‚è±‚Üê`;
            }
            bar.appendChild(edgeIndicator);
          }
        }

        bar.addEventListener('click', () => {
          selectResource(r);
          // Handle click-to-filter
          if (clickToFilterEnabled) {
            applyClickFilter(r.asyncId);
          }
        });
        timeline.appendChild(bar);
        row.appendChild(timeline);
        wrapper.appendChild(row);

        // Create stack trace panel
        const stackPanel = document.createElement('div');
        stackPanel.className = 'stack-trace-panel' + (expandedStackTraces.has(r.asyncId) ? ' show' : '');
        if (hasStack) {
          st.frames.forEach(frame => {
            const frameDiv = document.createElement('div');
            frameDiv.className = 'stack-frame';
            // Parse frame: "functionName @ file:line:col"
            const match = frame.match(/^(.+?)\s*@\s*(.+)$/);
            if (match) {
              const funcSpan = document.createElement('span');
              funcSpan.className = 'stack-function';
              funcSpan.textContent = match[1];
              frameDiv.appendChild(funcSpan);
              frameDiv.appendChild(document.createTextNode(' @ '));
              const locSpan = document.createElement('span');
              locSpan.className = 'stack-location';
              locSpan.textContent = match[2];
              frameDiv.appendChild(locSpan);
            } else {
              frameDiv.textContent = frame;
            }
            stackPanel.appendChild(frameDiv);
          });
        } else {
          const noStack = document.createElement('div');
          noStack.className = 'no-stack-msg';
          noStack.textContent = 'No stack trace available';
          stackPanel.appendChild(noStack);
        }
        wrapper.appendChild(stackPanel);

        // Expand button click handler
        expandBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (!hasStack) return;
          if (expandedStackTraces.has(r.asyncId)) {
            expandedStackTraces.delete(r.asyncId);
            expandBtn.textContent = '‚ñ∂';
            expandBtn.classList.remove('expanded');
            stackPanel.classList.remove('show');
          } else {
            expandedStackTraces.add(r.asyncId);
            expandBtn.textContent = '‚ñº';
            expandBtn.classList.add('expanded');
            stackPanel.classList.add('show');
          }
        });

        container.appendChild(wrapper);

        // Store bar position for dependency arrows (will be updated after layout)
        waterfallRowPositions.set(r.asyncId, {
          row,
          bar,
          resource: r,
          barLeft: (startTime / duration) * timelineWidth,
          barRight: ((endTime) / duration) * timelineWidth
        });
      });

      // Render additional waterfall features after rows are laid out
      requestAnimationFrame(() => {
        renderConcurrencyGraph();
        renderDependencyArrows();
        setupTimeCursor();
      });
    }

    // Highlight parent and children on hover
    function highlightRelatedRows(asyncId) {
      const resource = traceData.resourceMap.get(asyncId);
      if (!resource) return;

      // Highlight parent
      if (resource.triggerId !== 0) {
        const parentRow = document.querySelector(`.resource-row[data-async-id="${resource.triggerId}"]`);
        if (parentRow) parentRow.classList.add('hover-parent');
      }

      // Highlight children
      const childIds = traceData.childrenMap.get(asyncId) || [];
      childIds.forEach(childId => {
        const childRow = document.querySelector(`.resource-row[data-async-id="${childId}"]`);
        if (childRow) childRow.classList.add('hover-child');
      });

      // Highlight self
      const selfRow = document.querySelector(`.resource-row[data-async-id="${asyncId}"]`);
      if (selfRow) selfRow.classList.add('hover-self');
    }

    function clearRelatedHighlights() {
      document.querySelectorAll('.resource-row.hover-parent, .resource-row.hover-child, .resource-row.hover-self').forEach(row => {
        row.classList.remove('hover-parent', 'hover-child', 'hover-self');
      });
    }

    // Render concurrency graph above waterfall
    function renderConcurrencyGraph() {
      const canvas = document.getElementById('concurrency-canvas');
      const graphContainer = document.getElementById('concurrency-graph');
      if (!canvas || !traceData) return;

      const rect = graphContainer.getBoundingClientRect();
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = rect.height * window.devicePixelRatio;
      canvas.style.width = rect.width + 'px';
      canvas.style.height = rect.height + 'px';

      const ctx = canvas.getContext('2d');
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
      ctx.clearRect(0, 0, rect.width, rect.height);

      const duration = waterfallDuration;
      if (duration <= 0) return;

      // Calculate concurrency at each point in time
      const events = [];
      traceData.resources.forEach(r => {
        if (r.createdAt >= 0) {
          events.push({ time: r.createdAt, delta: 1 });
          const endTime = r.callbackEndedAt > 0 ? r.callbackEndedAt : (r.destroyedAt > 0 ? r.destroyedAt : duration);
          events.push({ time: endTime, delta: -1 });
        }
      });
      events.sort((a, b) => a.time - b.time);

      // Build concurrency data points
      let concurrency = 0;
      let maxConcurrency = 0;
      const points = [];
      events.forEach(e => {
        if (points.length === 0 || points[points.length - 1].time !== e.time) {
          points.push({ time: e.time, concurrency });
        }
        concurrency += e.delta;
        maxConcurrency = Math.max(maxConcurrency, concurrency);
        points.push({ time: e.time, concurrency });
      });

      if (maxConcurrency === 0) return;

      // Draw filled area
      ctx.beginPath();
      ctx.moveTo(0, rect.height);
      points.forEach(p => {
        const x = (p.time / duration) * rect.width;
        const y = rect.height - (p.concurrency / maxConcurrency) * (rect.height - 10);
        ctx.lineTo(x, y);
      });
      ctx.lineTo(rect.width, rect.height);
      ctx.closePath();
      ctx.fillStyle = 'rgba(100, 180, 255, 0.3)';
      ctx.fill();

      // Draw line
      ctx.beginPath();
      points.forEach((p, i) => {
        const x = (p.time / duration) * rect.width;
        const y = rect.height - (p.concurrency / maxConcurrency) * (rect.height - 10);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.strokeStyle = 'rgba(100, 180, 255, 0.8)';
      ctx.lineWidth = 1.5;
      ctx.stroke();

      // Label
      ctx.fillStyle = '#888';
      ctx.font = '10px system-ui';
      ctx.fillText(`Max: ${maxConcurrency} concurrent`, 5, 12);
    }

    // Render dependency arrows between parent and child rows
    function renderDependencyArrows() {
      const svg = document.getElementById('waterfall-arrows');
      if (!svg || !traceData) return;

      svg.innerHTML = '';
      const container = document.getElementById('waterfall');
      const containerRect = container.getBoundingClientRect();

      // Only draw arrows in tree sort mode for clarity
      const sortMode = document.getElementById('sort-mode').value;
      if (sortMode !== 'tree') return;

      waterfallRowPositions.forEach((pos, asyncId) => {
        const resource = pos.resource;
        if (resource.triggerId === 0) return;

        const parentPos = waterfallRowPositions.get(resource.triggerId);
        if (!parentPos) return;

        const parentRect = parentPos.bar.getBoundingClientRect();
        const childRect = pos.bar.getBoundingClientRect();

        // Calculate positions relative to SVG
        const parentX = parentRect.right - containerRect.left;
        const parentY = parentRect.top + parentRect.height / 2 - containerRect.top + 54; // Account for concurrency graph
        const childX = childRect.left - containerRect.left;
        const childY = childRect.top + childRect.height / 2 - containerRect.top + 54;

        // Create curved path
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        const midX = (parentX + childX) / 2;
        const d = `M ${parentX} ${parentY} C ${midX} ${parentY}, ${midX} ${childY}, ${childX} ${childY}`;
        path.setAttribute('d', d);
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke', 'rgba(150, 150, 150, 0.3)');
        path.setAttribute('stroke-width', '1');
        svg.appendChild(path);

        // Add arrowhead
        const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        const arrowSize = 4;
        arrow.setAttribute('points', `${childX},${childY} ${childX - arrowSize},${childY - arrowSize} ${childX - arrowSize},${childY + arrowSize}`);
        arrow.setAttribute('fill', 'rgba(150, 150, 150, 0.5)');
        svg.appendChild(arrow);
      });
    }

    // Setup time cursor interaction
    function setupTimeCursor() {
      const graphContainer = document.getElementById('concurrency-graph');
      const cursor = document.getElementById('time-cursor');
      const cursorLabel = document.getElementById('time-cursor-label');
      const container = document.getElementById('waterfall');

      if (!graphContainer || !cursor || !traceData) return;

      graphContainer.addEventListener('mousemove', (e) => {
        const rect = graphContainer.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const timeMs = (x / rect.width) * (waterfallDuration / 1e6);

        cursor.style.display = 'block';
        cursor.style.left = x + 'px';
        cursorLabel.textContent = timeMs.toFixed(2) + 'ms';

        // Count active resources at this time
        const timeNs = timeMs * 1e6;
        let activeCount = 0;
        traceData.resources.forEach(r => {
          const endTime = r.callbackEndedAt > 0 ? r.callbackEndedAt : (r.destroyedAt > 0 ? r.destroyedAt : waterfallDuration);
          if (r.createdAt <= timeNs && endTime >= timeNs) activeCount++;
        });
        cursorLabel.textContent = `${timeMs.toFixed(2)}ms (${activeCount} active)`;

        // Highlight active rows
        document.querySelectorAll('.resource-row').forEach(row => {
          const asyncId = parseInt(row.dataset.asyncId);
          const r = traceData.resourceMap.get(asyncId);
          if (r) {
            const endTime = r.callbackEndedAt > 0 ? r.callbackEndedAt : (r.destroyedAt > 0 ? r.destroyedAt : waterfallDuration);
            if (r.createdAt <= timeNs && endTime >= timeNs) {
              row.classList.add('time-cursor-active');
            } else {
              row.classList.remove('time-cursor-active');
            }
          }
        });
      });

      graphContainer.addEventListener('mouseleave', () => {
        cursor.style.display = 'none';
        document.querySelectorAll('.resource-row.time-cursor-active').forEach(row => {
          row.classList.remove('time-cursor-active');
        });
      });
    }

    // Note: Old Bubble View code removed - bubble layout is now integrated into DAG view
    // See computeBubbleLayoutForDAG() function below

    function screenToWorld(screenX, screenY) {
      return {
        x: (screenX - panX) / zoom,
        y: (screenY - panY) / zoom
      };
    }

    // ==================== GRAPH VIEW (with Force, Hierarchical, and Bubble layouts) ====================
    // Note: The old separate Bubble View has been integrated as a third layout option
    function initDAGNodes() {
      if (!traceData) return;

      const container = document.getElementById('dag-view');
      const width = container.clientWidth;
      const height = container.clientHeight;

      // Filter based on current filter mode and click filter
      const filteredResources = traceData.resources.filter(r =>
        shouldShowResource(r) && isResourceVisible(r.asyncId)
      );

      // Create nodes with initial positions based on depth
      dagNodes = [];
      const nodeMap = new Map();

      if (dagLayoutMode === 'hierarchical') {
        // Hierarchical layout: proper tree structure with parent-centered children
        computeHierarchicalLayout(filteredResources, width, height, nodeMap);
      } else if (dagLayoutMode === 'bubble') {
        // Bubble layout: tree structure with variable-sized nodes based on sync time
        computeBubbleLayoutForDAG(filteredResources, width, height, nodeMap);
      } else {
        // Force-directed layout: initial positions by depth, then simulate
        const depthGroups = new Map();
        filteredResources.forEach(r => {
          const depth = traceData.depthMap.get(r.asyncId) || 0;
          if (!depthGroups.has(depth)) depthGroups.set(depth, []);
          depthGroups.get(depth).push(r);
        });

        const maxDepth = Math.max(...depthGroups.keys(), 0);
        const levelHeight = height / (maxDepth + 2);

        depthGroups.forEach((resources, depth) => {
          const levelWidth = width / (resources.length + 1);
          resources.forEach((r, i) => {
            const node = {
              resource: r,
              x: levelWidth * (i + 1),
              y: levelHeight * (depth + 1),
              vx: 0,
              vy: 0,
              radius: 15,
              color: TYPE_COLORS[r.type] || '#808080',
              fixed: false
            };
            dagNodes.push(node);
            nodeMap.set(r.asyncId, node);
          });
        });
      }

      // Reset pan/zoom
      dagPanX = 0;
      dagPanY = 0;
      dagZoom = 1;

      // Start force simulation only for force layout
      if (dagLayoutMode === 'force') {
        startDAGSimulation();
      } else {
        renderDAG();
      }
    }

    // Compute hierarchical (tree) layout for DAG
    function computeHierarchicalLayout(resources, width, height, nodeMap) {
      // Build adjacency for children
      const childrenMap = new Map();
      resources.forEach(r => {
        if (!childrenMap.has(r.triggerId)) childrenMap.set(r.triggerId, []);
        if (r.triggerId !== 0 || r.type === 'root') {
          // Only add if parent is in filtered set or this is root
          childrenMap.get(r.triggerId).push(r);
        }
      });

      // Find roots (resources whose parent is not in the filtered set)
      const resourceIds = new Set(resources.map(r => r.asyncId));
      const roots = resources.filter(r => r.triggerId === 0 || !resourceIds.has(r.triggerId));

      // Sort children by creation time
      childrenMap.forEach((children, parentId) => {
        children.sort((a, b) => a.createdAt - b.createdAt);
      });

      // First pass: compute subtree widths
      const subtreeWidths = new Map();
      function computeSubtreeWidth(asyncId) {
        const children = childrenMap.get(asyncId) || [];
        if (children.length === 0) {
          subtreeWidths.set(asyncId, 1);
          return 1;
        }
        let totalWidth = 0;
        children.forEach(child => {
          totalWidth += computeSubtreeWidth(child.asyncId);
        });
        subtreeWidths.set(asyncId, totalWidth);
        return totalWidth;
      }

      let totalWidth = 0;
      roots.forEach(r => {
        totalWidth += computeSubtreeWidth(r.asyncId);
      });

      // Second pass: assign positions
      const padding = 60;
      const usableWidth = width - padding * 2;
      const maxDepth = Math.max(...resources.map(r => traceData.depthMap.get(r.asyncId) || 0), 0);
      const levelHeight = (height - padding * 2) / (maxDepth + 1);
      const nodeSpacing = usableWidth / Math.max(totalWidth, 1);

      let currentX = padding;

      function layoutSubtree(r, depth) {
        const children = childrenMap.get(r.asyncId) || [];
        const myWidth = subtreeWidths.get(r.asyncId) || 1;

        let x;
        if (children.length === 0) {
          // Leaf node: place at currentX
          x = currentX + nodeSpacing / 2;
          currentX += nodeSpacing;
        } else {
          // Internal node: place children first, then center above them
          const startX = currentX;
          children.forEach(child => {
            layoutSubtree(child, depth + 1);
          });
          const endX = currentX;
          x = (startX + endX) / 2;
        }

        const y = padding + depth * levelHeight;

        const node = {
          resource: r,
          x: x,
          y: y,
          vx: 0,
          vy: 0,
          radius: 15,
          color: TYPE_COLORS[r.type] || '#808080',
          fixed: true  // Fixed in hierarchical mode
        };
        dagNodes.push(node);
        nodeMap.set(r.asyncId, node);
      }

      roots.forEach(r => {
        layoutSubtree(r, 0);
      });
    }

    // Compute bubble layout for DAG - tree structure with variable-sized nodes based on sync time
    function computeBubbleLayoutForDAG(resources, width, height, nodeMap) {
      const padding = 50;

      // Calculate max sync time for sizing
      const maxSyncTime = Math.max(...resources.map(r =>
        (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) ? r.callbackEndedAt - r.callbackStartedAt : 0
      ), 1);

      // Build adjacency for children
      const childrenMap = new Map();
      resources.forEach(r => {
        if (!childrenMap.has(r.triggerId)) childrenMap.set(r.triggerId, []);
        if (r.triggerId !== 0 || r.type === 'root') {
          childrenMap.get(r.triggerId).push(r);
        }
      });

      // Find roots
      const resourceIds = new Set(resources.map(r => r.asyncId));
      const roots = resources.filter(r => r.triggerId === 0 || !resourceIds.has(r.triggerId));

      // Sort children by creation time
      childrenMap.forEach((children, parentId) => {
        children.sort((a, b) => a.createdAt - b.createdAt);
      });

      // Pre-compute node radii
      const nodeRadii = new Map();
      resources.forEach(r => {
        const syncTime = (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) ? r.callbackEndedAt - r.callbackStartedAt : 0;
        const radius = Math.max(12, Math.min(35, Math.sqrt(syncTime / maxSyncTime) * 40 + 12));
        nodeRadii.set(r.asyncId, radius);
      });

      // Compute subtree widths (accounting for variable node sizes)
      const subtreeWidths = new Map();
      const nodeSpacing = 20;

      function computeSubtreeWidth(asyncId) {
        const children = childrenMap.get(asyncId) || [];
        const myRadius = nodeRadii.get(asyncId) || 15;

        if (children.length === 0) {
          const w = myRadius * 2 + nodeSpacing;
          subtreeWidths.set(asyncId, w);
          return w;
        }

        let childrenTotalWidth = 0;
        children.forEach(child => {
          childrenTotalWidth += computeSubtreeWidth(child.asyncId);
        });

        const myWidth = Math.max(myRadius * 2 + nodeSpacing, childrenTotalWidth);
        subtreeWidths.set(asyncId, myWidth);
        return myWidth;
      }

      let totalWidth = 0;
      roots.forEach(r => {
        totalWidth += computeSubtreeWidth(r.asyncId);
      });

      // Calculate depth-based Y positions
      const maxDepth = Math.max(...resources.map(r => traceData.depthMap.get(r.asyncId) || 0), 0);
      const levelHeight = Math.min(80, (height - padding * 2) / (maxDepth + 1));

      // Layout nodes
      let currentX = padding;

      function layoutSubtree(r, depth) {
        const children = childrenMap.get(r.asyncId) || [];
        const myWidth = subtreeWidths.get(r.asyncId) || 50;
        const myRadius = nodeRadii.get(r.asyncId) || 15;

        let x;
        if (children.length === 0) {
          x = currentX + myWidth / 2;
          currentX += myWidth;
        } else {
          const startX = currentX;
          children.forEach(child => {
            layoutSubtree(child, depth + 1);
          });
          const endX = currentX;
          x = (startX + endX) / 2;
        }

        const y = padding + 30 + depth * levelHeight;
        const syncTime = (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) ? r.callbackEndedAt - r.callbackStartedAt : 0;

        const node = {
          resource: r,
          x: x,
          y: y,
          vx: 0,
          vy: 0,
          radius: myRadius,
          color: TYPE_COLORS[r.type] || '#808080',
          fixed: true,
          syncTime: syncTime  // Store for potential display
        };
        dagNodes.push(node);
        nodeMap.set(r.asyncId, node);
      }

      roots.forEach(r => {
        layoutSubtree(r, 0);
      });

      // Center the layout horizontally on the viewport
      if (dagNodes.length > 0) {
        const rootNode = dagNodes.find(n => n.resource.type === 'root') || dagNodes[0];
        const centerX = width / 2;
        const offsetX = centerX - rootNode.x;
        dagNodes.forEach(n => n.x += offsetX);
      }

      // Handle orphans (nodes not connected to any root)
      const positionedIds = new Set(dagNodes.map(n => n.resource.asyncId));
      let orphanX = padding + 30;
      resources.forEach(r => {
        if (!positionedIds.has(r.asyncId)) {
          const radius = nodeRadii.get(r.asyncId) || 15;
          const node = {
            resource: r,
            x: orphanX,
            y: height - padding - 30,
            vx: 0,
            vy: 0,
            radius: radius,
            color: TYPE_COLORS[r.type] || '#808080',
            fixed: true
          };
          dagNodes.push(node);
          nodeMap.set(r.asyncId, node);
          orphanX += radius * 2 + 20;
        }
      });
    }

    // Compute path highlighting for DAG (ancestors and descendants of a node)
    function computeDAGPath(asyncId) {
      dagPathNodes.clear();
      dagPathEdges.clear();

      if (!asyncId || !traceData) return;

      // Add the hovered node itself
      dagPathNodes.add(asyncId);

      // Find all ancestors (path to root)
      let current = asyncId;
      while (current) {
        const resource = traceData.resourceMap.get(current);
        if (!resource || resource.triggerId === 0) break;
        dagPathNodes.add(resource.triggerId);
        dagPathEdges.add(`${resource.triggerId}-${current}`);
        current = resource.triggerId;
      }

      // Find all descendants (BFS)
      const queue = [asyncId];
      while (queue.length > 0) {
        const nodeId = queue.shift();
        const children = traceData.childrenMap.get(nodeId) || [];
        children.forEach(childId => {
          // Only include if child is in the current filtered view
          const childNode = dagNodes.find(n => n.resource.asyncId === childId);
          if (childNode) {
            dagPathNodes.add(childId);
            dagPathEdges.add(`${nodeId}-${childId}`);
            queue.push(childId);
          }
        });
      }
    }

    function clearDAGPath() {
      dagHoveredNode = null;
      dagPathNodes.clear();
      dagPathEdges.clear();
    }

    function startDAGSimulation() {
      if (dagSimulationRunning) return;
      dagSimulationRunning = true;

      const container = document.getElementById('dag-view');
      const width = container.clientWidth;
      const height = container.clientHeight;
      const centerX = width / 2;
      const centerY = height / 2;

      let iterations = 0;
      const maxIterations = 150;

      function simulate() {
        if (!dagSimulationRunning || iterations >= maxIterations) {
          dagSimulationRunning = false;
          return;
        }

        const alpha = 1 - iterations / maxIterations;  // Cooling factor

        // Apply forces
        dagNodes.forEach(node => {
          if (node.fixed) return;

          let fx = 0, fy = 0;

          // Repulsion from other nodes
          dagNodes.forEach(other => {
            if (other === node) return;
            const dx = node.x - other.x;
            const dy = node.y - other.y;
            const dist = Math.sqrt(dx*dx + dy*dy) || 1;
            const minDist = 60;
            if (dist < minDist * 3) {
              const force = (minDist * minDist) / (dist * dist) * 2;
              fx += (dx / dist) * force;
              fy += (dy / dist) * force;
            }
          });

          // Attraction to parent
          const r = node.resource;
          if (r.triggerId !== 0) {
            const parent = dagNodes.find(n => n.resource.asyncId === r.triggerId);
            if (parent) {
              const dx = parent.x - node.x;
              const dy = parent.y - node.y;
              const dist = Math.sqrt(dx*dx + dy*dy) || 1;
              const idealDist = 80;
              const force = (dist - idealDist) * 0.05;
              fx += (dx / dist) * force;
              fy += (dy / dist) * force;

              // Also prefer to be below parent
              fy += 0.5;
            }
          }

          // Weak centering force
          fx += (centerX - node.x) * 0.001;
          fy += (centerY - node.y) * 0.001;

          // Apply velocity with damping
          node.vx = (node.vx + fx * alpha) * 0.8;
          node.vy = (node.vy + fy * alpha) * 0.8;

          node.x += node.vx;
          node.y += node.vy;

          // Keep in bounds
          node.x = Math.max(50, Math.min(width - 50, node.x));
          node.y = Math.max(50, Math.min(height - 50, node.y));
        });

        iterations++;
        renderDAG();
        requestAnimationFrame(simulate);
      }

      simulate();
    }

    function renderDAG() {
      const container = document.getElementById('dag-view');
      const canvas = document.getElementById('dag-canvas');
      const ctx = canvas.getContext('2d');

      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;

      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (!traceData || dagNodes.length === 0) {
        // Initialize nodes on first render
        initDAGNodes();
        return;
      }

      ctx.save();
      ctx.translate(dagPanX, dagPanY);
      ctx.scale(dagZoom, dagZoom);

      // Build node lookup for edge drawing
      const nodeMap = new Map();
      dagNodes.forEach(n => nodeMap.set(n.resource.asyncId, n));

      // Draw edges
      dagNodes.forEach(node => {
        const r = node.resource;
        if (r.triggerId !== 0) {
          const parent = nodeMap.get(r.triggerId);
          if (parent) {
            const isHighlighted = highlightedChain.has(r.asyncId) && highlightedChain.has(r.triggerId);
            const isOnCriticalPath = showCriticalPath &&
              criticalPathSet.has(r.asyncId) && criticalPathSet.has(r.triggerId);
            const isOnHoverPath = dagPathEdges.has(`${r.triggerId}-${r.asyncId}`);
            const dimmed = dagPathNodes.size > 0 && !isOnHoverPath;

            ctx.strokeStyle = isOnCriticalPath ? '#ff6432' :
                             isOnHoverPath ? '#50c878' :
                             dimmed ? 'rgba(126, 200, 227, 0.1)' :
                             isHighlighted ? '#e94560' : 'rgba(126, 200, 227, 0.3)';
            ctx.lineWidth = isOnCriticalPath ? 3 : (isOnHoverPath ? 2.5 : (isHighlighted ? 2 : 1));

            ctx.beginPath();
            ctx.moveTo(parent.x, parent.y);
            ctx.lineTo(node.x, node.y);
            ctx.stroke();

            // Arrowhead
            const angle = Math.atan2(node.y - parent.y, node.x - parent.x);
            const arrowX = node.x - node.radius * Math.cos(angle);
            const arrowY = node.y - node.radius * Math.sin(angle);
            const arrowSize = 8;

            ctx.beginPath();
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(arrowX - arrowSize * Math.cos(angle - 0.4), arrowY - arrowSize * Math.sin(angle - 0.4));
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(arrowX - arrowSize * Math.cos(angle + 0.4), arrowY - arrowSize * Math.sin(angle + 0.4));
            ctx.stroke();

            // Draw latency label on edge (in bubble mode or when paths aren't highlighted)
            if (dagLayoutMode === 'bubble' && !dimmed) {
              const parentEnd = parent.resource.callbackEndedAt > 0 ? parent.resource.callbackEndedAt : parent.resource.createdAt;
              const childStart = r.createdAt;
              const latencyNs = childStart - parentEnd;
              const latencyMs = latencyNs / 1e6;

              if (Math.abs(latencyMs) >= 0.01) {
                const midX = (parent.x + node.x) / 2;
                const midY = (parent.y + node.y) / 2;

                const labelText = latencyMs >= 1 ? `${latencyMs.toFixed(1)}ms` : `${(latencyMs * 1000).toFixed(0)}¬µs`;
                ctx.font = '9px sans-serif';
                const textWidth = ctx.measureText(labelText).width;

                // Background for readability
                ctx.fillStyle = 'rgba(26, 26, 46, 0.9)';
                ctx.fillRect(midX - textWidth/2 - 2, midY - 6, textWidth + 4, 12);

                // Label text
                ctx.fillStyle = latencyMs > 1 ? '#ffd700' : '#888';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(labelText, midX, midY);
              }
            }
          }
        }
      });

      // Draw temporal edges (dashed, green) if enabled
      if (showTemporalEdges && temporalEdges.length > 0) {
        ctx.save();
        ctx.setLineDash([4, 4]);
        ctx.strokeStyle = 'rgba(80, 200, 120, 0.6)';
        ctx.lineWidth = 1.5;

        temporalEdges.forEach(edge => {
          const fromNode = nodeMap.get(edge.from);
          const toNode = nodeMap.get(edge.to);
          if (fromNode && toNode) {
            ctx.beginPath();
            ctx.moveTo(fromNode.x, fromNode.y);
            ctx.lineTo(toNode.x, toNode.y);
            ctx.stroke();

            // Small arrowhead
            const angle = Math.atan2(toNode.y - fromNode.y, toNode.x - fromNode.x);
            const arrowX = toNode.x - toNode.radius * Math.cos(angle);
            const arrowY = toNode.y - toNode.radius * Math.sin(angle);
            const arrowSize = 5;
            ctx.beginPath();
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(arrowX - arrowSize * Math.cos(angle - 0.4), arrowY - arrowSize * Math.sin(angle - 0.4));
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(arrowX - arrowSize * Math.cos(angle + 0.4), arrowY - arrowSize * Math.sin(angle + 0.4));
            ctx.stroke();
          }
        });

        ctx.restore();
      }

      // Draw nodes
      dagNodes.forEach(node => {
        const r = node.resource;
        const isSelected = selectedResource && r.asyncId === selectedResource.asyncId;
        const isHighlighted = highlightedChain.has(r.asyncId);
        const isOnCriticalPath = showCriticalPath && criticalPathSet.has(r.asyncId);
        const isBottleneck = showBottlenecks && detectedBottlenecks.includes(r.asyncId);
        const patternSeverity = getPatternSeverity(r.asyncId);
        const isPatternMatch = patternSeverity !== null;
        const isInternal = r._classification === 'internal';
        const isOnHoverPath = dagPathNodes.has(r.asyncId);
        const isHoveredNode = dagHoveredNode && dagHoveredNode.resource.asyncId === r.asyncId;

        // Dim nodes not on the hover path when path highlighting is active
        const dimmed = dagPathNodes.size > 0 && !isOnHoverPath;

        // Node circle
        ctx.beginPath();
        ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
        ctx.fillStyle = node.color;
        ctx.globalAlpha = dimmed ? 0.2 : (isInternal ? 0.4 : (isHighlighted || isOnHoverPath ? 1 : 0.8));
        ctx.fill();
        ctx.globalAlpha = 1;

        // Hover path glow (green)
        if (isHoveredNode) {
          ctx.strokeStyle = '#50c878';
          ctx.lineWidth = 4;
          ctx.shadowColor = '#50c878';
          ctx.shadowBlur = 15;
          ctx.stroke();
          ctx.shadowBlur = 0;
        } else if (isOnHoverPath) {
          ctx.strokeStyle = '#50c878';
          ctx.lineWidth = 2.5;
          ctx.shadowColor = '#50c878';
          ctx.shadowBlur = 8;
          ctx.stroke();
          ctx.shadowBlur = 0;
        }
        // Critical path glow
        else if (isOnCriticalPath) {
          ctx.strokeStyle = '#ff6432';
          ctx.lineWidth = 3;
          ctx.shadowColor = '#ff6432';
          ctx.shadowBlur = 10;
          ctx.stroke();
          ctx.shadowBlur = 0;
        }
        // Bottleneck glow (yellow)
        else if (isBottleneck) {
          ctx.strokeStyle = '#ffc832';
          ctx.lineWidth = 3;
          ctx.shadowColor = '#ffc832';
          ctx.shadowBlur = 10;
          ctx.stroke();
          ctx.shadowBlur = 0;
        }
        // Pattern match glow (severity-based purple)
        else if (isPatternMatch) {
          const pStyle = getPatternStyle(patternSeverity);
          ctx.strokeStyle = pStyle.color;
          ctx.lineWidth = pStyle.lineWidth;
          ctx.shadowColor = pStyle.color;
          ctx.shadowBlur = pStyle.glow;
          ctx.stroke();
          ctx.shadowBlur = 0;
        }

        // Selection ring
        if (isSelected) {
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 3;
          ctx.stroke();
        } else if (isHighlighted && !isOnCriticalPath && !isBottleneck && !isPatternMatch && !isOnHoverPath) {
          ctx.strokeStyle = '#e94560';
          ctx.lineWidth = 2;
          ctx.stroke();
        }

        // Label
        ctx.fillStyle = 'white';
        ctx.font = '9px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const label = r.type.replace('js-', '').substring(0, 4);
        ctx.fillText(label, node.x, node.y);
      });

      ctx.restore();

      // Instructions
      ctx.fillStyle = '#444';
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText('Drag nodes | Shift+drag: pan | Scroll: zoom', 10, canvas.height - 10);
    }

    // ==================== PARALLELISM VIEW ====================
    // Store parallelism view state for hover/click interaction
    let parallelismBucketData = null;
    let parallelismHoverBucket = -1;
    let parallelismTooltip = null;

    function renderParallelism() {
      const container = document.getElementById('parallelism-view');
      const canvas = document.getElementById('parallelism-canvas');
      const ctx = canvas.getContext('2d');

      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;

      const width = canvas.width;
      const height = canvas.height;
      const padding = { top: 40, right: 200, bottom: 50, left: 60 };
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;

      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, width, height);

      if (!traceData) return;

      const duration = traceData.requestDurationNs;
      const numBuckets = Math.min(500, Math.floor(chartWidth / 2));
      const bucketSize = duration / numBuckets;

      // Track detailed info per bucket for hover/click
      // Each bucket tracks: executing resources, waiting resources, bottleneck info
      const bucketDetails = new Array(numBuckets).fill(null).map(() => ({
        executing: [],      // Resources with callback running
        waiting: [],        // Resources created but callback not started
        criticalPath: [],   // Critical path resources active in this bucket
        bottleneck: null    // If serialized, which resource is blocking
      }));

      // Count operations per bucket, now separating executing vs waiting
      const executingBuckets = new Array(numBuckets).fill(0);
      const waitingBuckets = new Array(numBuckets).fill(0);
      const criticalPathBuckets = new Array(numBuckets).fill(0);

      // For ideal parallelism: track what COULD run if everything started immediately
      // This represents maximum theoretical parallelism based on operation durations
      const idealBuckets = new Array(numBuckets).fill(0);

      // Also track by type for stacked visualization
      const typeExecutingBuckets = new Map();  // type -> array of executing counts
      const typeWaitingBuckets = new Map();    // type -> array of waiting counts
      const allTypes = new Set();

      traceData.resources.forEach(r => {
        allTypes.add(r.type);
        if (!typeExecutingBuckets.has(r.type)) {
          typeExecutingBuckets.set(r.type, new Array(numBuckets).fill(0));
          typeWaitingBuckets.set(r.type, new Array(numBuckets).fill(0));
        }

        const createdAt = r.createdAt;
        const callbackStart = r.callbackStartedAt > 0 ? r.callbackStartedAt : duration;
        const callbackEnd = r.callbackEndedAt > 0 ? r.callbackEndedAt :
                          (r.destroyedAt > 0 ? r.destroyedAt : duration);

        const isOnCriticalPath = criticalPathSet.has(r.asyncId);

        // Waiting period: created but callback not started
        if (createdAt < callbackStart) {
          const startBucket = Math.max(0, Math.floor(createdAt / bucketSize));
          const endBucket = Math.min(numBuckets - 1, Math.floor(callbackStart / bucketSize));
          const waitBuckets = typeWaitingBuckets.get(r.type);

          for (let i = startBucket; i <= endBucket; i++) {
            waitBuckets[i]++;
            waitingBuckets[i]++;
            bucketDetails[i].waiting.push(r);
            if (isOnCriticalPath) {
              criticalPathBuckets[i]++;
              bucketDetails[i].criticalPath.push(r);
            }
          }
        }

        // Executing period: callback running
        if (r.callbackStartedAt > 0 && r.callbackStartedAt < callbackEnd) {
          const startBucket = Math.max(0, Math.floor(r.callbackStartedAt / bucketSize));
          const endBucket = Math.min(numBuckets - 1, Math.floor(callbackEnd / bucketSize));
          const execBuckets = typeExecutingBuckets.get(r.type);

          for (let i = startBucket; i <= endBucket; i++) {
            execBuckets[i]++;
            executingBuckets[i]++;
            bucketDetails[i].executing.push(r);
            if (isOnCriticalPath) {
              criticalPathBuckets[i]++;
              if (!bucketDetails[i].criticalPath.includes(r)) {
                bucketDetails[i].criticalPath.push(r);
              }
            }
          }
        }

        // For ideal parallelism: if this operation's sync work were shifted to time 0
        // how much parallelism could we achieve? This shows theoretical maximum.
        const syncDuration = r.callbackEndedAt > 0 && r.callbackStartedAt > 0 ?
                            r.callbackEndedAt - r.callbackStartedAt : 0;
        if (syncDuration > 0) {
          const idealEndBucket = Math.min(numBuckets - 1, Math.floor(syncDuration / bucketSize));
          for (let i = 0; i <= idealEndBucket; i++) {
            idealBuckets[i]++;
          }
        }
      });

      // Calculate totals and find max
      const totalBuckets = new Array(numBuckets).fill(0);
      for (let i = 0; i < numBuckets; i++) {
        totalBuckets[i] = executingBuckets[i] + waitingBuckets[i];
      }
      const maxConcurrent = Math.max(...totalBuckets, ...idealBuckets, 1);
      const maxIdeal = Math.max(...idealBuckets, 1);

      // Identify bottlenecks (when only 1 resource is active)
      for (let i = 0; i < numBuckets; i++) {
        const total = totalBuckets[i];
        if (total === 1) {
          const blocker = bucketDetails[i].executing[0] || bucketDetails[i].waiting[0];
          if (blocker) {
            bucketDetails[i].bottleneck = blocker;
          }
        }
      }

      // Sort types by total count for consistent stacking
      const sortedTypes = Array.from(allTypes).sort((a, b) => {
        const sumA = (typeExecutingBuckets.get(a) || []).reduce((s, v) => s + v, 0) +
                    (typeWaitingBuckets.get(a) || []).reduce((s, v) => s + v, 0);
        const sumB = (typeExecutingBuckets.get(b) || []).reduce((s, v) => s + v, 0) +
                    (typeWaitingBuckets.get(b) || []).reduce((s, v) => s + v, 0);
        return sumB - sumA;
      });

      // Store bucket data for hover interaction
      parallelismBucketData = {
        numBuckets, bucketSize, duration, bucketDetails,
        executingBuckets, waitingBuckets, totalBuckets,
        criticalPathBuckets, idealBuckets,
        padding, chartWidth, chartHeight, maxConcurrent
      };

      // Draw title
      ctx.fillStyle = '#e94560';
      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Concurrent Operations Over Time (Executing vs Waiting)', width / 2 - 80, 20);

      // Draw axes
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding.left, padding.top);
      ctx.lineTo(padding.left, height - padding.bottom);
      ctx.lineTo(width - padding.right, height - padding.bottom);
      ctx.stroke();

      // Y-axis labels
      ctx.fillStyle = '#888';
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'right';
      for (let i = 0; i <= 5; i++) {
        const y = padding.top + (1 - i / 5) * chartHeight;
        const value = Math.round((i / 5) * maxConcurrent);
        ctx.fillText(value.toString(), padding.left - 8, y + 3);

        // Grid line
        ctx.strokeStyle = '#333';
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(width - padding.right, y);
        ctx.stroke();
      }

      // X-axis labels
      ctx.textAlign = 'center';
      for (let i = 0; i <= 5; i++) {
        const x = padding.left + (i / 5) * chartWidth;
        const time = (i / 5) * duration / 1e6;
        ctx.fillText(time.toFixed(1) + 'ms', x, height - padding.bottom + 15);
      }

      // Draw stacked area chart - executing (solid) then waiting (striped/faded)
      const barWidth = chartWidth / numBuckets;

      // First pass: draw executing (solid colors)
      for (let i = 0; i < numBuckets; i++) {
        let y = height - padding.bottom;
        const x = padding.left + i * barWidth;

        sortedTypes.forEach(type => {
          const execCount = typeExecutingBuckets.get(type)?.[i] || 0;
          if (execCount > 0) {
            const barHeight = (execCount / maxConcurrent) * chartHeight;
            ctx.fillStyle = TYPE_COLORS[type] || '#808080';
            ctx.globalAlpha = 0.9;
            ctx.fillRect(x, y - barHeight, barWidth + 0.5, barHeight);
            y -= barHeight;
          }
        });
      }

      // Second pass: draw waiting (faded/hatched) on top
      for (let i = 0; i < numBuckets; i++) {
        let y = height - padding.bottom - (executingBuckets[i] / maxConcurrent) * chartHeight;
        const x = padding.left + i * barWidth;

        sortedTypes.forEach(type => {
          const waitCount = typeWaitingBuckets.get(type)?.[i] || 0;
          if (waitCount > 0) {
            const barHeight = (waitCount / maxConcurrent) * chartHeight;
            ctx.fillStyle = TYPE_COLORS[type] || '#808080';
            ctx.globalAlpha = 0.35;  // Faded for waiting
            ctx.fillRect(x, y - barHeight, barWidth + 0.5, barHeight);
            y -= barHeight;
          }
        });
      }
      ctx.globalAlpha = 1;

      // Draw ideal parallelism - filled area with line on top
      // First draw filled area underneath
      ctx.fillStyle = 'rgba(0, 220, 255, 0.15)';
      ctx.beginPath();
      ctx.moveTo(padding.left, height - padding.bottom);
      for (let i = 0; i < numBuckets; i++) {
        const x = padding.left + i * barWidth + barWidth / 2;
        const y = height - padding.bottom - (idealBuckets[i] / maxConcurrent) * chartHeight;
        ctx.lineTo(x, y);
      }
      ctx.lineTo(padding.left + chartWidth, height - padding.bottom);
      ctx.closePath();
      ctx.fill();

      // Then draw the line on top (bright cyan, thicker)
      ctx.strokeStyle = '#00e5ff';
      ctx.lineWidth = 2.5;
      ctx.setLineDash([6, 3]);
      ctx.beginPath();
      for (let i = 0; i < numBuckets; i++) {
        const x = padding.left + i * barWidth + barWidth / 2;
        const y = height - padding.bottom - (idealBuckets[i] / maxConcurrent) * chartHeight;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
      ctx.setLineDash([]);

      // Draw critical path overlay (when enabled)
      if (showCriticalPath && criticalPathSet.size > 0) {
        ctx.strokeStyle = '#ff6600';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 0; i < numBuckets; i++) {
          const x = padding.left + i * barWidth + barWidth / 2;
          const cpCount = criticalPathBuckets[i];
          const y = height - padding.bottom - (cpCount / maxConcurrent) * chartHeight;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();

        // Fill under critical path with subtle highlight
        ctx.fillStyle = 'rgba(255, 102, 0, 0.1)';
        ctx.beginPath();
        ctx.moveTo(padding.left, height - padding.bottom);
        for (let i = 0; i < numBuckets; i++) {
          const x = padding.left + i * barWidth + barWidth / 2;
          const y = height - padding.bottom - (criticalPathBuckets[i] / maxConcurrent) * chartHeight;
          ctx.lineTo(x, y);
        }
        ctx.lineTo(padding.left + chartWidth, height - padding.bottom);
        ctx.closePath();
        ctx.fill();
      }

      // Draw "parallelism = 1" danger line
      const oneLineY = height - padding.bottom - (1 / maxConcurrent) * chartHeight;
      if (maxConcurrent > 1) {
        ctx.strokeStyle = '#ff6432';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(padding.left, oneLineY);
        ctx.lineTo(width - padding.right, oneLineY);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Find serialization regions (consecutive buckets where total <= 1)
      const serializationRegions = [];
      let regionStart = -1;
      for (let i = 0; i < numBuckets; i++) {
        if (totalBuckets[i] <= 1) {
          if (regionStart === -1) regionStart = i;
        } else {
          if (regionStart !== -1) {
            serializationRegions.push({ start: regionStart, end: i - 1 });
            regionStart = -1;
          }
        }
      }
      if (regionStart !== -1) {
        serializationRegions.push({ start: regionStart, end: numBuckets - 1 });
      }

      // Draw serialization region highlights
      ctx.fillStyle = 'rgba(255, 100, 50, 0.15)';
      serializationRegions.forEach(region => {
        const x = padding.left + region.start * barWidth;
        const w = (region.end - region.start + 1) * barWidth;
        ctx.fillRect(x, padding.top, w, chartHeight);
      });

      // Draw hover highlight
      if (parallelismHoverBucket >= 0 && parallelismHoverBucket < numBuckets) {
        const x = padding.left + parallelismHoverBucket * barWidth;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.fillRect(x, padding.top, barWidth, chartHeight);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, padding.top, barWidth, chartHeight);
      }

      // Draw legend
      const legendY = height - 25;
      let legendX = padding.left;
      ctx.font = '10px sans-serif';

      // Executing/waiting legend
      ctx.fillStyle = '#50c878';
      ctx.globalAlpha = 0.9;
      ctx.fillRect(legendX, legendY, 12, 12);
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#aaa';
      ctx.textAlign = 'left';
      ctx.fillText('Executing', legendX + 16, legendY + 10);
      legendX += 80;

      ctx.fillStyle = '#50c878';
      ctx.globalAlpha = 0.35;
      ctx.fillRect(legendX, legendY, 12, 12);
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#aaa';
      ctx.fillText('Waiting', legendX + 16, legendY + 10);
      legendX += 70;

      // Ideal line legend
      ctx.strokeStyle = '#00e5ff';
      ctx.lineWidth = 2.5;
      ctx.setLineDash([6, 3]);
      ctx.beginPath();
      ctx.moveTo(legendX, legendY + 6);
      ctx.lineTo(legendX + 12, legendY + 6);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = '#aaa';
      ctx.fillText('Ideal', legendX + 16, legendY + 10);
      legendX += 55;

      // Critical path legend (if enabled)
      if (showCriticalPath && criticalPathSet.size > 0) {
        ctx.strokeStyle = '#ff6600';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(legendX, legendY + 6);
        ctx.lineTo(legendX + 12, legendY + 6);
        ctx.stroke();
        ctx.fillStyle = '#aaa';
        ctx.fillText('Critical', legendX + 16, legendY + 10);
        legendX += 60;
      }

      // Type colors (remaining space)
      sortedTypes.slice(0, 5).forEach(type => {
        if (legendX > width - padding.right - 100) return;
        ctx.fillStyle = TYPE_COLORS[type] || '#808080';
        ctx.fillRect(legendX, legendY, 10, 10);
        ctx.fillStyle = '#888';
        const label = type.replace('js-', '').substring(0, 6);
        ctx.fillText(label, legendX + 14, legendY + 9);
        legendX += ctx.measureText(label).width + 26;
      });

      // ===== STATS SIDEBAR =====
      const sidebarX = width - padding.right + 10;
      const sidebarWidth = padding.right - 20;

      // Calculate efficiency metrics
      const avgConcurrency = totalBuckets.reduce((s, v) => s + v, 0) / numBuckets;
      const avgExecuting = executingBuckets.reduce((s, v) => s + v, 0) / numBuckets;
      const avgWaiting = waitingBuckets.reduce((s, v) => s + v, 0) / numBuckets;
      const serializationTime = totalBuckets.filter(v => v <= 1).length * bucketSize;
      const serializationPct = (serializationTime / duration * 100);

      // Total work done (sum of all operation durations)
      let totalSyncWork = 0;
      let totalAsyncWait = 0;
      traceData.resources.forEach(r => {
        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          totalSyncWork += r.callbackEndedAt - r.callbackStartedAt;
        }
        if (r.callbackStartedAt > 0 && r.createdAt > 0) {
          totalAsyncWait += r.callbackStartedAt - r.createdAt;
        }
      });

      // Efficiency: how well we're using available parallelism
      // Theoretical minimum = total sync work / peak parallelism
      const peakParallelism = Math.max(...executingBuckets, 1);
      const theoreticalMin = totalSyncWork / peakParallelism;
      const efficiency = theoreticalMin > 0 ? (theoreticalMin / duration * 100) : 0;

      // Parallelization opportunity: how much faster could we be?
      const idealAvg = idealBuckets.reduce((s, v) => s + v, 0) / numBuckets;
      const parallelizationGap = idealAvg > 0 ? (avgExecuting / idealAvg * 100) : 100;

      // Serialization cost: time lost to being serialized
      const potentialSavings = serializationTime * (1 - 1/Math.max(avgConcurrency, 1));

      // Draw sidebar background
      ctx.fillStyle = 'rgba(22, 33, 62, 0.95)';
      ctx.fillRect(sidebarX, padding.top, sidebarWidth, chartHeight);
      ctx.strokeStyle = '#0f3460';
      ctx.strokeRect(sidebarX, padding.top, sidebarWidth, chartHeight);

      let sbY = padding.top + 15;
      const lineHeight = 16;

      const drawSectionHeader = (title, color = '#e94560') => {
        ctx.fillStyle = color;
        ctx.font = 'bold 11px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(title, sidebarX + 8, sbY);
        sbY += lineHeight + 2;
      };

      const drawStatLine = (label, value, color = '#aaa') => {
        ctx.fillStyle = '#888';
        ctx.font = '10px sans-serif';
        ctx.fillText(label + ':', sidebarX + 8, sbY);
        ctx.fillStyle = color;
        ctx.textAlign = 'right';
        ctx.fillText(String(value), sidebarX + sidebarWidth - 8, sbY);
        ctx.textAlign = 'left';
        sbY += lineHeight;
      };

      // Parallelism Stats
      drawSectionHeader('Parallelism');
      drawStatLine('Peak (exec)', peakParallelism, '#50c878');
      drawStatLine('Avg executing', avgExecuting.toFixed(1), '#7ec8e3');
      drawStatLine('Avg waiting', avgWaiting.toFixed(1), '#888');
      drawStatLine('Avg total', avgConcurrency.toFixed(1));
      sbY += 6;

      // Efficiency Stats
      drawSectionHeader('Efficiency', '#00bcd4');
      drawStatLine('Ideal avg', idealAvg.toFixed(1), '#00bcd4');
      drawStatLine('Utilization', parallelizationGap.toFixed(0) + '%',
        parallelizationGap > 70 ? '#50c878' : (parallelizationGap > 40 ? '#ffd700' : '#ff6432'));
      drawStatLine('Efficiency', efficiency.toFixed(0) + '%',
        efficiency > 50 ? '#50c878' : (efficiency > 25 ? '#ffd700' : '#ff6432'));
      sbY += 6;

      // Serialization Stats
      drawSectionHeader('Serialization', '#ff6432');
      drawStatLine('Time', (serializationTime / 1e6).toFixed(2) + 'ms');
      drawStatLine('Percent', serializationPct.toFixed(0) + '%',
        serializationPct < 20 ? '#50c878' : (serializationPct < 50 ? '#ffd700' : '#ff6432'));
      drawStatLine('Potential save', (potentialSavings / 1e6).toFixed(2) + 'ms',
        potentialSavings > duration * 0.1 ? '#ffd700' : '#888');
      sbY += 6;

      // Critical path stats (if enabled)
      if (showCriticalPath && criticalPathInfo) {
        drawSectionHeader('Critical Path', '#ff6600');
        drawStatLine('Resources', criticalPathInfo.path.length);
        drawStatLine('Sync time', (criticalPathInfo.totalSyncTime / 1e6).toFixed(2) + 'ms');
        drawStatLine('Async wait', (criticalPathInfo.totalAsyncWait / 1e6).toFixed(2) + 'ms');
        sbY += 6;
      }

      // Bottleneck identification
      const bottleneckCounts = new Map();
      bucketDetails.forEach(bd => {
        if (bd.bottleneck) {
          const key = `${bd.bottleneck.type}#${bd.bottleneck.asyncId}`;
          bottleneckCounts.set(key, (bottleneckCounts.get(key) || 0) + 1);
        }
      });

      if (bottleneckCounts.size > 0) {
        drawSectionHeader('Top Bottlenecks', '#ffd700');
        const sorted = [...bottleneckCounts.entries()]
          .sort((a, b) => b[1] - a[1])
          .slice(0, 3);

        sorted.forEach(([key, count]) => {
          const pct = (count / numBuckets * 100).toFixed(0);
          const shortKey = key.length > 15 ? key.substring(0, 15) + '‚Ä¶' : key;
          drawStatLine(shortKey, pct + '%', '#ffd700');
        });
      }

      // Setup hover/click handlers (only once)
      if (!canvas._parallelismHandlersSet) {
        canvas._parallelismHandlersSet = true;

        canvas.addEventListener('mousemove', (e) => {
          if (currentView !== 'parallelism' || !parallelismBucketData) return;

          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          const pd = parallelismBucketData;

          // Check if within chart area
          if (x >= pd.padding.left && x <= pd.padding.left + pd.chartWidth &&
              y >= pd.padding.top && y <= pd.padding.top + pd.chartHeight) {
            const bucket = Math.floor((x - pd.padding.left) / (pd.chartWidth / pd.numBuckets));
            if (bucket !== parallelismHoverBucket) {
              parallelismHoverBucket = bucket;
              renderParallelismFrame();
              showParallelismTooltip(e, bucket);
            }
          } else {
            if (parallelismHoverBucket !== -1) {
              parallelismHoverBucket = -1;
              hideParallelismTooltip();
              renderParallelismFrame();
            }
          }
        });

        canvas.addEventListener('mouseleave', () => {
          if (parallelismHoverBucket !== -1) {
            parallelismHoverBucket = -1;
            hideParallelismTooltip();
            if (currentView === 'parallelism') renderParallelismFrame();
          }
        });

        canvas.addEventListener('click', (e) => {
          if (currentView !== 'parallelism' || !parallelismBucketData) return;

          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const pd = parallelismBucketData;

          if (x >= pd.padding.left && x <= pd.padding.left + pd.chartWidth) {
            const bucket = Math.floor((x - pd.padding.left) / (pd.chartWidth / pd.numBuckets));
            showParallelismDetailPanel(bucket);
          }
        });
      }
    }

    function renderParallelismFrame() {
      // Re-render without recalculating everything
      if (currentView === 'parallelism') {
        renderParallelism();
      }
    }

    function showParallelismTooltip(e, bucket) {
      if (!parallelismBucketData) return;

      const pd = parallelismBucketData;
      const bd = pd.bucketDetails[bucket];
      const timeMs = (bucket * pd.bucketSize / 1e6).toFixed(2);

      let tooltip = document.getElementById('parallelism-tooltip');
      if (!tooltip) {
        tooltip = document.createElement('div');
        tooltip.id = 'parallelism-tooltip';
        tooltip.style.cssText = `
          position: fixed; background: rgba(22, 33, 62, 0.95); border: 1px solid #0f3460;
          padding: 8px 12px; border-radius: 4px; font-size: 11px; color: #e0e0e0;
          pointer-events: none; z-index: 1000; max-width: 280px;
        `;
        document.body.appendChild(tooltip);
      }

      let html = `<div style="color: #e94560; font-weight: bold; margin-bottom: 4px;">@ ${timeMs}ms</div>`;
      html += `<div style="margin-bottom: 4px;">`;
      html += `<span style="color: #50c878;">‚ö° ${bd.executing.length} executing</span> ¬∑ `;
      html += `<span style="color: #888;">‚è≥ ${bd.waiting.length} waiting</span>`;
      html += `</div>`;

      if (bd.bottleneck) {
        const bn = bd.bottleneck;
        html += `<div style="color: #ffd700; margin-top: 4px;">‚ö†Ô∏è Bottleneck: ${bn.type} #${bn.asyncId}</div>`;
      }

      if (bd.executing.length > 0) {
        html += `<div style="margin-top: 4px; color: #aaa; font-size: 10px;">Executing:</div>`;
        bd.executing.slice(0, 4).forEach(r => {
          const isCritical = criticalPathSet.has(r.asyncId);
          html += `<div style="font-size: 10px; color: ${isCritical ? '#ff6600' : '#ccc'};">`;
          html += `${isCritical ? 'üî• ' : ''}${r.type} #${r.asyncId}</div>`;
        });
        if (bd.executing.length > 4) {
          html += `<div style="font-size: 10px; color: #666;">...+${bd.executing.length - 4} more</div>`;
        }
      }

      if (bd.waiting.length > 0 && bd.waiting.length <= 6) {
        html += `<div style="margin-top: 4px; color: #aaa; font-size: 10px;">Waiting:</div>`;
        bd.waiting.slice(0, 3).forEach(r => {
          const isCritical = criticalPathSet.has(r.asyncId);
          html += `<div style="font-size: 10px; color: ${isCritical ? '#ff6600' : '#888'};">`;
          html += `${isCritical ? 'üî• ' : ''}${r.type} #${r.asyncId}</div>`;
        });
        if (bd.waiting.length > 3) {
          html += `<div style="font-size: 10px; color: #666;">...+${bd.waiting.length - 3} more</div>`;
        }
      }

      tooltip.innerHTML = html;
      tooltip.style.left = (e.clientX + 15) + 'px';
      tooltip.style.top = (e.clientY + 15) + 'px';
      tooltip.style.display = 'block';
    }

    function hideParallelismTooltip() {
      const tooltip = document.getElementById('parallelism-tooltip');
      if (tooltip) tooltip.style.display = 'none';
    }

    function showParallelismDetailPanel(bucket) {
      if (!parallelismBucketData) return;

      const pd = parallelismBucketData;
      const bd = pd.bucketDetails[bucket];
      const timeMs = (bucket * pd.bucketSize / 1e6).toFixed(2);

      // Show in the selected details panel
      const selectedDetails = document.getElementById('selected-details');
      const timingBreakdown = document.getElementById('timing-breakdown');
      if (!selectedDetails) return;

      let html = `<div class="detail-item">
        <strong style="color: #e94560;">@ ${timeMs}ms</strong>
      </div>`;

      html += `<div class="detail-item">
        <span style="color: #50c878;">‚ö° ${bd.executing.length} executing</span><br>
        <span style="color: #888;">‚è≥ ${bd.waiting.length} waiting</span>
      </div>`;

      if (bd.bottleneck) {
        const bn = bd.bottleneck;
        html += `<div class="detail-item" style="background: rgba(255, 215, 0, 0.1); padding: 4px; border-radius: 3px;">
          <strong style="color: #ffd700;">‚ö†Ô∏è Bottleneck</strong><br>
          ${bn.type} #${bn.asyncId}
        </div>`;
      }

      if (bd.executing.length > 0) {
        html += `<div class="detail-item"><strong>Executing:</strong></div>`;
        bd.executing.forEach(r => {
          const isCritical = criticalPathSet.has(r.asyncId);
          const color = isCritical ? '#ff6600' : (TYPE_COLORS[r.type] || '#808080');
          html += `<div class="detail-item" style="padding-left: 8px; border-left: 3px solid ${color};">
            ${isCritical ? 'üî• ' : ''}<strong>${r.type}</strong> #${r.asyncId}
          </div>`;
        });
      }

      if (bd.waiting.length > 0) {
        html += `<div class="detail-item"><strong>Waiting:</strong></div>`;
        bd.waiting.slice(0, 10).forEach(r => {
          const isCritical = criticalPathSet.has(r.asyncId);
          const color = isCritical ? '#ff6600' : '#666';
          html += `<div class="detail-item" style="padding-left: 8px; border-left: 3px solid ${color}; opacity: 0.7;">
            ${isCritical ? 'üî• ' : ''}${r.type} #${r.asyncId}
          </div>`;
        });
        if (bd.waiting.length > 10) {
          html += `<div class="detail-item" style="color: #666;">...+${bd.waiting.length - 10} more waiting</div>`;
        }
      }

      selectedDetails.innerHTML = html;

      // Also update timing breakdown with summary
      if (timingBreakdown) {
        let timingHtml = `<div class="detail-item">
          <strong>Time:</strong> ${timeMs}ms
        </div>`;
        timingHtml += `<div class="detail-item">
          <strong>Parallelism:</strong> ${bd.executing.length + bd.waiting.length}
        </div>`;
        timingBreakdown.innerHTML = timingHtml;
      }
    }

    // ==================== BREAKDOWN VIEW ====================
    function renderBreakdown() {
      const container = document.getElementById('breakdown-view');
      const canvas = document.getElementById('breakdown-canvas');
      const ctx = canvas.getContext('2d');

      // Update control states
      document.getElementById('breakdown-group-select').value = breakdownGroupBy;
      document.getElementById('breakdown-viz-select').value = breakdownVizMode;

      canvas.width = canvas.parentElement.clientWidth;
      canvas.height = canvas.parentElement.clientHeight;

      const width = canvas.width;
      const height = canvas.height;
      const padding = { top: 20, right: 200, bottom: 30, left: 20 };
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;

      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, width, height);

      if (!traceData) return;

      // Update breadcrumb
      updateBreakdownBreadcrumb();

      // Gather data based on grouping mode and drill-down state
      const groupedData = computeBreakdownData();

      if (groupedData.length === 0) {
        ctx.fillStyle = '#666';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('No timing data available', width / 2, height / 2);
        return;
      }

      const totalTime = groupedData.reduce((sum, d) => sum + d.totalTime, 0);
      const duration = traceData.requestDurationNs;

      // Store data for hover/click interaction
      breakdownData = {
        items: groupedData,
        totalTime,
        duration,
        rects: [],
        padding,
        chartWidth,
        chartHeight
      };

      // Draw based on visualization mode
      if (breakdownVizMode === 'sunburst') {
        renderBreakdownSunburst(ctx, groupedData, totalTime, width, height, padding);
      } else {
        renderBreakdownTreemap(ctx, groupedData, totalTime, width, height, padding, chartWidth, chartHeight);
      }

      // Draw sidebar with stats
      renderBreakdownSidebar(ctx, groupedData, totalTime, duration, width, height, padding);

      // Setup event handlers (once)
      if (!canvas._breakdownHandlersSet) {
        canvas._breakdownHandlersSet = true;
        setupBreakdownEventHandlers(canvas);
      }
    }

    function computeBreakdownData() {
      if (!traceData) return [];

      // Determine which resources to include based on drill-down
      let resources = traceData.resources;

      // Apply drill-down filter
      if (breakdownDrillPath.length > 0) {
        const lastDrill = breakdownDrillPath[breakdownDrillPath.length - 1];
        if (lastDrill.filterFn) {
          resources = resources.filter(lastDrill.filterFn);
        }
      }

      // Check if we're at the individual resource level
      const atResourceLevel = breakdownDrillPath.length > 0 &&
        breakdownDrillPath[breakdownDrillPath.length - 1].isLeaf;

      if (atResourceLevel) {
        // Show individual resources
        return resources.map(r => {
          const syncTime = (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) ?
            r.callbackEndedAt - r.callbackStartedAt : 0;
          const asyncTime = (r.callbackStartedAt > 0 && r.createdAt > 0) ?
            r.callbackStartedAt - r.createdAt : 0;
          const totalTime = syncTime + asyncTime;
          // Wall-clock time for individual resource is its total active time
          const start = r.createdAt;
          const end = r.callbackEndedAt > 0 ? r.callbackEndedAt :
                     (r.destroyedAt > 0 ? r.destroyedAt : traceData.requestDurationNs);
          const wallClockTime = end - start;
          return {
            id: r.asyncId,
            key: `resource-${r.asyncId}`,
            label: `#${r.asyncId}`,
            type: r.type,
            resource: r,
            syncTime,
            asyncTime,
            totalTime,
            wallClockTime,
            count: 1,
            resources: [r],
            isLeaf: true,
            canDrillDown: false,
            onCriticalPath: criticalPathSet.has(r.asyncId),
            isBottleneck: false
          };
        }).filter(d => d.totalTime > 0).sort((a, b) => b.totalTime - a.totalTime);
      }

      // Group by the selected grouping mode
      const grouped = new Map();

      resources.forEach(r => {
        let key, label;

        switch (breakdownGroupBy) {
          case 'classification':
            key = r._classification || 'internal';
            label = key.charAt(0).toUpperCase() + key.slice(1);
            break;
          case 'trigger':
            // Group by root trigger (top of trigger chain)
            let root = r;
            while (root.triggerId !== 0) {
              const parent = traceData.resourceMap.get(root.triggerId);
              if (!parent) break;
              root = parent;
            }
            key = `trigger-${root.asyncId}`;
            label = `${root.type} #${root.asyncId}`;
            break;
          case 'stack':
            // Group by first user frame in stack
            const stack = traceData.stackTraces.find(s => s.id === r.stackTraceId);
            if (stack && stack.frames.length > 0) {
              // Find first non-internal frame
              const frame = stack.frames.find(f => !f.includes('node:') && !f.includes('internal/')) || stack.frames[0];
              const match = frame.match(/@ (.+):(\d+)/);
              if (match) {
                key = `${match[1]}:${match[2]}`;
                label = key.length > 30 ? '...' + key.slice(-27) : key;
              } else {
                key = frame.substring(0, 40);
                label = key;
              }
            } else {
              key = 'unknown';
              label = 'Unknown location';
            }
            break;
          case 'type':
          default:
            key = r.type;
            label = r.type;
            break;
        }

        if (!grouped.has(key)) {
          grouped.set(key, {
            key,
            label,
            type: breakdownGroupBy === 'type' ? r.type : null,
            syncTime: 0,
            asyncTime: 0,
            count: 0,
            resources: [],
            onCriticalPath: false,
            isBottleneck: false,
            wallClockTime: 0
          });
        }

        const data = grouped.get(key);
        data.count++;
        data.resources.push(r);

        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          data.syncTime += r.callbackEndedAt - r.callbackStartedAt;
        }
        if (r.callbackStartedAt > 0 && r.createdAt > 0) {
          data.asyncTime += r.callbackStartedAt - r.createdAt;
        }

        // Check if any resource in group is on critical path
        if (criticalPathSet.has(r.asyncId)) {
          data.onCriticalPath = true;
        }
      });

      // Calculate wall-clock contribution and bottleneck status
      const duration = traceData.requestDurationNs;
      const numBuckets = 200;
      const bucketSize = duration / numBuckets;

      grouped.forEach(data => {
        // Wall-clock contribution: time buckets where this group was active
        let wallClockBuckets = 0;
        let bottleneckBuckets = 0;

        for (let i = 0; i < numBuckets; i++) {
          const bucketStart = i * bucketSize;
          const bucketEnd = (i + 1) * bucketSize;

          // Check if any resource from this group is active in this bucket
          const groupActive = data.resources.some(r => {
            const start = r.createdAt;
            const end = r.callbackEndedAt > 0 ? r.callbackEndedAt :
                       (r.destroyedAt > 0 ? r.destroyedAt : duration);
            return start < bucketEnd && end > bucketStart;
          });

          if (groupActive) {
            // Wall-clock: count any bucket where this group is active
            wallClockBuckets++;

            // Bottleneck: check if this group is the ONLY thing active
            const othersActive = traceData.resources.some(r => {
              if (data.resources.includes(r)) return false;
              const start = r.createdAt;
              const end = r.callbackEndedAt > 0 ? r.callbackEndedAt :
                         (r.destroyedAt > 0 ? r.destroyedAt : duration);
              return start < bucketEnd && end > bucketStart;
            });

            if (!othersActive) {
              bottleneckBuckets++;
            }
          }
        }

        data.wallClockTime = wallClockBuckets * bucketSize;
        data.isBottleneck = bottleneckBuckets > numBuckets * 0.05;  // >5% of time as bottleneck
      });

      // Convert to array, compute canDrillDown, and sort
      const results = Array.from(grouped.values())
        .map(d => ({ ...d, totalTime: d.syncTime + d.asyncTime }))
        .filter(d => d.totalTime > 0)
        .sort((a, b) => b.totalTime - a.totalTime);

      // Compute canDrillDown for each item
      // Any group with more than 1 item can be drilled into (to see individual items or sub-groups)
      results.forEach(d => {
        d.canDrillDown = d.count > 1;
      });

      return results;
    }

    function renderBreakdownTreemap(ctx, items, totalTime, width, height, padding, chartWidth, chartHeight) {
      // Treemap layout using squarified algorithm
      function squarify(items, x, y, w, h) {
        if (items.length === 0) return [];
        const result = [];
        const total = items.reduce((sum, item) => sum + item.totalTime, 0);

        if (items.length === 1) {
          result.push({ ...items[0], x, y, w, h });
          return result;
        }

        const scale = (w * h) / total;
        const isVertical = w >= h;
        const side = isVertical ? h : w;

        let rowItems = [];
        let rowArea = 0;
        let bestWorst = Infinity;

        for (let i = 0; i < items.length; i++) {
          const testRow = [...rowItems, items[i]];
          const testArea = rowArea + items[i].totalTime;
          const rowSide = testArea * scale / side;
          let worst = 0;
          testRow.forEach(item => {
            const itemSide = (item.totalTime * scale) / rowSide;
            const aspect = Math.max(rowSide / itemSide, itemSide / rowSide);
            worst = Math.max(worst, aspect);
          });

          if (worst <= bestWorst || rowItems.length === 0) {
            rowItems = testRow;
            rowArea = testArea;
            bestWorst = worst;
          } else {
            break;
          }
        }

        const rowSize = rowArea * scale / side;
        let pos = 0;

        rowItems.forEach(item => {
          const itemSize = item.totalTime * scale / rowSize;
          if (isVertical) {
            result.push({ ...item, x: x, y: y + pos, w: rowSize, h: itemSize });
          } else {
            result.push({ ...item, x: x + pos, y: y, w: itemSize, h: rowSize });
          }
          pos += itemSize;
        });

        const remaining = items.slice(rowItems.length);
        if (remaining.length > 0) {
          if (isVertical) {
            result.push(...squarify(remaining, x + rowSize, y, w - rowSize, h));
          } else {
            result.push(...squarify(remaining, x, y + rowSize, w, h - rowSize));
          }
        }
        return result;
      }

      const rects = squarify(items, padding.left, padding.top, chartWidth, chartHeight);
      breakdownData.rects = rects;

      // Draw rectangles
      rects.forEach(rect => {
        const color = rect.type ? (TYPE_COLORS[rect.type] || '#808080') :
                     getGroupColor(rect.key);

        // Determine visual modifiers
        const isHovered = breakdownHoverItem && breakdownHoverItem.key === rect.key;
        const highlightCritical = showCriticalPath && rect.onCriticalPath;
        const highlightBottleneck = showBottlenecks && rect.isBottleneck;

        // Draw background
        if (rect.syncTime > 0 || rect.asyncTime > 0) {
          const syncRatio = rect.syncTime / rect.totalTime;
          const asyncRatio = 1 - syncRatio;

          // Async portion (top)
          if (asyncRatio > 0) {
            const asyncHeight = (rect.h - 2) * asyncRatio;
            ctx.fillStyle = color;
            ctx.globalAlpha = 0.45;
            ctx.fillRect(rect.x + 1, rect.y + 1, rect.w - 2, asyncHeight);
            ctx.globalAlpha = 1;
          }

          // Sync portion (bottom)
          if (syncRatio > 0) {
            const syncHeight = (rect.h - 2) * syncRatio;
            ctx.fillStyle = color;
            ctx.globalAlpha = 0.9;
            ctx.fillRect(rect.x + 1, rect.y + rect.h - 1 - syncHeight, rect.w - 2, syncHeight);
            ctx.globalAlpha = 1;
          }
        } else {
          ctx.fillStyle = color;
          ctx.globalAlpha = 0.7;
          ctx.fillRect(rect.x + 1, rect.y + 1, rect.w - 2, rect.h - 2);
          ctx.globalAlpha = 1;
        }

        // Border - highlight if special
        if (highlightCritical) {
          ctx.strokeStyle = '#ff6600';
          ctx.lineWidth = 3;
        } else if (highlightBottleneck) {
          ctx.strokeStyle = '#ffd700';
          ctx.lineWidth = 3;
        } else if (isHovered) {
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
        } else {
          ctx.strokeStyle = '#1a1a2e';
          ctx.lineWidth = 2;
        }
        ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);

        // Critical path indicator
        if (highlightCritical && rect.w > 30 && rect.h > 20) {
          ctx.fillStyle = '#ff6600';
          ctx.font = '10px sans-serif';
          ctx.textAlign = 'left';
          ctx.fillText('üî•', rect.x + 4, rect.y + 14);
        }

        // Bottleneck indicator
        if (highlightBottleneck && rect.w > 30 && rect.h > 20) {
          ctx.fillStyle = '#ffd700';
          ctx.font = '10px sans-serif';
          ctx.textAlign = 'right';
          ctx.fillText('‚ö†', rect.x + rect.w - 4, rect.y + 14);
        }

        // Label
        if (rect.w > 50 && rect.h > 40) {
          const isLightBg = isLightColor(color);
          ctx.fillStyle = isLightBg ? '#1a1a2e' : 'white';
          ctx.font = 'bold 12px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          let label = rect.label || rect.key;
          if (label.length > 15) label = label.substring(0, 12) + '...';
          const timeMs = (rect.totalTime / 1e6).toFixed(1);
          const pct = ((rect.totalTime / totalTime) * 100).toFixed(0);

          ctx.fillText(label, rect.x + rect.w / 2, rect.y + rect.h / 2 - 10);
          ctx.font = '11px sans-serif';
          ctx.fillText(`${timeMs}ms (${pct}%)`, rect.x + rect.w / 2, rect.y + rect.h / 2 + 6);

          // Show count
          if (rect.count > 1 && rect.h > 50) {
            ctx.font = '10px sans-serif';
            ctx.fillStyle = isLightBg ? 'rgba(26,26,46,0.7)' : 'rgba(255,255,255,0.7)';
            ctx.fillText(`${rect.count} items`, rect.x + rect.w / 2, rect.y + rect.h / 2 + 22);
          }

          // Drill-down indicator in corner for drillable items
          if (rect.canDrillDown && rect.w > 30 && rect.h > 30) {
            ctx.fillStyle = isLightBg ? 'rgba(26,26,46,0.8)' : 'rgba(126,200,227,0.9)';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'bottom';
            ctx.fillText('‚ñ∂', rect.x + rect.w - 4, rect.y + rect.h - 4);
            ctx.textBaseline = 'middle';  // Reset
          }
        } else if (rect.w > 25 && rect.h > 20) {
          const isLightBg = isLightColor(color);
          ctx.fillStyle = isLightBg ? '#1a1a2e' : 'white';
          ctx.font = '10px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          const shortLabel = (rect.label || rect.key).substring(0, 4);
          ctx.fillText(shortLabel, rect.x + rect.w / 2, rect.y + rect.h / 2);
        }
      });

      // Legend
      const legendY = height - 18;
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'left';

      ctx.globalAlpha = 0.9;
      ctx.fillStyle = '#666';
      ctx.fillRect(padding.left, legendY - 6, 10, 10);
      ctx.globalAlpha = 0.45;
      ctx.fillRect(padding.left + 75, legendY - 6, 10, 10);
      ctx.globalAlpha = 1;

      ctx.fillStyle = '#888';
      ctx.fillText('= Sync', padding.left + 14, legendY + 2);
      ctx.fillText('= Async', padding.left + 89, legendY + 2);

      // Drill-down hint
      ctx.fillStyle = '#666';
      ctx.fillText('‚ñ∂ = click to drill down', padding.left + 160, legendY + 2);
    }

    function renderBreakdownSunburst(ctx, items, totalTime, width, height, padding) {
      const centerX = padding.left + (width - padding.left - padding.right) / 2;
      const centerY = padding.top + (height - padding.top - padding.bottom) / 2;
      const maxRadius = Math.min(width - padding.left - padding.right, height - padding.top - padding.bottom) / 2 - 20;
      const innerRadius = maxRadius * 0.2;

      // Store rects as arc segments for hit detection
      breakdownData.rects = [];
      breakdownData.sunburstCenter = { x: centerX, y: centerY };
      breakdownData.sunburstInnerRadius = innerRadius;
      breakdownData.sunburstOuterRadius = maxRadius;

      let currentAngle = -Math.PI / 2;  // Start at top

      items.forEach(item => {
        const angleSize = (item.totalTime / totalTime) * Math.PI * 2;
        const endAngle = currentAngle + angleSize;

        const color = item.type ? (TYPE_COLORS[item.type] || '#808080') : getGroupColor(item.key);
        const isHovered = breakdownHoverItem && breakdownHoverItem.key === item.key;
        const highlightCritical = showCriticalPath && item.onCriticalPath;
        const highlightBottleneck = showBottlenecks && item.isBottleneck;

        // Calculate radii for sync/async split
        const syncRatio = item.syncTime / item.totalTime;
        const asyncRadius = innerRadius + (maxRadius - innerRadius) * (1 - syncRatio);

        // Draw async portion (outer)
        if (syncRatio < 1) {
          ctx.beginPath();
          ctx.arc(centerX, centerY, maxRadius, currentAngle, endAngle);
          ctx.arc(centerX, centerY, asyncRadius, endAngle, currentAngle, true);
          ctx.closePath();
          ctx.fillStyle = color;
          ctx.globalAlpha = 0.45;
          ctx.fill();
          ctx.globalAlpha = 1;
        }

        // Draw sync portion (inner)
        if (syncRatio > 0) {
          ctx.beginPath();
          ctx.arc(centerX, centerY, asyncRadius, currentAngle, endAngle);
          ctx.arc(centerX, centerY, innerRadius, endAngle, currentAngle, true);
          ctx.closePath();
          ctx.fillStyle = color;
          ctx.globalAlpha = 0.9;
          ctx.fill();
          ctx.globalAlpha = 1;
        }

        // Border
        ctx.beginPath();
        ctx.arc(centerX, centerY, maxRadius, currentAngle, endAngle);
        ctx.arc(centerX, centerY, innerRadius, endAngle, currentAngle, true);
        ctx.closePath();
        if (highlightCritical) {
          ctx.strokeStyle = '#ff6600';
          ctx.lineWidth = 3;
        } else if (highlightBottleneck) {
          ctx.strokeStyle = '#ffd700';
          ctx.lineWidth = 3;
        } else if (isHovered) {
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
        } else {
          ctx.strokeStyle = '#1a1a2e';
          ctx.lineWidth = 1;
        }
        ctx.stroke();

        // Store for hit detection
        breakdownData.rects.push({
          ...item,
          startAngle: currentAngle,
          endAngle: endAngle,
          innerRadius,
          outerRadius: maxRadius
        });

        // Label (if segment is big enough)
        if (angleSize > 0.2) {
          const midAngle = currentAngle + angleSize / 2;
          const labelRadius = (innerRadius + maxRadius) / 2;
          const labelX = centerX + Math.cos(midAngle) * labelRadius;
          const labelY = centerY + Math.sin(midAngle) * labelRadius;

          ctx.save();
          ctx.translate(labelX, labelY);
          if (midAngle > Math.PI / 2 && midAngle < 3 * Math.PI / 2) {
            ctx.rotate(midAngle + Math.PI);
          } else {
            ctx.rotate(midAngle);
          }

          const isLightBg = isLightColor(color);
          ctx.fillStyle = isLightBg ? '#1a1a2e' : 'white';
          ctx.font = 'bold 11px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          let label = item.label || item.key;
          if (label.length > 12) label = label.substring(0, 9) + '...';
          ctx.fillText(label, 0, -6);

          ctx.font = '10px sans-serif';
          const pct = ((item.totalTime / totalTime) * 100).toFixed(0);
          const drillIndicator = item.canDrillDown ? ' ‚ñ∂' : '';
          ctx.fillText(`${pct}%${drillIndicator}`, 0, 6);

          ctx.restore();
        }

        currentAngle = endAngle;
      });

      // Center hole
      ctx.beginPath();
      ctx.arc(centerX, centerY, innerRadius, 0, Math.PI * 2);
      ctx.fillStyle = '#1a1a2e';
      ctx.fill();

      // Center text
      ctx.fillStyle = '#e94560';
      ctx.font = 'bold 12px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('Total', centerX, centerY - 8);
      ctx.font = '11px sans-serif';
      ctx.fillStyle = '#aaa';
      ctx.fillText((totalTime / 1e6).toFixed(1) + 'ms', centerX, centerY + 8);

      // Legend at bottom
      const legendY = height - 18;
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillStyle = '#888';
      ctx.fillText('Inner = Sync, Outer = Async | Click segment to drill down', padding.left, legendY + 2);
    }

    function renderBreakdownSidebar(ctx, items, totalTime, duration, width, height, padding) {
      const sidebarX = width - padding.right + 10;
      const sidebarWidth = padding.right - 20;
      const sidebarY = padding.top;
      const sidebarHeight = height - padding.top - padding.bottom;

      // Background
      ctx.fillStyle = 'rgba(22, 33, 62, 0.95)';
      ctx.fillRect(sidebarX, sidebarY, sidebarWidth, sidebarHeight);
      ctx.strokeStyle = '#0f3460';
      ctx.strokeRect(sidebarX, sidebarY, sidebarWidth, sidebarHeight);

      let y = sidebarY + 18;
      const lineHeight = 15;

      const drawHeader = (text, color = '#e94560') => {
        ctx.fillStyle = color;
        ctx.font = 'bold 11px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(text, sidebarX + 8, y);
        y += lineHeight + 2;
      };

      const drawStat = (label, value, color = '#aaa') => {
        ctx.fillStyle = '#888';
        ctx.font = '10px sans-serif';
        ctx.fillText(label + ':', sidebarX + 8, y);
        ctx.fillStyle = color;
        ctx.textAlign = 'right';
        ctx.fillText(String(value), sidebarX + sidebarWidth - 8, y);
        ctx.textAlign = 'left';
        y += lineHeight;
      };

      // Summary stats
      drawHeader('Summary');
      drawStat('Groups', items.length);
      drawStat('Total time', (totalTime / 1e6).toFixed(1) + 'ms');

      // Wall-clock attribution
      const totalWallClock = items.reduce((sum, d) => sum + d.wallClockTime, 0);
      const overlapTime = totalTime - totalWallClock;
      drawStat('Wall-clock', (totalWallClock / 1e6).toFixed(1) + 'ms');
      drawStat('Parallel gain', (overlapTime / 1e6).toFixed(1) + 'ms',
        overlapTime > 0 ? '#50c878' : '#888');
      y += 8;

      // Top items
      drawHeader('Top by Time');
      items.slice(0, 5).forEach(item => {
        const pct = ((item.totalTime / totalTime) * 100).toFixed(0);
        let label = item.label || item.key;
        if (label.length > 12) label = label.substring(0, 9) + '...';

        const color = item.type ? (TYPE_COLORS[item.type] || '#808080') : getGroupColor(item.key);
        ctx.fillStyle = color;
        ctx.fillRect(sidebarX + 8, y - 8, 8, 8);

        ctx.fillStyle = '#aaa';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(label, sidebarX + 20, y);
        ctx.textAlign = 'right';

        let suffix = '';
        if (showCriticalPath && item.onCriticalPath) suffix = ' üî•';
        if (showBottlenecks && item.isBottleneck) suffix += ' ‚ö†';
        ctx.fillText(pct + '%' + suffix, sidebarX + sidebarWidth - 8, y);
        ctx.textAlign = 'left';
        y += lineHeight;
      });
      y += 8;

      // Critical path items (if enabled)
      if (showCriticalPath) {
        const cpItems = items.filter(d => d.onCriticalPath);
        if (cpItems.length > 0) {
          drawHeader('Critical Path', '#ff6600');
          cpItems.slice(0, 3).forEach(item => {
            let label = item.label || item.key;
            if (label.length > 15) label = label.substring(0, 12) + '...';
            ctx.fillStyle = '#ff6600';
            ctx.font = '10px sans-serif';
            ctx.fillText('üî• ' + label, sidebarX + 8, y);
            y += lineHeight;
          });
          y += 8;
        }
      }

      // Bottleneck items (if enabled)
      if (showBottlenecks) {
        const bnItems = items.filter(d => d.isBottleneck);
        if (bnItems.length > 0) {
          drawHeader('Bottlenecks', '#ffd700');
          bnItems.slice(0, 3).forEach(item => {
            let label = item.label || item.key;
            if (label.length > 15) label = label.substring(0, 12) + '...';
            const wallPct = ((item.wallClockTime / duration) * 100).toFixed(0);
            ctx.fillStyle = '#ffd700';
            ctx.font = '10px sans-serif';
            ctx.fillText('‚ö† ' + label, sidebarX + 8, y);
            ctx.textAlign = 'right';
            ctx.fillText(wallPct + '% wall', sidebarX + sidebarWidth - 8, y);
            ctx.textAlign = 'left';
            y += lineHeight;
          });
        }
      }
    }

    function getGroupColor(key) {
      // Generate consistent color for non-type groups
      const colors = ['#e94560', '#0f4c75', '#3282b8', '#bbe1fa', '#50c878',
                      '#ffd700', '#ff6432', '#9966cc', '#00bcd4', '#ff9800'];
      let hash = 0;
      for (let i = 0; i < key.length; i++) {
        hash = ((hash << 5) - hash) + key.charCodeAt(i);
        hash |= 0;
      }
      return colors[Math.abs(hash) % colors.length];
    }

    function updateBreakdownBreadcrumb() {
      const breadcrumb = document.getElementById('breakdown-breadcrumb');
      if (!breadcrumb) return;

      if (breakdownDrillPath.length === 0) {
        breadcrumb.innerHTML = '';
        return;
      }

      let html = '<span style="cursor: pointer; color: #7ec8e3;" onclick="breakdownNavigateToRoot()">All</span>';
      breakdownDrillPath.forEach((crumb, i) => {
        html += ' ‚Ä∫ ';
        if (i === breakdownDrillPath.length - 1) {
          html += `<span style="color: #e94560;">${crumb.label}</span>`;
        } else {
          html += `<span style="cursor: pointer; color: #7ec8e3;" onclick="breakdownNavigateTo(${i})">${crumb.label}</span>`;
        }
      });
      breadcrumb.innerHTML = html;
    }

    // Global navigation functions for breadcrumb clicks
    window.breakdownNavigateToRoot = function() {
      breakdownDrillPath = [];
      renderBreakdown();
    };

    window.breakdownNavigateTo = function(index) {
      breakdownDrillPath = breakdownDrillPath.slice(0, index + 1);
      renderBreakdown();
    };

    function setupBreakdownEventHandlers(canvas) {
      // Group select handler
      document.getElementById('breakdown-group-select').addEventListener('change', (e) => {
        breakdownGroupBy = e.target.value;
        breakdownDrillPath = [];  // Reset drill-down when changing grouping
        saveSettings();
        renderBreakdown();
      });

      // Viz select handler
      document.getElementById('breakdown-viz-select').addEventListener('change', (e) => {
        breakdownVizMode = e.target.value;
        saveSettings();
        renderBreakdown();
      });

      // Hover handler
      canvas.addEventListener('mousemove', (e) => {
        if (currentView !== 'breakdown' || !breakdownData) return;

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const hitItem = findBreakdownHit(x, y);

        // Update cursor based on drillability
        canvas.style.cursor = (hitItem && hitItem.canDrillDown) ? 'pointer' : 'default';

        if (hitItem !== breakdownHoverItem) {
          breakdownHoverItem = hitItem;
          renderBreakdown();
          if (hitItem) {
            showBreakdownTooltip(e, hitItem);
          } else {
            hideBreakdownTooltip();
          }
        } else if (hitItem) {
          // Update tooltip position
          updateBreakdownTooltipPosition(e);
        }
      });

      canvas.addEventListener('mouseleave', () => {
        if (breakdownHoverItem) {
          breakdownHoverItem = null;
          hideBreakdownTooltip();
          if (currentView === 'breakdown') renderBreakdown();
        }
      });

      // Click handler for drill-down
      canvas.addEventListener('click', (e) => {
        if (currentView !== 'breakdown' || !breakdownData) return;

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const hitItem = findBreakdownHit(x, y);
        if (hitItem && hitItem.canDrillDown && hitItem.resources && hitItem.resources.length > 1) {
          // Check if drilling would result in same single group by computing unique keys
          const uniqueKeys = new Set();
          const resourceMap = new Map(traceData.resources.map(r => [r.asyncId, r]));

          hitItem.resources.forEach(r => {
            let key;
            if (breakdownGroupBy === 'type') {
              key = r.type;
            } else if (breakdownGroupBy === 'classification') {
              key = r._classification || 'internal';
            } else if (breakdownGroupBy === 'trigger') {
              // Must trace to root ancestor (same as grouping logic)
              let root = r;
              while (root.triggerId > 0) {
                const parent = resourceMap.get(root.triggerId);
                if (!parent) break;
                root = parent;
              }
              key = `trigger-${root.asyncId}`;
            } else if (breakdownGroupBy === 'stack') {
              key = r.stackTraceId;
            }
            uniqueKeys.add(key);
          });

          const wouldBeSameGroup = uniqueKeys.size <= 1;

          // Drill down into this item
          breakdownDrillPath.push({
            label: hitItem.label || hitItem.key,
            key: hitItem.key,
            filterFn: (r) => hitItem.resources.some(hr => hr.asyncId === r.asyncId),
            // Show individual items if small group OR if drilling would just show same group
            isLeaf: hitItem.count <= 10 || wouldBeSameGroup
          });
          hideBreakdownTooltip();
          breakdownHoverItem = null;
          renderBreakdown();
        } else if (hitItem && hitItem.resource) {
          // Individual resource - show in sidebar
          selectResource(hitItem.resource.asyncId);
        }
      });
    }

    function findBreakdownHit(x, y) {
      if (!breakdownData || !breakdownData.rects) return null;

      if (breakdownVizMode === 'sunburst' && breakdownData.sunburstCenter) {
        // Sunburst hit detection
        const cx = breakdownData.sunburstCenter.x;
        const cy = breakdownData.sunburstCenter.y;
        const dx = x - cx;
        const dy = y - cy;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);

        for (const item of breakdownData.rects) {
          if (dist >= item.innerRadius && dist <= item.outerRadius) {
            // Normalize angles for comparison
            let a = angle;
            let start = item.startAngle;
            let end = item.endAngle;

            // Handle angle wrap-around
            while (a < start) a += Math.PI * 2;
            while (end < start) end += Math.PI * 2;

            if (a >= start && a <= end) {
              return item;
            }
          }
        }
      } else {
        // Treemap hit detection
        for (const rect of breakdownData.rects) {
          if (x >= rect.x && x <= rect.x + rect.w &&
              y >= rect.y && y <= rect.y + rect.h) {
            return rect;
          }
        }
      }
      return null;
    }

    function showBreakdownTooltip(e, item) {
      let tooltip = document.getElementById('breakdown-tooltip');
      if (!tooltip) {
        tooltip = document.createElement('div');
        tooltip.id = 'breakdown-tooltip';
        tooltip.style.cssText = `
          position: fixed; background: rgba(22, 33, 62, 0.95); border: 1px solid #0f3460;
          padding: 10px 14px; border-radius: 4px; font-size: 11px; color: #e0e0e0;
          pointer-events: none; z-index: 1000; max-width: 300px;
        `;
        document.body.appendChild(tooltip);
      }

      const totalTime = breakdownData.totalTime;
      const duration = breakdownData.duration;
      const pct = ((item.totalTime / totalTime) * 100).toFixed(1);
      const wallPct = ((item.wallClockTime / duration) * 100).toFixed(1);
      const syncPct = item.totalTime > 0 ? ((item.syncTime / item.totalTime) * 100).toFixed(0) : 0;

      // Show full key (untruncated) with word-wrap for long paths
      const fullName = item.key || item.label || 'Unknown';
      let html = `<div style="font-weight: bold; color: #e94560; margin-bottom: 6px; word-break: break-all;">${fullName}</div>`;
      html += `<div style="display: grid; grid-template-columns: auto auto; gap: 2px 12px;">`;
      html += `<span style="color: #888;">Count:</span><span>${item.count}</span>`;
      html += `<span style="color: #888;">Total time:</span><span>${(item.totalTime / 1e6).toFixed(2)}ms (${pct}%)</span>`;
      html += `<span style="color: #888;">Sync:</span><span>${(item.syncTime / 1e6).toFixed(2)}ms (${syncPct}%)</span>`;
      html += `<span style="color: #888;">Async:</span><span>${(item.asyncTime / 1e6).toFixed(2)}ms</span>`;
      html += `<span style="color: #888;">Wall-clock:</span><span>${(item.wallClockTime / 1e6).toFixed(2)}ms (${wallPct}%)</span>`;
      html += `</div>`;

      if (item.onCriticalPath) {
        html += `<div style="color: #ff6600; margin-top: 6px;">üî• On critical path</div>`;
      }
      if (item.isBottleneck) {
        html += `<div style="color: #ffd700; margin-top: 4px;">‚ö† Bottleneck - serializes execution</div>`;
      }
      if (item.canDrillDown) {
        html += `<div style="color: #7ec8e3; margin-top: 6px; font-size: 10px;">‚ñ∂ Click to drill down</div>`;
      } else if (item.count === 1) {
        html += `<div style="color: #666; margin-top: 6px; font-size: 10px;">Single item</div>`;
      }

      tooltip.innerHTML = html;
      tooltip.style.left = (e.clientX + 15) + 'px';
      tooltip.style.top = (e.clientY + 15) + 'px';
      tooltip.style.display = 'block';
    }

    function updateBreakdownTooltipPosition(e) {
      const tooltip = document.getElementById('breakdown-tooltip');
      if (tooltip) {
        tooltip.style.left = (e.clientX + 15) + 'px';
        tooltip.style.top = (e.clientY + 15) + 'px';
      }
    }

    function hideBreakdownTooltip() {
      const tooltip = document.getElementById('breakdown-tooltip');
      if (tooltip) tooltip.style.display = 'none';
    }

    // ==================== LATENCY VIEW ====================
    function renderLatency() {
      const container = document.getElementById('latency-view');
      const canvas = document.getElementById('latency-canvas');
      const ctx = canvas.getContext('2d');

      // Account for controls height
      const controls = document.getElementById('latency-controls');
      const controlsHeight = controls ? controls.offsetHeight : 0;
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight - controlsHeight;

      const width = canvas.width;
      const height = canvas.height;
      const padding = { top: 50, right: 200, bottom: 80, left: 70 };
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;

      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, width, height);

      if (!traceData) return;

      // Collect async wait times (latencies) for all resources
      const latencies = [];
      traceData.resources.forEach(r => {
        if (r.callbackStartedAt > 0 && r.createdAt > 0) {
          const latencyNs = r.callbackStartedAt - r.createdAt;
          if (latencyNs > 0) {
            latencies.push({
              latencyNs,
              latencyMs: latencyNs / 1e6,
              resource: r,
              onCriticalPath: criticalPathSet.has(r.asyncId)
            });
          }
        }
      });

      if (latencies.length === 0) {
        ctx.fillStyle = '#666';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('No latency data available', width / 2, height / 2);
        return;
      }

      // Sort by latency for percentile calculations
      latencies.sort((a, b) => a.latencyNs - b.latencyNs);

      const minLatency = latencies[0].latencyMs;
      const maxLatency = latencies[latencies.length - 1].latencyMs;
      const p50 = latencies[Math.floor(latencies.length * 0.5)].latencyMs;
      const p90 = latencies[Math.floor(latencies.length * 0.9)].latencyMs;
      const p99 = latencies[Math.floor(latencies.length * 0.99)].latencyMs;
      const avgLatency = latencies.reduce((s, l) => s + l.latencyMs, 0) / latencies.length;

      // Calculate standard deviation for outlier detection
      const variance = latencies.reduce((s, l) => s + Math.pow(l.latencyMs - avgLatency, 2), 0) / latencies.length;
      const stdDev = Math.sqrt(variance);
      const outlierThreshold = avgLatency + 3 * stdDev;
      const outliers = latencies.filter(l => l.latencyMs > outlierThreshold);

      // Create histogram buckets (logarithmic scale for wide range)
      const numBuckets = Math.min(50, Math.floor(chartWidth / 15));
      const useLogScale = maxLatency / Math.max(minLatency, 0.001) > 100;

      let buckets;
      if (useLogScale) {
        const logMin = Math.log10(Math.max(minLatency, 0.001));
        const logMax = Math.log10(maxLatency);
        const logStep = (logMax - logMin) / numBuckets;
        buckets = Array.from({ length: numBuckets }, (_, i) => ({
          min: Math.pow(10, logMin + i * logStep),
          max: Math.pow(10, logMin + (i + 1) * logStep),
          count: 0,
          criticalCount: 0,
          outlierCount: 0,
          byType: new Map(),
          resources: []
        }));
      } else {
        const step = (maxLatency - minLatency) / numBuckets || 1;
        buckets = Array.from({ length: numBuckets }, (_, i) => ({
          min: minLatency + i * step,
          max: minLatency + (i + 1) * step,
          count: 0,
          criticalCount: 0,
          outlierCount: 0,
          byType: new Map(),
          resources: []
        }));
      }

      // Fill buckets
      latencies.forEach(l => {
        for (let i = 0; i < buckets.length; i++) {
          if (l.latencyMs >= buckets[i].min && (l.latencyMs < buckets[i].max || i === buckets.length - 1)) {
            buckets[i].count++;
            buckets[i].resources.push(l);
            if (l.onCriticalPath) buckets[i].criticalCount++;
            if (l.latencyMs > outlierThreshold) buckets[i].outlierCount++;
            const type = l.resource.type;
            buckets[i].byType.set(type, (buckets[i].byType.get(type) || 0) + 1);
            break;
          }
        }
      });

      // Store bucket data for hit detection
      const barWidth = chartWidth / buckets.length;
      latencyBucketData = {
        buckets,
        barWidth,
        padding,
        chartHeight,
        chartWidth,
        height,
        width,
        useLogScale,
        minLatency,
        maxLatency,
        latencies,
        outlierThreshold,
        p50, p90, p99, avgLatency, stdDev
      };

      const maxCount = Math.max(...buckets.map(b => b.count), 1);

      // Draw title
      ctx.fillStyle = '#e94560';
      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'center';
      const title = latencyMode === 'cdf' ? 'Async Wait Time CDF (Cumulative Distribution)' : 'Async Wait Time Distribution (Histogram)';
      ctx.fillText(title, (width - padding.right + padding.left) / 2, 25);

      // Draw axes
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding.left, padding.top);
      ctx.lineTo(padding.left, height - padding.bottom);
      ctx.lineTo(width - padding.right, height - padding.bottom);
      ctx.stroke();

      // Y-axis labels
      ctx.fillStyle = '#888';
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'right';
      const yMax = latencyMode === 'cdf' ? 100 : maxCount;
      for (let i = 0; i <= 5; i++) {
        const y = padding.top + (1 - i / 5) * chartHeight;
        const value = latencyMode === 'cdf' ? (i * 20) + '%' : Math.round((i / 5) * maxCount).toString();
        ctx.fillText(value, padding.left - 8, y + 3);

        ctx.strokeStyle = '#333';
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(width - padding.right, y);
        ctx.stroke();
      }

      // Y-axis title
      ctx.save();
      ctx.translate(15, height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillStyle = '#888';
      ctx.font = '11px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(latencyMode === 'cdf' ? 'Cumulative %' : 'Count', 0, 0);
      ctx.restore();

      // Get all types for legend
      const allTypes = new Set();
      buckets.forEach(b => b.byType.forEach((_, type) => allTypes.add(type)));
      const sortedTypes = Array.from(allTypes).sort((a, b) => {
        const countA = buckets.reduce((s, b) => s + (b.byType.get(a) || 0), 0);
        const countB = buckets.reduce((s, b) => s + (b.byType.get(b) || 0), 0);
        return countB - countA;
      });

      if (latencyMode === 'cdf') {
        // Draw CDF curve
        ctx.beginPath();
        ctx.strokeStyle = '#7ec8e3';
        ctx.lineWidth = 2.5;
        let cumulative = 0;
        const totalCount = latencies.length;

        latencies.forEach((l, i) => {
          cumulative++;
          const pct = (cumulative / totalCount) * 100;
          let x;
          if (useLogScale) {
            const logMin = Math.log10(Math.max(minLatency, 0.001));
            const logMax = Math.log10(maxLatency);
            const logVal = Math.log10(Math.max(l.latencyMs, 0.001));
            x = padding.left + ((logVal - logMin) / (logMax - logMin)) * chartWidth;
          } else {
            x = padding.left + ((l.latencyMs - minLatency) / (maxLatency - minLatency)) * chartWidth;
          }
          const y = padding.top + (1 - pct / 100) * chartHeight;

          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        ctx.stroke();

        // Fill under curve
        ctx.lineTo(width - padding.right, height - padding.bottom);
        ctx.lineTo(padding.left, height - padding.bottom);
        ctx.closePath();
        ctx.fillStyle = 'rgba(126, 200, 227, 0.15)';
        ctx.fill();

        // Draw critical path CDF if enabled
        if (showCriticalPath) {
          const criticalLatencies = latencies.filter(l => l.onCriticalPath);
          if (criticalLatencies.length > 0) {
            ctx.beginPath();
            ctx.strokeStyle = '#ff6600';
            ctx.lineWidth = 2;
            let critCum = 0;
            criticalLatencies.forEach((l, i) => {
              critCum++;
              const pct = (critCum / criticalLatencies.length) * 100;
              let x;
              if (useLogScale) {
                const logMin = Math.log10(Math.max(minLatency, 0.001));
                const logMax = Math.log10(maxLatency);
                const logVal = Math.log10(Math.max(l.latencyMs, 0.001));
                x = padding.left + ((logVal - logMin) / (logMax - logMin)) * chartWidth;
              } else {
                x = padding.left + ((l.latencyMs - minLatency) / (maxLatency - minLatency)) * chartWidth;
              }
              const y = padding.top + (1 - pct / 100) * chartHeight;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            });
            ctx.stroke();
          }
        }
      } else {
        // Draw histogram bars
        buckets.forEach((bucket, i) => {
          const x = padding.left + i * barWidth;
          let y = height - padding.bottom;
          const isHovered = latencyHoverBucket === i;
          const hasOutliers = bucket.outlierCount > 0;
          const hasCritical = showCriticalPath && bucket.criticalCount > 0;

          // Draw stacked bars by type
          sortedTypes.forEach(type => {
            const count = bucket.byType.get(type) || 0;
            if (count > 0) {
              const barHeight = (count / maxCount) * chartHeight;
              ctx.fillStyle = TYPE_COLORS[type] || '#808080';
              ctx.globalAlpha = isHovered ? 1 : 0.85;
              ctx.fillRect(x + 1, y - barHeight, barWidth - 2, barHeight);
              y -= barHeight;
            }
          });
          ctx.globalAlpha = 1;

          // Highlight outlier buckets
          if (latencyShowOutliers && hasOutliers) {
            const barHeight = (bucket.count / maxCount) * chartHeight;
            ctx.strokeStyle = '#ff6347';
            ctx.lineWidth = 2;
            ctx.strokeRect(x + 1, height - padding.bottom - barHeight, barWidth - 2, barHeight);
          }

          // Highlight critical path buckets
          if (hasCritical) {
            const barHeight = (bucket.count / maxCount) * chartHeight;
            ctx.strokeStyle = '#ff6600';
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 3]);
            ctx.strokeRect(x + 2, height - padding.bottom - barHeight + 1, barWidth - 4, barHeight - 2);
            ctx.setLineDash([]);
          }

          // Hover highlight
          if (isHovered) {
            const barHeight = (bucket.count / maxCount) * chartHeight;
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, height - padding.bottom - barHeight - 1, barWidth, barHeight + 2);
          }
        });
      }

      // X-axis labels
      ctx.fillStyle = '#888';
      ctx.font = '9px sans-serif';
      ctx.textAlign = 'center';
      const labelInterval = Math.ceil(buckets.length / 8);
      buckets.forEach((bucket, i) => {
        if (i % labelInterval === 0 || i === buckets.length - 1) {
          const x = padding.left + (i + 0.5) * barWidth;
          const label = bucket.min < 1 ? `${(bucket.min * 1000).toFixed(0)}¬µs` : `${bucket.min.toFixed(1)}ms`;
          ctx.fillText(label, x, height - padding.bottom + 15);
        }
      });

      // X-axis title
      ctx.fillStyle = '#888';
      ctx.font = '11px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Async Wait Time' + (useLogScale ? ' (log scale)' : ''), (width - padding.right + padding.left) / 2, height - padding.bottom + 35);

      // Draw percentile lines
      function drawPercentileLine(value, label, color) {
        let x;
        if (useLogScale) {
          const logMin = Math.log10(Math.max(minLatency, 0.001));
          const logMax = Math.log10(maxLatency);
          const logVal = Math.log10(Math.max(value, 0.001));
          x = padding.left + ((logVal - logMin) / (logMax - logMin)) * chartWidth;
        } else {
          x = padding.left + ((value - minLatency) / (maxLatency - minLatency)) * chartWidth;
        }

        if (x >= padding.left && x <= width - padding.right) {
          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
          ctx.setLineDash([4, 4]);
          ctx.beginPath();
          ctx.moveTo(x, padding.top);
          ctx.lineTo(x, height - padding.bottom);
          ctx.stroke();
          ctx.setLineDash([]);

          ctx.fillStyle = color;
          ctx.font = '9px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText(label, x, padding.top - 5);
        }
      }

      drawPercentileLine(p50, 'p50', '#50c878');
      drawPercentileLine(p90, 'p90', '#ffd700');
      drawPercentileLine(p99, 'p99', '#ff6347');

      // Stats sidebar
      const sbX = width - padding.right + 10;
      const sbWidth = padding.right - 20;

      ctx.fillStyle = 'rgba(22, 33, 62, 0.95)';
      ctx.fillRect(sbX, padding.top, sbWidth, chartHeight);
      ctx.strokeStyle = '#0f3460';
      ctx.strokeRect(sbX, padding.top, sbWidth, chartHeight);

      let sbY = padding.top + 15;
      ctx.fillStyle = '#e94560';
      ctx.font = 'bold 11px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText('Statistics', sbX + 10, sbY);
      sbY += 18;

      ctx.font = '10px sans-serif';
      ctx.fillStyle = '#aaa';
      ctx.fillText(`Count: ${latencies.length}`, sbX + 10, sbY); sbY += 14;
      ctx.fillText(`Min: ${formatLatency(minLatency)}`, sbX + 10, sbY); sbY += 14;
      ctx.fillText(`Avg: ${formatLatency(avgLatency)}`, sbX + 10, sbY); sbY += 14;
      ctx.fillText(`Max: ${formatLatency(maxLatency)}`, sbX + 10, sbY); sbY += 14;
      ctx.fillText(`Std Dev: ${formatLatency(stdDev)}`, sbX + 10, sbY); sbY += 20;

      // Percentiles
      ctx.fillStyle = '#e94560';
      ctx.font = 'bold 10px sans-serif';
      ctx.fillText('Percentiles', sbX + 10, sbY); sbY += 14;
      ctx.font = '10px sans-serif';
      ctx.fillStyle = '#50c878';
      ctx.fillText(`p50: ${formatLatency(p50)}`, sbX + 10, sbY); sbY += 14;
      ctx.fillStyle = '#ffd700';
      ctx.fillText(`p90: ${formatLatency(p90)}`, sbX + 10, sbY); sbY += 14;
      ctx.fillStyle = '#ff6347';
      ctx.fillText(`p99: ${formatLatency(p99)}`, sbX + 10, sbY); sbY += 20;

      // Outliers
      if (latencyShowOutliers && outliers.length > 0) {
        ctx.fillStyle = '#e94560';
        ctx.font = 'bold 10px sans-serif';
        ctx.fillText('Outliers (>3œÉ)', sbX + 10, sbY); sbY += 14;
        ctx.font = '10px sans-serif';
        ctx.fillStyle = '#ff6347';
        ctx.fillText(`Count: ${outliers.length}`, sbX + 10, sbY); sbY += 14;
        ctx.fillStyle = '#aaa';
        ctx.fillText(`Threshold: ${formatLatency(outlierThreshold)}`, sbX + 10, sbY); sbY += 20;
      }

      // Critical path stats
      if (showCriticalPath) {
        const criticalLatencies = latencies.filter(l => l.onCriticalPath);
        if (criticalLatencies.length > 0) {
          ctx.fillStyle = '#ff6600';
          ctx.font = 'bold 10px sans-serif';
          ctx.fillText('Critical Path', sbX + 10, sbY); sbY += 14;
          ctx.font = '10px sans-serif';
          ctx.fillStyle = '#aaa';
          ctx.fillText(`Count: ${criticalLatencies.length}`, sbX + 10, sbY); sbY += 14;
          const critAvg = criticalLatencies.reduce((s, l) => s + l.latencyMs, 0) / criticalLatencies.length;
          ctx.fillText(`Avg: ${formatLatency(critAvg)}`, sbX + 10, sbY); sbY += 20;
        }
      }

      // Legend
      ctx.fillStyle = '#e94560';
      ctx.font = 'bold 10px sans-serif';
      ctx.fillText('Types', sbX + 10, sbY); sbY += 14;
      ctx.font = '9px sans-serif';
      sortedTypes.slice(0, 8).forEach(type => {
        ctx.fillStyle = TYPE_COLORS[type] || '#808080';
        ctx.fillRect(sbX + 10, sbY - 8, 10, 10);
        ctx.fillStyle = '#aaa';
        const label = type.length > 12 ? type.substring(0, 10) + '..' : type;
        ctx.fillText(label, sbX + 24, sbY);
        sbY += 13;
      });

      // Setup event handlers (once)
      if (!canvas._latencyHandlersSet) {
        canvas._latencyHandlersSet = true;
        setupLatencyEventHandlers(canvas);
      }
    }

    function formatLatency(ms) {
      if (ms < 0.001) return `${(ms * 1e6).toFixed(0)}ns`;
      if (ms < 1) return `${(ms * 1000).toFixed(0)}¬µs`;
      return `${ms.toFixed(2)}ms`;
    }

    function setupLatencyEventHandlers(canvas) {
      // Mode select handler
      document.getElementById('latency-mode-select').addEventListener('change', (e) => {
        latencyMode = e.target.value;
        renderLatency();
      });

      // Outliers checkbox handler
      document.getElementById('latency-outliers-checkbox').addEventListener('change', (e) => {
        latencyShowOutliers = e.target.checked;
        renderLatency();
      });

      // Hover handler
      canvas.addEventListener('mousemove', (e) => {
        if (currentView !== 'latency' || !latencyBucketData || latencyMode === 'cdf') {
          canvas.style.cursor = 'default';
          return;
        }

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const { buckets, barWidth, padding, chartHeight, height } = latencyBucketData;

        // Find which bucket is hovered
        let hoveredBucket = -1;
        if (x >= padding.left && x <= padding.left + buckets.length * barWidth &&
            y >= padding.top && y <= height - padding.bottom) {
          hoveredBucket = Math.floor((x - padding.left) / barWidth);
          if (hoveredBucket >= buckets.length) hoveredBucket = buckets.length - 1;
        }

        canvas.style.cursor = hoveredBucket >= 0 ? 'pointer' : 'default';

        if (hoveredBucket !== latencyHoverBucket) {
          latencyHoverBucket = hoveredBucket;
          renderLatency();
          if (hoveredBucket >= 0) {
            showLatencyTooltip(e, buckets[hoveredBucket]);
          } else {
            hideLatencyTooltip();
          }
        } else if (hoveredBucket >= 0) {
          updateLatencyTooltipPosition(e);
        }
      });

      canvas.addEventListener('mouseleave', () => {
        if (latencyHoverBucket !== -1) {
          latencyHoverBucket = -1;
          hideLatencyTooltip();
          if (currentView === 'latency') renderLatency();
        }
      });

      // Click handler - show resources in sidebar
      canvas.addEventListener('click', (e) => {
        if (currentView !== 'latency' || !latencyBucketData || latencyMode === 'cdf') return;

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const { buckets, barWidth, padding } = latencyBucketData;

        if (x >= padding.left && x <= padding.left + buckets.length * barWidth) {
          const bucketIdx = Math.floor((x - padding.left) / barWidth);
          if (bucketIdx >= 0 && bucketIdx < buckets.length) {
            const bucket = buckets[bucketIdx];
            if (bucket.resources.length > 0) {
              showLatencyBucketDetails(bucket);
            }
          }
        }
      });
    }

    function showLatencyTooltip(e, bucket) {
      let tooltip = document.getElementById('latency-tooltip');
      if (!tooltip) {
        tooltip = document.createElement('div');
        tooltip.id = 'latency-tooltip';
        tooltip.style.cssText = `
          position: fixed; background: rgba(22, 33, 62, 0.95); border: 1px solid #0f3460;
          padding: 10px 14px; border-radius: 4px; font-size: 11px; color: #e0e0e0;
          pointer-events: none; z-index: 1000; max-width: 280px;
        `;
        document.body.appendChild(tooltip);
      }

      const { outlierThreshold } = latencyBucketData;
      const rangeLabel = `${formatLatency(bucket.min)} - ${formatLatency(bucket.max)}`;

      let html = `<div style="font-weight: bold; color: #e94560; margin-bottom: 6px;">Latency: ${rangeLabel}</div>`;
      html += `<div style="display: grid; grid-template-columns: auto auto; gap: 2px 12px;">`;
      html += `<span style="color: #888;">Count:</span><span>${bucket.count}</span>`;

      if (showCriticalPath && bucket.criticalCount > 0) {
        html += `<span style="color: #ff6600;">On critical path:</span><span>${bucket.criticalCount}</span>`;
      }
      if (latencyShowOutliers && bucket.outlierCount > 0) {
        html += `<span style="color: #ff6347;">Outliers:</span><span>${bucket.outlierCount}</span>`;
      }
      html += `</div>`;

      // Type breakdown
      if (bucket.byType.size > 0) {
        html += `<div style="margin-top: 8px; font-weight: bold; color: #7ec8e3; font-size: 10px;">By Type:</div>`;
        html += `<div style="font-size: 10px;">`;
        Array.from(bucket.byType.entries())
          .sort((a, b) => b[1] - a[1])
          .slice(0, 5)
          .forEach(([type, count]) => {
            const color = TYPE_COLORS[type] || '#808080';
            html += `<span style="color: ${color};">‚óè</span> ${type}: ${count}<br>`;
          });
        html += `</div>`;
      }

      html += `<div style="color: #7ec8e3; margin-top: 6px; font-size: 10px;">Click for details</div>`;

      tooltip.innerHTML = html;
      tooltip.style.left = (e.clientX + 15) + 'px';
      tooltip.style.top = (e.clientY + 15) + 'px';
      tooltip.style.display = 'block';
    }

    function updateLatencyTooltipPosition(e) {
      const tooltip = document.getElementById('latency-tooltip');
      if (tooltip) {
        tooltip.style.left = (e.clientX + 15) + 'px';
        tooltip.style.top = (e.clientY + 15) + 'px';
      }
    }

    function hideLatencyTooltip() {
      const tooltip = document.getElementById('latency-tooltip');
      if (tooltip) tooltip.style.display = 'none';
    }

    function showLatencyBucketDetails(bucket) {
      const detailsEl = document.getElementById('selected-details');
      if (!detailsEl) return;

      let html = `<div style="font-weight: bold; color: #e94560; margin-bottom: 8px;">
        Latency Range: ${formatLatency(bucket.min)} - ${formatLatency(bucket.max)}
      </div>`;
      html += `<div style="color: #aaa; margin-bottom: 8px;">${bucket.count} resources</div>`;

      // List resources sorted by latency
      html += `<div style="max-height: 300px; overflow-y: auto;">`;
      bucket.resources
        .sort((a, b) => b.latencyMs - a.latencyMs)
        .slice(0, 20)
        .forEach(l => {
          const r = l.resource;
          const color = TYPE_COLORS[r.type] || '#808080';
          const criticalBadge = l.onCriticalPath ? ' <span style="color: #ff6600;">üî•</span>' : '';
          const outlierBadge = l.latencyMs > latencyBucketData.outlierThreshold ? ' <span style="color: #ff6347;">‚ö†</span>' : '';
          html += `<div class="detail-item" style="cursor: pointer; padding: 4px; border-radius: 3px;"
                        onmouseover="this.style.background='rgba(233,69,96,0.2)'"
                        onmouseout="this.style.background='transparent'"
                        onclick="selectResource(${r.asyncId})">
            <span style="color: ${color};">‚óè</span>
            <strong>${r.type}</strong> #${r.asyncId}${criticalBadge}${outlierBadge}
            <span style="color: #888; float: right;">${formatLatency(l.latencyMs)}</span>
          </div>`;
        });
      if (bucket.resources.length > 20) {
        html += `<div style="color: #666; font-style: italic;">...and ${bucket.resources.length - 20} more</div>`;
      }
      html += `</div>`;

      detailsEl.innerHTML = html;
    }

    // ==================== GAPS VIEW ====================
    function renderGaps() {
      const container = document.getElementById('gaps-view');
      const canvas = document.getElementById('gaps-canvas');
      const ctx = canvas.getContext('2d');

      // Account for controls height
      const controls = document.getElementById('gaps-controls');
      const controlsHeight = controls ? controls.offsetHeight : 0;
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight - controlsHeight;

      const width = canvas.width;
      const height = canvas.height;
      const padding = { top: 50, right: 220, bottom: 60, left: 70 };
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;

      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, width, height);

      if (!traceData) return;

      const duration = traceData.requestDurationNs;

      // Build timeline of activity - track when sync work is happening
      const numBuckets = Math.min(1000, Math.floor(chartWidth));
      const bucketSize = duration / numBuckets;
      const activityBuckets = new Array(numBuckets).fill(0);
      const asyncBuckets = new Array(numBuckets).fill(0);

      traceData.resources.forEach(r => {
        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          const startBucket = Math.max(0, Math.floor(r.callbackStartedAt / bucketSize));
          const endBucket = Math.min(numBuckets - 1, Math.floor(r.callbackEndedAt / bucketSize));
          for (let i = startBucket; i <= endBucket; i++) {
            activityBuckets[i]++;
          }
        }

        if (r.createdAt > 0) {
          const waitEnd = r.callbackStartedAt > 0 ? r.callbackStartedAt :
                         (r.callbackEndedAt > 0 ? r.callbackEndedAt :
                         (r.destroyedAt > 0 ? r.destroyedAt : duration));
          const startBucket = Math.max(0, Math.floor(r.createdAt / bucketSize));
          const endBucket = Math.min(numBuckets - 1, Math.floor(waitEnd / bucketSize));
          for (let i = startBucket; i <= endBucket; i++) {
            asyncBuckets[i]++;
          }
        }
      });

      // Find gaps
      const allGaps = [];
      let gapStart = null;

      for (let i = 0; i < numBuckets; i++) {
        const isIdle = activityBuckets[i] === 0;
        if (isIdle && gapStart === null) {
          gapStart = i;
        } else if (!isIdle && gapStart !== null) {
          const gapEnd = i;
          const gapDurationNs = (gapEnd - gapStart) * bucketSize;
          allGaps.push({
            startBucket: gapStart,
            endBucket: gapEnd,
            startNs: gapStart * bucketSize,
            endNs: gapEnd * bucketSize,
            durationNs: gapDurationNs,
            durationMs: gapDurationNs / 1e6,
            asyncWaiters: Math.max(...asyncBuckets.slice(gapStart, gapEnd + 1))
          });
          gapStart = null;
        }
      }

      if (gapStart !== null) {
        const gapEnd = numBuckets;
        const gapDurationNs = (gapEnd - gapStart) * bucketSize;
        allGaps.push({
          startBucket: gapStart,
          endBucket: gapEnd,
          startNs: gapStart * bucketSize,
          endNs: gapEnd * bucketSize,
          durationNs: gapDurationNs,
          durationMs: gapDurationNs / 1e6,
          asyncWaiters: Math.max(...asyncBuckets.slice(gapStart, gapEnd))
        });
      }

      // Filter gaps by threshold
      const thresholdNs = duration * (gapsThresholdPercent / 100);
      const gaps = gapsShowMinor ? allGaps : allGaps.filter(g => g.durationNs > thresholdNs);
      const minorGapsCount = allGaps.length - gaps.filter(g => g.durationNs > thresholdNs).length;

      // Sort gaps by duration
      gaps.sort((a, b) => b.durationNs - a.durationNs);

      // For each gap, find waiting resources and classify
      gaps.forEach(gap => {
        gap.waitingResources = traceData.resources.filter(r => {
          if (r.createdAt <= 0) return false;
          if (r.createdAt > gap.endNs) return false;
          const waitEnd = r.callbackStartedAt > 0 ? r.callbackStartedAt :
                         (r.callbackEndedAt > 0 ? r.callbackEndedAt :
                         (r.destroyedAt > 0 ? r.destroyedAt : duration));
          return waitEnd > gap.startNs;
        });

        // Classify the gap
        gap.classification = classifyGap(gap);
        gap.recommendation = getGapRecommendation(gap);

        // Check if gap is on critical path
        gap.onCriticalPath = gap.waitingResources.some(r => criticalPathSet.has(r.asyncId));

        // Mark as minor
        gap.isMinor = gap.durationNs <= thresholdNs;
      });

      // Store gaps for hover detection
      gapsData = gaps;

      const totalGapTime = gaps.reduce((s, g) => s + g.durationNs, 0);
      const gapPercent = (totalGapTime / duration * 100).toFixed(1);
      const criticalGaps = gaps.filter(g => g.onCriticalPath);

      // Draw title
      ctx.fillStyle = '#e94560';
      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Gap Analysis - Idle Periods (No Sync Execution)', (width - padding.right + padding.left) / 2, 25);

      // Draw axes
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding.left, padding.top);
      ctx.lineTo(padding.left, height - padding.bottom);
      ctx.lineTo(width - padding.right, height - padding.bottom);
      ctx.stroke();

      const maxActivity = Math.max(...activityBuckets, 1);
      const barWidth = chartWidth / numBuckets;

      // Store render params for hover detection
      gapsRenderParams = { padding, chartWidth, chartHeight, barWidth, numBuckets, bucketSize, duration, height };

      // Background showing async waiters
      const maxAsync = Math.max(...asyncBuckets, 1);
      for (let i = 0; i < numBuckets; i++) {
        if (asyncBuckets[i] > 0) {
          const barHeight = (asyncBuckets[i] / maxAsync) * chartHeight * 0.3;
          ctx.fillStyle = accessibilityMode ? 'rgba(126, 200, 227, 0.35)' : 'rgba(126, 200, 227, 0.2)';
          ctx.fillRect(padding.left + i * barWidth, height - padding.bottom - barHeight, barWidth, barHeight);
        }
      }

      // Draw sync activity bars
      for (let i = 0; i < numBuckets; i++) {
        if (activityBuckets[i] > 0) {
          const barHeight = (activityBuckets[i] / maxActivity) * chartHeight * 0.6;
          const x = padding.left + i * barWidth;
          const y = height - padding.bottom - barHeight;
          ctx.fillStyle = '#50c878';
          ctx.globalAlpha = accessibilityMode ? 1.0 : 0.8;
          ctx.fillRect(x, y, barWidth, barHeight);
        }
      }
      ctx.globalAlpha = 1;

      // Highlight gaps
      const classColors = {
        'fetch': '#e94560',
        'timer': '#ffd700',
        'io': '#7ec8e3',
        'promise': '#9966cc',
        'unknown': '#ff6432'
      };

      gaps.forEach((gap, idx) => {
        const x = padding.left + gap.startBucket * barWidth;
        const gapWidth = (gap.endBucket - gap.startBucket) * barWidth;
        const isHovered = gapsHoverIndex === idx;

        // Gap color based on classification
        let gapColor = '#ff6432';
        if (gapsShowClassification && gap.classification) {
          gapColor = classColors[gap.classification.type] || '#ff6432';
        }

        // Gap fill
        const baseOpacity = isHovered ? 0.5 : (idx < 3 ? 0.35 : 0.2);
        const opacity = gap.isMinor ? baseOpacity * 0.5 : baseOpacity;
        ctx.fillStyle = gapColor;
        ctx.globalAlpha = opacity;
        ctx.fillRect(x, padding.top, gapWidth, chartHeight);
        ctx.globalAlpha = 1;

        // Gap border
        ctx.strokeStyle = gapColor;
        ctx.lineWidth = isHovered ? 3 : (idx < 3 ? 2 : 1);
        if (gap.isMinor) ctx.setLineDash([2, 2]);
        ctx.strokeRect(x, padding.top, gapWidth, chartHeight);
        ctx.setLineDash([]);

        // Critical path indicator
        if (showCriticalPath && gap.onCriticalPath) {
          ctx.strokeStyle = '#ff6600';
          ctx.lineWidth = 3;
          ctx.setLineDash([4, 4]);
          ctx.strokeRect(x + 2, padding.top + 2, gapWidth - 4, chartHeight - 4);
          ctx.setLineDash([]);
        }

        // Labels for significant gaps
        if (gap.durationMs >= 0.1 && gapWidth > 30 && !gap.isMinor) {
          ctx.fillStyle = gapColor;
          ctx.font = 'bold 10px sans-serif';
          ctx.textAlign = 'center';
          const label = gap.durationMs >= 1 ? `${gap.durationMs.toFixed(1)}ms` : `${(gap.durationMs * 1000).toFixed(0)}¬µs`;
          ctx.fillText(label, x + gapWidth / 2, padding.top + 15);

          if (gapsShowClassification && gap.classification && gapWidth > 60) {
            ctx.font = '9px sans-serif';
            ctx.fillText(gap.classification.label, x + gapWidth / 2, padding.top + 28);
          }

          if (gap.asyncWaiters > 0 && gapWidth > 50) {
            ctx.font = '9px sans-serif';
            ctx.fillStyle = '#7ec8e3';
            const yOffset = gapsShowClassification && gap.classification && gapWidth > 60 ? 41 : 28;
            ctx.fillText(`${gap.asyncWaiters} waiting`, x + gapWidth / 2, padding.top + yOffset);
          }
        }
      });

      // X-axis labels
      ctx.fillStyle = '#888';
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'center';
      for (let i = 0; i <= 5; i++) {
        const x = padding.left + (i / 5) * chartWidth;
        const time = (i / 5) * duration / 1e6;
        ctx.fillText(time.toFixed(1) + 'ms', x, height - padding.bottom + 15);
      }

      ctx.fillText('Time', (width - padding.right + padding.left) / 2, height - padding.bottom + 35);

      // Y-axis title
      ctx.save();
      ctx.translate(20, height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillStyle = '#888';
      ctx.font = '11px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Activity Level', 0, 0);
      ctx.restore();

      // Legend
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'left';

      ctx.fillStyle = '#50c878';
      ctx.fillRect(padding.left, height - 25, 12, 12);
      ctx.fillStyle = '#888';
      ctx.fillText('Sync', padding.left + 16, height - 16);

      ctx.fillStyle = 'rgba(126, 200, 227, 0.5)';
      ctx.fillRect(padding.left + 60, height - 25, 12, 12);
      ctx.fillStyle = '#888';
      ctx.fillText('Async wait', padding.left + 76, height - 16);

      if (gapsShowClassification) {
        let legendX = padding.left + 150;
        Object.entries(classColors).slice(0, 4).forEach(([type, color]) => {
          ctx.fillStyle = color;
          ctx.globalAlpha = 0.5;
          ctx.fillRect(legendX, height - 25, 12, 12);
          ctx.globalAlpha = 1;
          ctx.strokeStyle = color;
          ctx.strokeRect(legendX, height - 25, 12, 12);
          ctx.fillStyle = '#888';
          ctx.fillText(type, legendX + 16, height - 16);
          legendX += 70;
        });
      }

      // Sidebar
      const sbX = width - padding.right + 10;
      const sbWidth = padding.right - 20;

      ctx.fillStyle = 'rgba(22, 33, 62, 0.95)';
      ctx.fillRect(sbX, padding.top, sbWidth, chartHeight);
      ctx.strokeStyle = '#0f3460';
      ctx.strokeRect(sbX, padding.top, sbWidth, chartHeight);

      let sbY = padding.top + 15;
      ctx.fillStyle = '#e94560';
      ctx.font = 'bold 11px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText('Gap Statistics', sbX + 10, sbY);
      sbY += 18;

      ctx.font = '10px sans-serif';
      ctx.fillStyle = '#aaa';
      ctx.fillText(`Gaps shown: ${gaps.length}`, sbX + 10, sbY); sbY += 14;
      if (minorGapsCount > 0 && !gapsShowMinor) {
        ctx.fillStyle = '#666';
        ctx.fillText(`(${minorGapsCount} minor hidden)`, sbX + 10, sbY); sbY += 14;
      }
      ctx.fillStyle = '#aaa';
      ctx.fillText(`Total idle: ${(totalGapTime / 1e6).toFixed(2)}ms`, sbX + 10, sbY); sbY += 14;
      ctx.fillText(`Idle %: ${gapPercent}%`, sbX + 10, sbY); sbY += 18;

      // Critical path gaps
      if (showCriticalPath && criticalGaps.length > 0) {
        ctx.fillStyle = '#ff6600';
        ctx.font = 'bold 10px sans-serif';
        ctx.fillText('Critical Path Gaps', sbX + 10, sbY); sbY += 14;
        ctx.font = '10px sans-serif';
        ctx.fillStyle = '#aaa';
        const criticalTime = criticalGaps.reduce((s, g) => s + g.durationNs, 0);
        ctx.fillText(`Count: ${criticalGaps.length}`, sbX + 10, sbY); sbY += 14;
        ctx.fillText(`Time: ${(criticalTime / 1e6).toFixed(2)}ms`, sbX + 10, sbY); sbY += 18;
      }

      // Top gaps
      if (gaps.length > 0) {
        ctx.fillStyle = '#e94560';
        ctx.font = 'bold 10px sans-serif';
        ctx.fillText('Largest Gaps', sbX + 10, sbY); sbY += 14;

        gaps.slice(0, 5).forEach((gap, i) => {
          const color = gapsShowClassification && gap.classification ?
            classColors[gap.classification.type] : '#ff6432';
          ctx.fillStyle = color;
          ctx.font = '10px sans-serif';
          const timeLabel = gap.durationMs >= 1 ? `${gap.durationMs.toFixed(1)}ms` : `${(gap.durationMs * 1000).toFixed(0)}¬µs`;
          const critBadge = gap.onCriticalPath ? ' üî•' : '';
          ctx.fillText(`${i + 1}. ${timeLabel}${critBadge}`, sbX + 10, sbY);
          sbY += 12;
          if (gapsShowClassification && gap.classification) {
            ctx.fillStyle = '#888';
            ctx.font = '9px sans-serif';
            ctx.fillText(`   ${gap.classification.label}`, sbX + 10, sbY);
            sbY += 12;
          }
        });
        sbY += 6;
      }

      // Recommendations
      if (gapsShowRecommendations && gaps.length > 0) {
        ctx.fillStyle = '#e94560';
        ctx.font = 'bold 10px sans-serif';
        ctx.fillText('Recommendations', sbX + 10, sbY); sbY += 14;

        // Get unique recommendations
        const recommendations = new Map();
        gaps.slice(0, 10).forEach(gap => {
          if (gap.recommendation && !recommendations.has(gap.recommendation.type)) {
            recommendations.set(gap.recommendation.type, gap.recommendation);
          }
        });

        ctx.font = '9px sans-serif';
        Array.from(recommendations.values()).slice(0, 3).forEach(rec => {
          ctx.fillStyle = '#ffd700';
          ctx.fillText(`‚Ä¢ ${rec.short}`, sbX + 10, sbY);
          sbY += 12;
        });
      }

      // Setup event handlers (once)
      if (!canvas._gapsHandlersSet) {
        canvas._gapsHandlersSet = true;
        setupGapsEventHandlers(canvas);
      }
    }

    function classifyGap(gap) {
      if (!gap.waitingResources || gap.waitingResources.length === 0) {
        return { type: 'unknown', label: 'No waiters' };
      }

      // Count resource types
      const typeCounts = {};
      gap.waitingResources.forEach(r => {
        typeCounts[r.type] = (typeCounts[r.type] || 0) + 1;
      });

      // Determine primary cause
      const types = Object.entries(typeCounts).sort((a, b) => b[1] - a[1]);
      const [primaryType] = types[0];

      if (primaryType === 'fetch' || primaryType.includes('fetch')) {
        return { type: 'fetch', label: 'Awaiting fetch' };
      }
      if (primaryType === 'timer') {
        return { type: 'timer', label: 'Timer delay' };
      }
      if (primaryType.includes('kv') || primaryType.includes('do-') || primaryType.includes('r2') || primaryType.includes('d1')) {
        return { type: 'io', label: 'Storage I/O' };
      }
      if (primaryType === 'js-promise' || primaryType === 'kj-promise') {
        return { type: 'promise', label: 'Promise wait' };
      }
      if (primaryType.includes('stream')) {
        return { type: 'io', label: 'Stream I/O' };
      }

      return { type: 'unknown', label: `Waiting: ${primaryType}` };
    }

    function getGapRecommendation(gap) {
      if (!gap.classification) return null;

      switch (gap.classification.type) {
        case 'fetch':
          return {
            type: 'parallel-fetch',
            short: 'Parallelize fetches',
            detail: 'Use Promise.all() to run fetches concurrently'
          };
        case 'timer':
          return {
            type: 'remove-timer',
            short: 'Review timer necessity',
            detail: 'Consider if setTimeout/setInterval is needed'
          };
        case 'io':
          return {
            type: 'cache-io',
            short: 'Cache or batch I/O',
            detail: 'Consider caching results or batching operations'
          };
        case 'promise':
          return {
            type: 'check-await',
            short: 'Check await placement',
            detail: 'Ensure awaits are not unnecessarily sequential'
          };
        default:
          return {
            type: 'investigate',
            short: 'Investigate gap cause',
            detail: 'Review waiting resources for optimization'
          };
      }
    }

    function setupGapsEventHandlers(canvas) {
      // Control handlers
      document.getElementById('gaps-threshold-slider').addEventListener('input', (e) => {
        gapsThresholdPercent = parseFloat(e.target.value);
        document.getElementById('gaps-threshold-value').textContent = gapsThresholdPercent.toFixed(1) + '%';
        renderGaps();
      });

      document.getElementById('gaps-show-minor').addEventListener('change', (e) => {
        gapsShowMinor = e.target.checked;
        renderGaps();
      });

      document.getElementById('gaps-show-classification').addEventListener('change', (e) => {
        gapsShowClassification = e.target.checked;
        renderGaps();
      });

      document.getElementById('gaps-show-recommendations').addEventListener('change', (e) => {
        gapsShowRecommendations = e.target.checked;
        renderGaps();
      });

      // Hover handler
      canvas.addEventListener('mousemove', (e) => {
        if (currentView !== 'gaps' || !gapsRenderParams || gapsData.length === 0) {
          canvas.style.cursor = 'default';
          return;
        }

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const { padding, barWidth, chartHeight, height } = gapsRenderParams;

        // Find hovered gap
        let hoveredIdx = -1;
        if (y >= padding.top && y <= height - padding.bottom) {
          for (let i = 0; i < gapsData.length; i++) {
            const gap = gapsData[i];
            const gapX = padding.left + gap.startBucket * barWidth;
            const gapWidth = (gap.endBucket - gap.startBucket) * barWidth;
            if (x >= gapX && x <= gapX + gapWidth) {
              hoveredIdx = i;
              break;
            }
          }
        }

        canvas.style.cursor = hoveredIdx >= 0 ? 'pointer' : 'default';

        if (hoveredIdx !== gapsHoverIndex) {
          gapsHoverIndex = hoveredIdx;
          renderGaps();
          if (hoveredIdx >= 0) {
            showGapsTooltip(e, gapsData[hoveredIdx]);
          } else {
            hideGapsTooltip();
          }
        } else if (hoveredIdx >= 0) {
          updateGapsTooltipPosition(e);
        }
      });

      canvas.addEventListener('mouseleave', () => {
        if (gapsHoverIndex !== -1) {
          gapsHoverIndex = -1;
          hideGapsTooltip();
          if (currentView === 'gaps') renderGaps();
        }
      });

      // Click handler
      canvas.addEventListener('click', (e) => {
        if (currentView !== 'gaps' || gapsHoverIndex < 0 || gapsHoverIndex >= gapsData.length) return;
        showGapDetails(gapsData[gapsHoverIndex]);
      });
    }

    function showGapsTooltip(e, gap) {
      let tooltip = document.getElementById('gaps-tooltip');
      if (!tooltip) {
        tooltip = document.createElement('div');
        tooltip.id = 'gaps-tooltip';
        tooltip.style.cssText = `
          position: fixed; background: rgba(22, 33, 62, 0.95); border: 1px solid #0f3460;
          padding: 10px 14px; border-radius: 4px; font-size: 11px; color: #e0e0e0;
          pointer-events: none; z-index: 1000; max-width: 300px;
        `;
        document.body.appendChild(tooltip);
      }

      const timeLabel = gap.durationMs >= 1 ? `${gap.durationMs.toFixed(2)}ms` : `${(gap.durationMs * 1000).toFixed(0)}¬µs`;
      const startLabel = (gap.startNs / 1e6).toFixed(2);
      const endLabel = (gap.endNs / 1e6).toFixed(2);

      let html = `<div style="font-weight: bold; color: #e94560; margin-bottom: 6px;">Gap: ${timeLabel}</div>`;
      html += `<div style="display: grid; grid-template-columns: auto auto; gap: 2px 12px;">`;
      html += `<span style="color: #888;">Time range:</span><span>${startLabel}ms - ${endLabel}ms</span>`;
      html += `<span style="color: #888;">Waiting ops:</span><span>${gap.asyncWaiters}</span>`;

      if (gapsShowClassification && gap.classification) {
        html += `<span style="color: #888;">Cause:</span><span>${gap.classification.label}</span>`;
      }

      if (showCriticalPath && gap.onCriticalPath) {
        html += `<span style="color: #ff6600;">Critical path:</span><span>Yes üî•</span>`;
      }
      html += `</div>`;

      // Top waiting resources
      if (gap.waitingResources && gap.waitingResources.length > 0) {
        html += `<div style="margin-top: 8px; font-weight: bold; color: #7ec8e3; font-size: 10px;">Top Waiters:</div>`;
        html += `<div style="font-size: 10px;">`;
        const typeCounts = {};
        gap.waitingResources.forEach(r => {
          typeCounts[r.type] = (typeCounts[r.type] || 0) + 1;
        });
        Object.entries(typeCounts)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 4)
          .forEach(([type, count]) => {
            const color = TYPE_COLORS[type] || '#808080';
            html += `<span style="color: ${color};">‚óè</span> ${type}: ${count}<br>`;
          });
        html += `</div>`;
      }

      if (gapsShowRecommendations && gap.recommendation) {
        html += `<div style="margin-top: 6px; color: #ffd700; font-size: 10px;">üí° ${gap.recommendation.short}</div>`;
      }

      html += `<div style="color: #7ec8e3; margin-top: 6px; font-size: 10px;">Click for details</div>`;

      tooltip.innerHTML = html;
      tooltip.style.left = (e.clientX + 15) + 'px';
      tooltip.style.top = (e.clientY + 15) + 'px';
      tooltip.style.display = 'block';
    }

    function updateGapsTooltipPosition(e) {
      const tooltip = document.getElementById('gaps-tooltip');
      if (tooltip) {
        tooltip.style.left = (e.clientX + 15) + 'px';
        tooltip.style.top = (e.clientY + 15) + 'px';
      }
    }

    function hideGapsTooltip() {
      const tooltip = document.getElementById('gaps-tooltip');
      if (tooltip) tooltip.style.display = 'none';
    }

    function showGapDetails(gap) {
      const detailsEl = document.getElementById('selected-details');
      if (!detailsEl) return;

      const timeLabel = gap.durationMs >= 1 ? `${gap.durationMs.toFixed(2)}ms` : `${(gap.durationMs * 1000).toFixed(0)}¬µs`;

      let html = `<div style="font-weight: bold; color: #e94560; margin-bottom: 8px;">
        Gap: ${timeLabel}
        ${gap.onCriticalPath ? '<span style="color: #ff6600;">üî•</span>' : ''}
      </div>`;
      html += `<div style="color: #aaa; margin-bottom: 4px;">
        ${(gap.startNs / 1e6).toFixed(2)}ms - ${(gap.endNs / 1e6).toFixed(2)}ms
      </div>`;

      if (gapsShowClassification && gap.classification) {
        html += `<div style="color: #7ec8e3; margin-bottom: 8px;">Cause: ${gap.classification.label}</div>`;
      }

      if (gapsShowRecommendations && gap.recommendation) {
        html += `<div style="background: rgba(255,215,0,0.1); padding: 6px; border-radius: 4px; margin-bottom: 8px;">
          <div style="color: #ffd700; font-weight: bold; font-size: 10px;">üí° Recommendation</div>
          <div style="color: #aaa; font-size: 10px;">${gap.recommendation.detail}</div>
        </div>`;
      }

      html += `<div style="font-weight: bold; color: #7ec8e3; margin-bottom: 4px;">Waiting Resources (${gap.waitingResources.length})</div>`;
      html += `<div style="max-height: 250px; overflow-y: auto;">`;

      gap.waitingResources
        .sort((a, b) => {
          // Sort critical path resources first
          const aOnCrit = criticalPathSet.has(a.asyncId) ? 0 : 1;
          const bOnCrit = criticalPathSet.has(b.asyncId) ? 0 : 1;
          return aOnCrit - bOnCrit;
        })
        .slice(0, 20)
        .forEach(r => {
          const color = TYPE_COLORS[r.type] || '#808080';
          const critBadge = criticalPathSet.has(r.asyncId) ? ' <span style="color: #ff6600;">üî•</span>' : '';
          html += `<div class="detail-item" style="cursor: pointer; padding: 4px; border-radius: 3px;"
                        onmouseover="this.style.background='rgba(233,69,96,0.2)'"
                        onmouseout="this.style.background='transparent'"
                        onclick="selectResource(${r.asyncId})">
            <span style="color: ${color};">‚óè</span>
            <strong>${r.type}</strong> #${r.asyncId}${critBadge}
          </div>`;
        });

      if (gap.waitingResources.length > 20) {
        html += `<div style="color: #666; font-style: italic;">...and ${gap.waitingResources.length - 20} more</div>`;
      }
      html += `</div>`;

      detailsEl.innerHTML = html;
    }

    // ==================== REPLAY VIEW ====================

    // Compute bubble layout for replay - positions nodes hierarchically based on trigger relationships
    // Returns a Map of asyncId -> { x, y, radius }
    function computeReplayBubbleLayout(visibleResources, chartWidth, chartHeight, chartLeft, chartTop) {
      if (visibleResources.length === 0) return new Map();

      const padding = 30;
      const minRadius = 15;
      const maxRadius = 40;
      const nodeSpacing = 25;

      // Build children map for visible resources only
      const childrenMap = new Map();
      const visibleIds = new Set(visibleResources.map(r => r.asyncId));

      visibleResources.forEach(r => {
        // Initialize empty children array for each resource
        if (!childrenMap.has(r.asyncId)) {
          childrenMap.set(r.asyncId, []);
        }
        // Add to parent's children if parent is visible
        if (r.triggerId !== 0 && visibleIds.has(r.triggerId)) {
          if (!childrenMap.has(r.triggerId)) {
            childrenMap.set(r.triggerId, []);
          }
          childrenMap.get(r.triggerId).push(r);
        }
      });

      // Sort children by creation time
      childrenMap.forEach(children => {
        children.sort((a, b) => a.createdAt - b.createdAt);
      });

      // Find roots (no visible parent)
      const roots = visibleResources.filter(r =>
        r.triggerId === 0 || !visibleIds.has(r.triggerId)
      );

      // Calculate current sync time for each resource (for dynamic sizing)
      // If callback is in progress, use time elapsed so far
      const duration = traceData.requestDurationNs;
      const getSyncTime = (r) => {
        if (r.callbackStartedAt <= 0) return 0;
        if (r.callbackEndedAt > 0 && r.callbackEndedAt <= replayTime) {
          // Callback completed
          return r.callbackEndedAt - r.callbackStartedAt;
        }
        if (r.callbackStartedAt <= replayTime) {
          // Callback in progress - use time elapsed so far
          return replayTime - r.callbackStartedAt;
        }
        return 0;
      };

      // Find max sync time among visible resources for relative sizing
      const maxSyncTime = Math.max(...visibleResources.map(getSyncTime), 1);

      // Compute node radii based on sync time
      const nodeRadii = new Map();
      visibleResources.forEach(r => {
        const syncTime = getSyncTime(r);
        const ratio = Math.sqrt(syncTime / maxSyncTime);
        const radius = minRadius + ratio * (maxRadius - minRadius);
        nodeRadii.set(r.asyncId, radius);
      });

      // Compute depth for each node
      const depthMap = new Map();
      function computeDepth(r, depth) {
        depthMap.set(r.asyncId, depth);
        const children = childrenMap.get(r.asyncId) || [];
        children.forEach(child => computeDepth(child, depth + 1));
      }
      roots.forEach(r => computeDepth(r, 0));

      // Compute subtree widths
      const subtreeWidths = new Map();
      function computeSubtreeWidth(asyncId) {
        const children = childrenMap.get(asyncId) || [];
        const myRadius = nodeRadii.get(asyncId) || minRadius;

        if (children.length === 0) {
          const w = myRadius * 2 + nodeSpacing;
          subtreeWidths.set(asyncId, w);
          return w;
        }

        let childrenTotalWidth = 0;
        children.forEach(child => {
          childrenTotalWidth += computeSubtreeWidth(child.asyncId);
        });

        const myWidth = Math.max(myRadius * 2 + nodeSpacing, childrenTotalWidth);
        subtreeWidths.set(asyncId, myWidth);
        return myWidth;
      }

      let totalWidth = 0;
      roots.forEach(r => {
        totalWidth += computeSubtreeWidth(r.asyncId);
      });

      // Calculate depth-based Y positions
      const maxDepth = Math.max(...Array.from(depthMap.values()), 0);
      const availableHeight = chartHeight - padding * 2;
      const levelHeight = maxDepth > 0 ? Math.min(80, availableHeight / (maxDepth + 1)) : 80;

      // Layout nodes
      const positions = new Map();
      let currentX = padding;

      function layoutSubtree(r, depth) {
        const children = childrenMap.get(r.asyncId) || [];
        const myWidth = subtreeWidths.get(r.asyncId) || 50;
        const myRadius = nodeRadii.get(r.asyncId) || minRadius;

        let x;
        if (children.length === 0) {
          x = currentX + myWidth / 2;
          currentX += myWidth;
        } else {
          const startX = currentX;
          children.forEach(child => layoutSubtree(child, depth + 1));
          const endX = currentX;
          x = (startX + endX) / 2;
        }

        const y = padding + 30 + depth * levelHeight;

        positions.set(r.asyncId, {
          x: x,
          y: y,
          radius: myRadius,
          resource: r
        });
      }

      roots.forEach(r => layoutSubtree(r, 0));

      // Handle orphans (resources not in the tree due to filtering)
      let orphanX = padding;
      const orphanY = chartHeight - padding - 30;
      visibleResources.forEach(r => {
        if (!positions.has(r.asyncId)) {
          const radius = nodeRadii.get(r.asyncId) || minRadius;
          positions.set(r.asyncId, {
            x: orphanX + radius,
            y: orphanY,
            radius: radius,
            resource: r
          });
          orphanX += radius * 2 + nodeSpacing;
        }
      });

      // Calculate bounds
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      positions.forEach(pos => {
        minX = Math.min(minX, pos.x - pos.radius);
        maxX = Math.max(maxX, pos.x + pos.radius);
        minY = Math.min(minY, pos.y - pos.radius);
        maxY = Math.max(maxY, pos.y + pos.radius);
      });

      const layoutWidth = maxX - minX + padding * 2;
      const layoutHeight = maxY - minY + padding * 2;

      // Use a minimum scale to keep nodes readable (don't shrink too much)
      const scaleX = chartWidth / layoutWidth;
      const scaleY = chartHeight / layoutHeight;
      const minScale = 0.6;  // Don't shrink below 60%
      const scale = Math.max(Math.min(scaleX, scaleY, 1.5), minScale);

      // Find the focus point - prioritize: newly created > executing > most recent
      let focusX = 0, focusY = 0;
      let focusFound = false;

      // Look for nodes that just appeared or are executing
      const recentThreshold = traceData.requestDurationNs * 0.05;  // Last 5% of trace time
      let newestNode = null;
      let newestTime = -1;
      let executingNode = null;

      positions.forEach((pos, asyncId) => {
        const r = pos.resource;
        // Track newest node
        if (r.createdAt > newestTime && r.createdAt <= replayTime) {
          newestTime = r.createdAt;
          newestNode = pos;
        }
        // Track executing node
        if (r.callbackStartedAt > 0 && r.callbackStartedAt <= replayTime &&
            (r.callbackEndedAt === 0 || r.callbackEndedAt > replayTime)) {
          executingNode = pos;
        }
      });

      // Priority: executing node > newest node > center of layout
      if (executingNode) {
        focusX = executingNode.x;
        focusY = executingNode.y;
        focusFound = true;
      } else if (newestNode && (replayTime - newestTime) < recentThreshold) {
        focusX = newestNode.x;
        focusY = newestNode.y;
        focusFound = true;
      } else {
        // Default to center of layout
        focusX = (minX + maxX) / 2;
        focusY = (minY + maxY) / 2;
      }

      // Calculate target viewport offset to center focus point
      const targetOffsetX = chartLeft + chartWidth / 2 - focusX * scale;
      const targetOffsetY = chartTop + chartHeight / 2 - focusY * scale;

      // Smoothly interpolate viewport (stored in replayBubbleViewport)
      const panSmoothing = 0.08;  // Smooth panning
      if (replayBubbleViewport.scale === 1 && replayBubbleViewport.x === 0 && replayBubbleViewport.y === 0) {
        // First frame - jump to position
        replayBubbleViewport.x = targetOffsetX;
        replayBubbleViewport.y = targetOffsetY;
        replayBubbleViewport.scale = scale;
      } else {
        // Smooth pan
        replayBubbleViewport.x += (targetOffsetX - replayBubbleViewport.x) * panSmoothing;
        replayBubbleViewport.y += (targetOffsetY - replayBubbleViewport.y) * panSmoothing;
        replayBubbleViewport.scale += (scale - replayBubbleViewport.scale) * panSmoothing;
      }

      const offsetX = replayBubbleViewport.x;
      const offsetY = replayBubbleViewport.y;
      const currentScale = replayBubbleViewport.scale;

      // Apply transform
      const transformedPositions = new Map();
      positions.forEach((pos, asyncId) => {
        transformedPositions.set(asyncId, {
          x: offsetX + pos.x * currentScale,
          y: offsetY + pos.y * currentScale,
          radius: pos.radius * currentScale,
          resource: pos.resource
        });
      });

      return transformedPositions;
    }

    // Update bubble node positions with smoothing
    function updateReplayBubblePositions(targetPositions, deltaTime) {
      const smoothingFactor = Math.min(1, deltaTime * 0.008);  // Smooth over ~125ms

      targetPositions.forEach((target, asyncId) => {
        let node = replayBubbleNodes.get(asyncId);
        if (!node) {
          // New node - start at target position
          node = {
            x: target.x,
            y: target.y,
            radius: target.radius,
            targetX: target.x,
            targetY: target.y,
            targetRadius: target.radius,
            resource: target.resource
          };
          replayBubbleNodes.set(asyncId, node);
        } else {
          // Update targets
          node.targetX = target.x;
          node.targetY = target.y;
          node.targetRadius = target.radius;
          node.resource = target.resource;

          // Interpolate current towards target
          node.x += (node.targetX - node.x) * smoothingFactor;
          node.y += (node.targetY - node.y) * smoothingFactor;
          node.radius += (node.targetRadius - node.radius) * smoothingFactor;
        }
      });

      // Remove nodes that are no longer in target
      for (const asyncId of replayBubbleNodes.keys()) {
        if (!targetPositions.has(asyncId)) {
          replayBubbleNodes.delete(asyncId);
        }
      }
    }

    function renderReplay() {
      // Stop any existing animation
      if (replayAnimationId) {
        cancelAnimationFrame(replayAnimationId);
        replayAnimationId = null;
      }
      replayPlaying = false;
      replayTime = 0;
      replayPeakParallelism = 0;
      replayEventLog = [];
      replayLastEventTime = 0;
      replayLiveAlerts = [];
      replayAlertedPatterns = new Set();
      replayTrail = [];
      replayLoopPauseUntil = 0;
      replayBubbleNodes.clear();
      replayBubbleViewport = { x: 0, y: 0, scale: 1 };
      renderReplayFrame();
    }

    function startReplayAnimation() {
      if (!traceData || replayPlaying) return;
      replayPlaying = true;
      let lastFrameTime = performance.now();

      function animate(now) {
        if (!replayPlaying || currentView !== 'replay') {
          replayPlaying = false;
          return;
        }

        const delta = (now - lastFrameTime) * replaySpeed;
        lastFrameTime = now;

        // Convert real-time delta to trace time (speed up playback)
        const traceTimePerMs = traceData.requestDurationNs / 3000;  // 3 second playback
        replayTime += delta * traceTimePerMs;

        if (replayTime >= traceData.requestDurationNs) {
          if (replayLoop) {
            // Loop mode - pause briefly at end, then reset
            if (replayLoopPauseUntil === 0) {
              // Start the pause (1 second)
              replayLoopPauseUntil = now + 1000;
              replayTime = traceData.requestDurationNs;  // Hold at end
            } else if (now >= replayLoopPauseUntil) {
              // Pause is over, reset and continue
              replayLoopPauseUntil = 0;
              replayTime = 0;
              replayTrail = [];  // Clear trail on loop
              replayEventLog = [];
              replayLastEventTime = 0;
              replayLiveAlerts = [];
              replayAlertedPatterns.clear();
            }
            // During pause, just keep rendering at end position
          } else {
            replayTime = traceData.requestDurationNs;
            replayPlaying = false;
          }
        }

        renderReplayFrame();

        if (replayPlaying) {
          replayAnimationId = requestAnimationFrame(animate);
        }
      }

      replayAnimationId = requestAnimationFrame(animate);
    }

    function stopReplayAnimation() {
      replayPlaying = false;
      if (replayAnimationId) {
        cancelAnimationFrame(replayAnimationId);
        replayAnimationId = null;
      }
    }

    function renderReplayFrame() {
      const container = document.getElementById('replay-view');
      const canvas = document.getElementById('replay-canvas');
      const ctx = canvas.getContext('2d');

      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;

      const width = canvas.width;
      const height = canvas.height;

      // Sidebar dimensions
      const sidebarWidth = 210;
      const sidebarX = 0;

      // Main area dimensions (to the right of sidebar)
      const mainX = sidebarWidth;
      const mainWidth = width - sidebarWidth;
      const padding = { top: 80, right: 30, bottom: 50, left: 10 };
      const chartWidth = mainWidth - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;

      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, width, height);

      // Sidebar background
      ctx.fillStyle = 'rgba(15, 52, 96, 0.5)';
      ctx.fillRect(sidebarX, 0, sidebarWidth, height);
      ctx.strokeStyle = '#0f3460';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(sidebarWidth, 0);
      ctx.lineTo(sidebarWidth, height);
      ctx.stroke();

      if (!traceData) return;

      // Update the sidebar timeline chart with playhead position
      renderTimelineChart();

      const duration = traceData.requestDurationNs;
      const currentTimeMs = replayTime / 1e6;
      const durationMs = duration / 1e6;
      const progress = replayTime / duration;

      // Draw title (centered in main area)
      ctx.fillStyle = '#e94560';
      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Request Replay', mainX + mainWidth / 2, 25);

      // Draw playback controls area
      const controlsY = 45;
      ctx.fillStyle = '#888';
      ctx.font = '11px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(`Time: ${currentTimeMs.toFixed(2)}ms / ${durationMs.toFixed(2)}ms`, mainX + mainWidth / 2, controlsY);

      // Draw control buttons (centered in main area)
      const btnY = controlsY + 8;
      const btnWidth = 60;
      const btnHeight = 22;
      const btnSpacing = 10;
      const totalBtnWidth = btnWidth * 4 + btnSpacing * 3;
      let btnX = mainX + (mainWidth - totalBtnWidth) / 2;

      // Play/Pause button
      ctx.fillStyle = replayPlaying ? '#ff6432' : '#50c878';
      ctx.fillRect(btnX, btnY, btnWidth, btnHeight);
      ctx.fillStyle = 'white';
      ctx.font = 'bold 10px sans-serif';
      ctx.fillText(replayPlaying ? '‚è∏ Pause' : '‚ñ∂ Play', btnX + btnWidth/2, btnY + 15);
      btnX += btnWidth + btnSpacing;

      // Reset button
      ctx.fillStyle = '#0f3460';
      ctx.strokeStyle = '#e94560';
      ctx.lineWidth = 1;
      ctx.fillRect(btnX, btnY, btnWidth, btnHeight);
      ctx.strokeRect(btnX, btnY, btnWidth, btnHeight);
      ctx.fillStyle = '#e94560';
      ctx.fillText('‚èÆ Reset', btnX + btnWidth/2, btnY + 15);
      btnX += btnWidth + btnSpacing;

      // Speed buttons (compact)
      const speeds = [0.25, 0.5, 1, 2];
      speeds.forEach(speed => {
        const speedWidth = speed === 0.25 ? 32 : 28;
        ctx.fillStyle = replaySpeed === speed ? '#e94560' : '#0f3460';
        ctx.fillRect(btnX, btnY, speedWidth, btnHeight);
        ctx.strokeStyle = '#e94560';
        ctx.strokeRect(btnX, btnY, speedWidth, btnHeight);
        ctx.fillStyle = replaySpeed === speed ? 'white' : '#e94560';
        ctx.fillText(`${speed}x`, btnX + speedWidth/2, btnY + 15);
        btnX += speedWidth + 3;
      });

      // Loop button
      btnX += 3;
      ctx.fillStyle = replayLoop ? '#50c878' : '#0f3460';
      ctx.fillRect(btnX, btnY, 38, btnHeight);
      ctx.strokeStyle = replayLoop ? '#50c878' : '#e94560';
      ctx.strokeRect(btnX, btnY, 38, btnHeight);
      ctx.fillStyle = replayLoop ? 'white' : '#e94560';
      ctx.fillText('üîÅ', btnX + 19, btnY + 15);
      btnX += 41;

      // Ghost button
      ctx.fillStyle = replayGhostMode ? '#9966cc' : '#0f3460';
      ctx.fillRect(btnX, btnY, 38, btnHeight);
      ctx.strokeStyle = replayGhostMode ? '#9966cc' : '#e94560';
      ctx.strokeRect(btnX, btnY, 38, btnHeight);
      ctx.fillStyle = replayGhostMode ? 'white' : '#e94560';
      ctx.fillText('üëª', btnX + 19, btnY + 15);
      btnX += 41;

      // Layout toggle buttons (compact with single letter + icon style)
      btnX += 5;
      const layoutModes = [
        { mode: 'grid', label: '‚äû', width: 28 },
        { mode: 'bubble', label: '‚óâ', width: 28 },
        { mode: 'rings', label: '‚óé', width: 28 }
      ];
      layoutModes.forEach(({ mode, label, width }) => {
        ctx.fillStyle = replayLayoutMode === mode ? '#4a9eff' : '#0f3460';
        ctx.fillRect(btnX, btnY, width, btnHeight);
        ctx.strokeStyle = replayLayoutMode === mode ? '#4a9eff' : '#e94560';
        ctx.strokeRect(btnX, btnY, width, btnHeight);
        ctx.fillStyle = replayLayoutMode === mode ? 'white' : '#e94560';
        ctx.fillText(label, btnX + width/2, btnY + 15);
        btnX += width + 3;
      });

      // Progress bar (in main area)
      const progressY = btnY + btnHeight + 10;
      const progressX = mainX + padding.left;
      ctx.fillStyle = '#0f3460';
      ctx.fillRect(progressX, progressY, chartWidth, 8);

      // Event markers on progress bar
      traceData.resources.forEach(r => {
        // Mark creation events
        if (r.createdAt > 0) {
          const x = progressX + (r.createdAt / duration) * chartWidth;
          ctx.fillStyle = 'rgba(80, 200, 120, 0.6)';  // Green for creation
          ctx.beginPath();
          ctx.arc(x, progressY + 4, 2, 0, Math.PI * 2);
          ctx.fill();
        }
        // Mark callback start events (more prominent)
        if (r.callbackStartedAt > 0) {
          const x = progressX + (r.callbackStartedAt / duration) * chartWidth;
          ctx.fillStyle = 'rgba(233, 69, 96, 0.8)';  // Red for callback
          ctx.beginPath();
          ctx.moveTo(x, progressY - 2);
          ctx.lineTo(x - 3, progressY + 10);
          ctx.lineTo(x + 3, progressY + 10);
          ctx.closePath();
          ctx.fill();
        }
      });

      // Progress fill (drawn on top of markers)
      ctx.fillStyle = '#e94560';
      ctx.globalAlpha = 0.6;
      ctx.fillRect(progressX, progressY, chartWidth * progress, 8);
      ctx.globalAlpha = 1;

      // Playhead
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(progressX + chartWidth * progress, progressY + 4, 6, 0, Math.PI * 2);
      ctx.fill();

      // Draw resources that exist at current time
      const visibleResources = traceData.resources.filter(r => r.createdAt <= replayTime);
      const activeResources = visibleResources.filter(r => {
        const endTime = r.callbackEndedAt > 0 ? r.callbackEndedAt :
                       (r.destroyedAt > 0 ? r.destroyedAt : duration);
        return endTime >= replayTime;
      });

      // Layout resources (grid or bubble mode)
      const resourceAreaTop = progressY + 25;
      const resourceAreaHeight = height - resourceAreaTop - padding.bottom;
      const resourceAreaLeft = mainX + padding.left;

      // Sort by creation time for stable layout
      const sortedVisible = [...visibleResources].sort((a, b) => a.createdAt - b.createdAt);

      // Build position map for dependency lines
      let positionMap = new Map();
      let defaultRadius = 28;

      if (replayLayoutMode === 'bubble') {
        // Bubble layout - hierarchical based on trigger relationships
        const targetPositions = computeReplayBubbleLayout(
          sortedVisible,
          chartWidth,
          resourceAreaHeight,
          resourceAreaLeft,
          resourceAreaTop
        );

        // Update positions with smoothing (use 16ms as approx frame time)
        updateReplayBubblePositions(targetPositions, 16);

        // Build position map from smoothed positions
        replayBubbleNodes.forEach((node, asyncId) => {
          positionMap.set(asyncId, {
            x: node.x,
            y: node.y,
            radius: node.radius,
            resource: node.resource
          });
        });

        // Variable radius in bubble mode
        defaultRadius = null;
      } else if (replayLayoutMode === 'rings') {
        // Rings layout - time flows outward from center like tree rings
        // Resources placed on rings based on creation time, angular position based on parent
        const centerX = resourceAreaLeft + chartWidth / 2;
        const centerY = resourceAreaTop + resourceAreaHeight / 2;
        const maxRadius = Math.min(chartWidth, resourceAreaHeight) / 2 - 40;
        const minRadius = 30;  // Inner ring radius

        // Group resources by time buckets (rings)
        const numRings = Math.min(Math.max(10, Math.ceil(sortedVisible.length / 8)), 25);
        const ringWidth = (maxRadius - minRadius) / numRings;

        // Build parent->children map for angular positioning
        const childrenMap = new Map();
        sortedVisible.forEach(r => {
          if (r.triggerId !== 0) {
            if (!childrenMap.has(r.triggerId)) {
              childrenMap.set(r.triggerId, []);
            }
            childrenMap.get(r.triggerId).push(r);
          }
        });

        // Assign angular positions using BFS from root
        // Children are placed near their parent's angle
        const angleMap = new Map();
        const ringAssignment = new Map();

        // Assign rings based on creation time buckets
        sortedVisible.forEach((r, idx) => {
          const timeFraction = r.createdAt / duration;
          const ringIndex = Math.min(numRings - 1, Math.floor(timeFraction * numRings));
          ringAssignment.set(r.asyncId, ringIndex);
        });

        // Count resources per ring for even distribution
        const resourcesPerRing = new Array(numRings).fill(0).map(() => []);
        sortedVisible.forEach(r => {
          const ringIdx = ringAssignment.get(r.asyncId);
          resourcesPerRing[ringIdx].push(r);
        });

        // Assign angles - try to place children near parents
        // First pass: assign angles to resources with no parent angle yet
        const processedAngles = new Set();

        // BFS from root(s) to assign angles based on parent position
        const queue = sortedVisible.filter(r => r.triggerId === 0 || !sortedVisible.find(p => p.asyncId === r.triggerId));

        // Initialize roots at even spacing
        const roots = queue.slice();
        roots.forEach((r, i) => {
          angleMap.set(r.asyncId, (i / Math.max(1, roots.length)) * Math.PI * 2);
        });

        // Process children, placing them near their parent
        while (queue.length > 0) {
          const resource = queue.shift();
          if (processedAngles.has(resource.asyncId)) continue;
          processedAngles.add(resource.asyncId);

          const children = childrenMap.get(resource.asyncId) || [];
          const parentAngle = angleMap.get(resource.asyncId) || 0;

          // Spread children around parent's angle
          const spread = Math.PI / 4;  // 45 degrees spread
          children.forEach((child, i) => {
            if (!angleMap.has(child.asyncId)) {
              const offset = children.length > 1
                ? (i / (children.length - 1) - 0.5) * spread
                : 0;
              angleMap.set(child.asyncId, parentAngle + offset);
              queue.push(child);
            }
          });
        }

        // Final angle adjustment: spread resources within each ring evenly while respecting parent proximity
        resourcesPerRing.forEach((ringResources, ringIdx) => {
          if (ringResources.length === 0) return;

          // Sort by current angle
          ringResources.sort((a, b) => (angleMap.get(a.asyncId) || 0) - (angleMap.get(b.asyncId) || 0));

          // Ensure minimum spacing between nodes on same ring
          const minAngularSpacing = (Math.PI * 2) / Math.max(ringResources.length, 1);
          ringResources.forEach((r, i) => {
            const baseAngle = angleMap.get(r.asyncId) || 0;
            // Blend between parent-based angle and even distribution
            const evenAngle = (i / ringResources.length) * Math.PI * 2;
            angleMap.set(r.asyncId, baseAngle * 0.3 + evenAngle * 0.7);
          });
        });

        // Calculate positions
        sortedVisible.forEach(r => {
          const ringIdx = ringAssignment.get(r.asyncId);
          const ringRadius = minRadius + (ringIdx + 0.5) * ringWidth;
          const angle = angleMap.get(r.asyncId) || 0;

          // Node radius based on execution time (like bubble mode)
          let nodeRadius = 8;  // Base size
          if (r.callbackStartedAt > 0) {
            const syncEndTime = Math.min(r.callbackEndedAt > 0 ? r.callbackEndedAt : replayTime, replayTime);
            const syncTime = Math.max(0, syncEndTime - r.callbackStartedAt);
            // Scale radius with sync time (max 20px for largest)
            nodeRadius = 8 + Math.min(12, (syncTime / duration) * 200);
          }

          const x = centerX + ringRadius * Math.cos(angle - Math.PI / 2);  // Start from top
          const y = centerY + ringRadius * Math.sin(angle - Math.PI / 2);

          positionMap.set(r.asyncId, {
            x, y,
            resource: r,
            radius: nodeRadius,
            ringRadius,  // Store for connection drawing
            angle        // Store for connection drawing
          });
        });

        // Variable radius in rings mode
        defaultRadius = null;
      } else {
        // Grid layout - original behavior
        const maxCols = Math.floor(chartWidth / 100);
        const maxRows = Math.floor(resourceAreaHeight / 80);
        const cellWidth = chartWidth / Math.max(maxCols, 1);
        const cellHeight = resourceAreaHeight / Math.max(maxRows, 1);

        sortedVisible.forEach((r, idx) => {
          if (idx >= maxCols * maxRows) return;
          const col = idx % maxCols;
          const row = Math.floor(idx / maxCols);
          const x = resourceAreaLeft + col * cellWidth + cellWidth / 2;
          const y = resourceAreaTop + row * cellHeight + cellHeight / 2;
          positionMap.set(r.asyncId, { x, y, resource: r, radius: 28 });
        });

        defaultRadius = 28;
      }

      // Store position map and radius on canvas for click/hover handling
      canvas._replayPositionMap = positionMap;
      canvas._replayCircleRadius = defaultRadius;

      // Clip graph rendering to main area (don't draw over sidebar)
      ctx.save();
      ctx.beginPath();
      ctx.rect(mainX, resourceAreaTop, mainWidth, resourceAreaHeight);
      ctx.clip();

      // Draw ring guides when in rings mode
      if (replayLayoutMode === 'rings') {
        const centerX = resourceAreaLeft + chartWidth / 2;
        const centerY = resourceAreaTop + resourceAreaHeight / 2;
        const maxRadius = Math.min(chartWidth, resourceAreaHeight) / 2 - 40;
        const minRadius = 30;
        const numRings = Math.min(Math.max(10, Math.ceil(sortedVisible.length / 8)), 25);
        const ringWidth = (maxRadius - minRadius) / numRings;

        // Draw concentric ring guides
        ctx.strokeStyle = 'rgba(100, 100, 140, 0.2)';
        ctx.lineWidth = 1;

        // Draw filled rings with alternating shades for time progression
        for (let i = 0; i < numRings; i++) {
          const radius = minRadius + (i + 1) * ringWidth;
          ctx.beginPath();
          ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
          ctx.stroke();
        }

        // Draw radial guides (like clock hands)
        ctx.strokeStyle = 'rgba(100, 100, 140, 0.1)';
        for (let i = 0; i < 12; i++) {
          const angle = (i / 12) * Math.PI * 2 - Math.PI / 2;
          ctx.beginPath();
          ctx.moveTo(centerX + minRadius * Math.cos(angle), centerY + minRadius * Math.sin(angle));
          ctx.lineTo(centerX + maxRadius * Math.cos(angle), centerY + maxRadius * Math.sin(angle));
          ctx.stroke();
        }

        // Draw center point with "t=0" label
        ctx.beginPath();
        ctx.arc(centerX, centerY, 4, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(233, 69, 96, 0.6)';
        ctx.fill();

        // Center label
        ctx.fillStyle = 'rgba(233, 69, 96, 0.7)';
        ctx.font = '9px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('t=0', centerX, centerY - 10);

        // Time labels on rings (show a few key time markers)
        ctx.fillStyle = 'rgba(100, 100, 140, 0.5)';
        ctx.font = '8px sans-serif';
        const timeLabelsToShow = [0.25, 0.5, 0.75, 1.0];
        timeLabelsToShow.forEach(fraction => {
          const ringRadius = minRadius + (maxRadius - minRadius) * fraction;
          const timeMs = (duration * fraction) / 1e6;
          const label = timeMs >= 1000 ? `${(timeMs/1000).toFixed(1)}s` : `${timeMs.toFixed(0)}ms`;
          // Position label on the right side of the ring
          ctx.textAlign = 'left';
          ctx.fillText(label, centerX + ringRadius + 3, centerY + 3);
        });

        // "time ‚Üí" indicator arrow on bottom right
        const arrowX = centerX + maxRadius * 0.7;
        const arrowY = centerY + maxRadius * 0.7;
        ctx.fillStyle = 'rgba(100, 100, 140, 0.4)';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('time ‚Üí', arrowX, arrowY);

        // Time indicator - shows current replay position as a sweeping line
        const timeAngle = (replayTime / duration) * Math.PI * 2 - Math.PI / 2;
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(centerX + maxRadius * Math.cos(timeAngle), centerY + maxRadius * Math.sin(timeAngle));
        ctx.strokeStyle = 'rgba(233, 69, 96, 0.4)';
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      // Calculate waiting counts - how many resources are waiting on each resource
      // A resource is "waiting on" another if it's created, callback not started, and is a descendant
      const waitingOnCount = new Map();
      visibleResources.forEach(r => {
        const isWaiting = r.createdAt <= replayTime &&
                         (r.callbackStartedAt === 0 || r.callbackStartedAt > replayTime);
        if (isWaiting && r.triggerId !== 0) {
          // Walk up the trigger chain and increment counts
          let currentId = r.triggerId;
          const visited = new Set();
          while (currentId !== 0 && !visited.has(currentId)) {
            visited.add(currentId);
            waitingOnCount.set(currentId, (waitingOnCount.get(currentId) || 0) + 1);
            const parent = traceData.resourceMap.get(currentId);
            currentId = parent ? parent.triggerId : 0;
          }
        }
      });

      // Update and draw execution trails
      // Track resources that just finished executing
      const trailDuration = duration * 0.15;  // Trail fades over 15% of duration
      sortedVisible.forEach(r => {
        const pos = positionMap.get(r.asyncId);
        if (!pos) return;

        // Check if this resource just finished executing (callback ended)
        if (r.callbackEndedAt > 0 && r.callbackEndedAt <= replayTime) {
          const existingTrail = replayTrail.find(t => t.asyncId === r.asyncId);
          if (!existingTrail) {
            replayTrail.push({
              asyncId: r.asyncId,
              fadeStart: r.callbackEndedAt,
              color: TYPE_COLORS[r.type] || '#808080'
            });
          }
        }
      });

      // Draw fading trails and clean up expired ones
      replayTrail = replayTrail.filter(trail => {
        const age = replayTime - trail.fadeStart;
        if (age < 0) return false;  // Remove trails from "future" (user navigated backwards)
        if (age > trailDuration) return false;  // Remove expired trails

        // Look up current position (handles viewport panning)
        const pos = positionMap.get(trail.asyncId);
        if (!pos) return false;  // Node no longer visible

        const fadeProgress = age / trailDuration;
        const alpha = Math.max(0, 0.4 * (1 - fadeProgress));
        const baseSize = pos.radius || defaultRadius || 28;
        const size = baseSize + 15 * fadeProgress;  // Expand as it fades

        ctx.beginPath();
        ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
        ctx.fillStyle = trail.color;
        ctx.globalAlpha = alpha;
        ctx.fill();
        ctx.globalAlpha = 1;

        return true;  // Keep this trail
      });

      // Ghost mode - draw expanding rings showing recent state changes
      if (replayGhostMode && replayTime > 0) {
        const ghostTime = replayTime - (duration * 0.05);  // Look back 5% of duration
        if (ghostTime > 0) {
          sortedVisible.forEach((r, idx) => {
            const pos = positionMap.get(r.asyncId);
            if (!pos) return;

            const { x, y } = pos;
            const nodeRadius = pos.radius || defaultRadius || 28;
            const color = TYPE_COLORS[r.type] || '#808080';

            // Determine CURRENT state
            const endTime = r.callbackEndedAt > 0 ? r.callbackEndedAt :
                           (r.destroyedAt > 0 ? r.destroyedAt : duration);
            const isActive = endTime >= replayTime;
            const isExecuting = r.callbackStartedAt > 0 && r.callbackStartedAt <= replayTime &&
                               r.callbackEndedAt > 0 && r.callbackEndedAt >= replayTime;
            const isWaiting = r.createdAt <= replayTime &&
                             (r.callbackStartedAt === 0 || r.callbackStartedAt > replayTime);

            // Determine GHOST state (what it was before)
            const wasCreated = r.createdAt <= ghostTime;
            const ghostEndTime = r.callbackEndedAt > 0 ? r.callbackEndedAt :
                                (r.destroyedAt > 0 ? r.destroyedAt : duration);
            const wasActive = ghostEndTime >= ghostTime;
            const wasExecuting = wasCreated && r.callbackStartedAt > 0 && r.callbackStartedAt <= ghostTime &&
                                r.callbackEndedAt > 0 && r.callbackEndedAt >= ghostTime;
            const wasWaiting = wasCreated &&
                              (r.callbackStartedAt === 0 || r.callbackStartedAt > ghostTime);

            // Draw ghost indicators for STATE CHANGES
            // Resource was just created (didn't exist at ghost time)
            if (!wasCreated && r.createdAt <= replayTime) {
              // New resource - draw pulsing creation ring
              const age = replayTime - r.createdAt;
              const pulseProgress = Math.min(1, age / (duration * 0.05));
              ctx.beginPath();
              ctx.arc(x, y, nodeRadius + 20 * pulseProgress, 0, Math.PI * 2);
              ctx.strokeStyle = '#50c878';  // Green for new
              ctx.lineWidth = 4 * (1 - pulseProgress);
              ctx.globalAlpha = 0.8 * (1 - pulseProgress);
              ctx.stroke();
              ctx.globalAlpha = 1;
            }

            // Resource just started executing (was waiting, now executing)
            if (wasWaiting && isExecuting) {
              const age = replayTime - r.callbackStartedAt;
              const pulseProgress = Math.min(1, age / (duration * 0.05));
              ctx.beginPath();
              ctx.arc(x, y, nodeRadius + 25 * pulseProgress, 0, Math.PI * 2);
              ctx.strokeStyle = '#ffaa00';  // Orange for execution start
              ctx.lineWidth = 5 * (1 - pulseProgress);
              ctx.globalAlpha = 0.9 * (1 - pulseProgress);
              ctx.stroke();
              ctx.globalAlpha = 1;
            }

            // Resource just finished executing (was executing, now done)
            if (wasExecuting && !isExecuting && r.callbackEndedAt > ghostTime) {
              const age = replayTime - r.callbackEndedAt;
              const pulseProgress = Math.min(1, age / (duration * 0.05));
              ctx.beginPath();
              ctx.arc(x, y, nodeRadius + 30 * pulseProgress, 0, Math.PI * 2);
              ctx.strokeStyle = color;
              ctx.lineWidth = 6 * (1 - pulseProgress);
              ctx.globalAlpha = 0.7 * (1 - pulseProgress);
              ctx.stroke();
              ctx.globalAlpha = 1;
            }
          });
        }
      }

      // Draw dependency lines first (behind circles)
      ctx.lineWidth = 1.5;
      sortedVisible.forEach((r, idx) => {
        const childPos = positionMap.get(r.asyncId);
        const parentPos = positionMap.get(r.triggerId);
        if (!childPos || !parentPos || r.triggerId === 0) return;

        const endTime = r.callbackEndedAt > 0 ? r.callbackEndedAt :
                       (r.destroyedAt > 0 ? r.destroyedAt : duration);
        const isActive = endTime >= replayTime;
        const parentEndTime = parentPos.resource.callbackEndedAt > 0 ? parentPos.resource.callbackEndedAt :
                             (parentPos.resource.destroyedAt > 0 ? parentPos.resource.destroyedAt : duration);
        const parentActive = parentEndTime >= replayTime;

        // Draw line from parent to child
        const dx = childPos.x - parentPos.x;
        const dy = childPos.y - parentPos.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 1) return;

        // Use per-node radius in bubble mode, fixed radius in grid mode
        const parentRadius = parentPos.radius || defaultRadius || 28;
        const childRadius = childPos.radius || defaultRadius || 28;
        const startX = parentPos.x + (dx / dist) * parentRadius;
        const startY = parentPos.y + (dy / dist) * parentRadius;
        const endX = childPos.x - (dx / dist) * childRadius;
        const endY = childPos.y - (dy / dist) * childRadius;

        // Color and style based on state
        const parentColor = TYPE_COLORS[parentPos.resource.type] || '#808080';
        if (isActive && parentActive) {
          ctx.strokeStyle = parentColor;
          ctx.globalAlpha = 0.6;
        } else {
          ctx.strokeStyle = '#444';
          ctx.globalAlpha = 0.3;
        }

        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();

        // Arrowhead
        const arrowSize = 6;
        const angle = Math.atan2(endY - startY, endX - startX);
        ctx.beginPath();
        ctx.moveTo(endX, endY);
        ctx.lineTo(endX - arrowSize * Math.cos(angle - 0.4), endY - arrowSize * Math.sin(angle - 0.4));
        ctx.lineTo(endX - arrowSize * Math.cos(angle + 0.4), endY - arrowSize * Math.sin(angle + 0.4));
        ctx.closePath();
        ctx.fillStyle = ctx.strokeStyle;
        ctx.fill();
        ctx.globalAlpha = 1;
      });

      // Draw temporal edges (dashed, green) if enabled
      if (showTemporalEdges && temporalEdges.length > 0) {
        ctx.save();
        ctx.setLineDash([4, 4]);
        ctx.strokeStyle = 'rgba(80, 200, 120, 0.6)';
        ctx.lineWidth = 1.5;

        temporalEdges.forEach(edge => {
          const fromPos = positionMap.get(edge.from);
          const toPos = positionMap.get(edge.to);
          // Only draw if both nodes are visible (have positions) at current replay time
          if (!fromPos || !toPos) return;

          // Check if both resources are currently visible
          const fromResource = fromPos.resource;
          const toResource = toPos.resource;
          if (!fromResource || !toResource) return;

          // Both should be created by current replay time
          if (fromResource.createdAt > replayTime || toResource.createdAt > replayTime) return;

          const fromRadius = fromPos.radius || defaultRadius || 28;
          const toRadius = toPos.radius || defaultRadius || 28;

          // Calculate line endpoints at circle edges
          const dx = toPos.x - fromPos.x;
          const dy = toPos.y - fromPos.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 1) return;

          const startX = fromPos.x + (dx / dist) * fromRadius;
          const startY = fromPos.y + (dy / dist) * fromRadius;
          const endX = toPos.x - (dx / dist) * toRadius;
          const endY = toPos.y - (dy / dist) * toRadius;

          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(endX, endY);
          ctx.stroke();

          // Small arrowhead
          const angle = Math.atan2(endY - startY, endX - startX);
          const arrowSize = 5;
          ctx.beginPath();
          ctx.moveTo(endX, endY);
          ctx.lineTo(endX - arrowSize * Math.cos(angle - 0.4), endY - arrowSize * Math.sin(angle - 0.4));
          ctx.moveTo(endX, endY);
          ctx.lineTo(endX - arrowSize * Math.cos(angle + 0.4), endY - arrowSize * Math.sin(angle + 0.4));
          ctx.stroke();
        });

        ctx.restore();
      }

      // Draw resource circles
      sortedVisible.forEach((r, idx) => {
        const pos = positionMap.get(r.asyncId);
        if (!pos) return;
        const { x, y } = pos;
        const radius = pos.radius || defaultRadius || 28;

        const endTime = r.callbackEndedAt > 0 ? r.callbackEndedAt :
                       (r.destroyedAt > 0 ? r.destroyedAt : duration);
        const isActive = endTime >= replayTime;
        const isExecuting = r.callbackStartedAt > 0 && r.callbackStartedAt <= replayTime &&
                           r.callbackEndedAt > 0 && r.callbackEndedAt >= replayTime;
        const isWaiting = r.createdAt <= replayTime &&
                         (r.callbackStartedAt === 0 || r.callbackStartedAt > replayTime);

        const color = TYPE_COLORS[r.type] || '#808080';

        // Pulse effect for newly created
        const age = replayTime - r.createdAt;
        const isNew = age < duration * 0.02;  // 2% of duration

        if (isNew && isActive) {
          ctx.beginPath();
          ctx.arc(x, y, radius + 12 * (1 - age / (duration * 0.02)), 0, Math.PI * 2);
          ctx.fillStyle = color;
          ctx.globalAlpha = 0.3 * (1 - age / (duration * 0.02));
          ctx.fill();
          ctx.globalAlpha = 1;
        }

        // Critical path highlight - draw first so it's behind the circle
        const isOnCriticalPath = showCriticalPath && criticalPathSet.has(r.asyncId);
        if (isOnCriticalPath && isActive) {
          ctx.beginPath();
          ctx.arc(x, y, radius + 6, 0, Math.PI * 2);
          ctx.strokeStyle = '#ff6432';
          ctx.lineWidth = 3;
          ctx.shadowColor = '#ff6432';
          ctx.shadowBlur = 15;
          ctx.stroke();
          ctx.shadowBlur = 0;
        }

        // Draw resource circle
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);

        if (!isActive) {
          // Completed - faded
          ctx.fillStyle = color;
          ctx.globalAlpha = 0.3;
          ctx.fill();
          ctx.globalAlpha = 1;
        } else if (isExecuting) {
          // Currently executing - bright with glow
          ctx.shadowColor = color;
          ctx.shadowBlur = 20;
          ctx.fillStyle = color;
          ctx.fill();
          ctx.shadowBlur = 0;

          // Spinning indicator (only if radius is large enough)
          if (radius > 8) {
            const spinAngle = (replayTime / 1e6) * 10;
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(x, y, radius - 6, spinAngle, spinAngle + Math.PI);
            ctx.stroke();
          }
        } else if (isWaiting) {
          // Waiting - pulsing outline
          ctx.fillStyle = color;
          ctx.globalAlpha = 0.5;
          ctx.fill();
          ctx.globalAlpha = 1;

          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.stroke();
          ctx.setLineDash([]);
        } else {
          ctx.fillStyle = color;
          ctx.globalAlpha = 0.7;
          ctx.fill();
          ctx.globalAlpha = 1;
        }

        // Label
        ctx.fillStyle = 'white';
        ctx.font = 'bold 10px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const label = r.type.replace('js-', '').substring(0, 6);
        ctx.fillText(label, x, y - 4);

        // Badges suppressed in rings view to reduce visual clutter
        if (replayLayoutMode !== 'rings') {
          // Lifecycle badge - ‚è≥ waiting, ‚ö° executing, ‚úì done
          ctx.font = '10px sans-serif';
          if (!isActive) {
            ctx.fillText('‚úì', x, y + 10);
          } else if (isExecuting) {
            ctx.fillText('‚ö°', x, y + 10);
          } else if (isWaiting) {
            ctx.fillText('‚è≥', x, y + 10);
          }

          // Waiting count badge
          const waitCount = waitingOnCount.get(r.asyncId) || 0;
          if (waitCount > 0 && isActive) {
            const badgeX = x + radius - 5;
            const badgeY = y - radius + 5;
            const badgeRadius = waitCount > 9 ? 10 : 8;

            // Badge background
            ctx.beginPath();
            ctx.arc(badgeX, badgeY, badgeRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#ff6432';
            ctx.fill();
            ctx.strokeStyle = '#1a1a2e';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Badge text
            ctx.fillStyle = 'white';
            ctx.font = 'bold 9px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(waitCount > 99 ? '99+' : waitCount.toString(), badgeX, badgeY);
          }

          // Critical path flame icon (shown for all critical path nodes, subtle when inactive)
          if (isOnCriticalPath) {
            const flameX = x - radius + 8;
            const flameY = y + radius - 8;
            ctx.font = isActive ? '14px sans-serif' : '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.globalAlpha = isActive ? 1.0 : 0.6;
            ctx.fillText('üî•', flameX, flameY);
            ctx.globalAlpha = 1;
          }

          // Unresolved promise indicator (shown when replay is complete or near end)
          const isUnresolved = r.type === 'js-promise' &&
                              r.createdAt > 0 &&
                              r.callbackStartedAt === 0 &&
                              r.destroyedAt === 0;
          if (isUnresolved && replayTime >= duration * 0.9) {
            // Draw a subtle "?" badge in the lower-right
            const badgeX = x + radius - 6;
            const badgeY = y + radius - 6;

            ctx.beginPath();
            ctx.arc(badgeX, badgeY, 8, 0, Math.PI * 2);
            ctx.fillStyle = '#9966cc';
            ctx.globalAlpha = 0.8;
            ctx.fill();
            ctx.globalAlpha = 1;
            ctx.strokeStyle = '#1a1a2e';
            ctx.lineWidth = 1.5;
            ctx.stroke();

            ctx.fillStyle = 'white';
            ctx.font = 'bold 10px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('?', badgeX, badgeY);

            // Also draw a dashed border around the node
            ctx.beginPath();
            ctx.arc(x, y, radius + 3, 0, Math.PI * 2);
            ctx.strokeStyle = '#9966cc';
            ctx.lineWidth = 2;
            ctx.setLineDash([4, 4]);
            ctx.globalAlpha = 0.6;
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.globalAlpha = 1;
          }
        }
      });

      // Restore context (remove clipping) before drawing sidebar
      ctx.restore();

      // Calculate live metrics
      const executing = activeResources.filter(r =>
        r.callbackStartedAt > 0 && r.callbackStartedAt <= replayTime &&
        r.callbackEndedAt > 0 && r.callbackEndedAt >= replayTime
      ).length;
      const waiting = activeResources.filter(r =>
        r.callbackStartedAt === 0 || r.callbackStartedAt > replayTime
      ).length;
      const currentParallelism = executing + waiting;
      if (currentParallelism > replayPeakParallelism) {
        replayPeakParallelism = currentParallelism;
      }

      // Calculate accumulated times
      let accumulatedSync = 0, accumulatedAsync = 0;
      visibleResources.forEach(r => {
        if (r.callbackStartedAt > 0 && r.callbackStartedAt <= replayTime) {
          const syncEnd = Math.min(r.callbackEndedAt > 0 ? r.callbackEndedAt : replayTime, replayTime);
          accumulatedSync += Math.max(0, syncEnd - r.callbackStartedAt);
        }
        if (r.createdAt > 0 && r.createdAt <= replayTime) {
          const asyncEnd = r.callbackStartedAt > 0 ? Math.min(r.callbackStartedAt, replayTime) : replayTime;
          accumulatedAsync += Math.max(0, asyncEnd - r.createdAt);
        }
      });

      // Count promises alive
      const promisesAlive = activeResources.filter(r => r.type === 'js-promise').length;

      // Calculate accumulated user vs runtime time for overhead indicator
      let accUserTime = 0, accRuntimeTime = 0;
      visibleResources.forEach(r => {
        const cls = r._classification || 'internal';
        // Sync time contribution
        if (r.callbackStartedAt > 0 && r.callbackStartedAt <= replayTime) {
          const syncEnd = Math.min(r.callbackEndedAt > 0 ? r.callbackEndedAt : replayTime, replayTime);
          const syncContrib = Math.max(0, syncEnd - r.callbackStartedAt);
          if (cls === 'typed' || cls === 'user') {
            accUserTime += syncContrib;
          } else {
            accRuntimeTime += syncContrib;
          }
        }
        // Async time contribution
        if (r.createdAt > 0 && r.createdAt <= replayTime) {
          const asyncEnd = r.callbackStartedAt > 0 ? Math.min(r.callbackStartedAt, replayTime) : replayTime;
          const asyncContrib = Math.max(0, asyncEnd - r.createdAt);
          if (cls === 'typed' || cls === 'user') {
            accUserTime += asyncContrib;
          } else {
            accRuntimeTime += asyncContrib;
          }
        }
      });

      // Track events as replay progresses
      if (replayTime > replayLastEventTime) {
        traceData.resources.forEach(r => {
          // Created events
          if (r.createdAt > replayLastEventTime && r.createdAt <= replayTime) {
            replayEventLog.push({
              time: r.createdAt,
              type: 'created',
              message: `${r.type} #${r.asyncId} created`,
              color: TYPE_COLORS[r.type] || '#808080'
            });
          }
          // Callback started events
          if (r.callbackStartedAt > replayLastEventTime && r.callbackStartedAt <= replayTime) {
            replayEventLog.push({
              time: r.callbackStartedAt,
              type: 'started',
              message: `${r.type} #${r.asyncId} executing`,
              color: '#50c878'
            });
          }
          // Callback ended events
          if (r.callbackEndedAt > replayLastEventTime && r.callbackEndedAt <= replayTime) {
            replayEventLog.push({
              time: r.callbackEndedAt,
              type: 'completed',
              message: `${r.type} #${r.asyncId} completed`,
              color: '#7ec8e3'
            });
          }
        });
        // Keep only last 50 events
        if (replayEventLog.length > 50) {
          replayEventLog = replayEventLog.slice(-50);
        }
        replayLastEventTime = replayTime;
      }

      // Bottleneck alert (when parallelism = 1 and we have waiting resources)
      if (showBottlenecks && currentParallelism === 1 && executing === 1 && waiting === 0 && activeResources.length > 0) {
        const blockingResource = activeResources.find(r =>
          r.callbackStartedAt > 0 && r.callbackStartedAt <= replayTime &&
          r.callbackEndedAt > 0 && r.callbackEndedAt >= replayTime
        );
        if (blockingResource) {
          const existingAlert = replayLiveAlerts.find(a => a.type === 'bottleneck');
          if (!existingAlert) {
            replayLiveAlerts.push({
              type: 'bottleneck',
              message: `‚ö†Ô∏è Serialization: ${blockingResource.type} #${blockingResource.asyncId}`,
              color: '#ffd700',
              expireTime: replayTime + duration * 0.05
            });
          }
        }
      }

      // Live pattern detection (when patterns enabled)
      if (showPatterns) {
        // Detection window - alert when resource is first "seen" in replay
        const alertWindow = duration * 0.2;  // 20% of duration for detection window

        // Check for sequential fetch pattern - fetches created during another fetch's callback
        traceData.resources.forEach(r => {
          if (r.type !== 'fetch' || r.createdAt <= 0) return;
          if (r.createdAt > replayTime) return;  // Not created yet

          const patternKey = `seq-fetch-${r.asyncId}`;
          if (replayAlertedPatterns.has(patternKey)) return;  // Already alerted

          // Check if recently became visible (within detection window)
          if (r.createdAt < replayTime - alertWindow) return;

          // Check if parent is a fetch and this was created during parent's callback
          const trigger = traceData.resourceMap.get(r.triggerId);
          if (trigger && trigger.type === 'fetch' &&
              trigger.callbackStartedAt > 0 &&
              r.createdAt >= trigger.callbackStartedAt) {
            replayAlertedPatterns.add(patternKey);
            replayLiveAlerts.push({
              type: 'sequential-fetch',
              resourceId: r.asyncId,
              message: `üîç Sequential fetch #${r.asyncId} (await chain)`,
              color: '#cc66ff',
              expireTime: replayTime + duration * 0.2
            });
          }
        });

        // Check for duplicate fetches to same URL
        const fetchUrls = new Map();
        visibleResources.filter(r => r.type === 'fetch').forEach(f => {
          const urlAnnotation = traceData.annotations.find(a => a.asyncId === f.asyncId && a.key === 'url');
          if (urlAnnotation) {
            const url = urlAnnotation.value;
            if (!fetchUrls.has(url)) fetchUrls.set(url, []);
            fetchUrls.get(url).push(f);
          }
        });
        fetchUrls.forEach((fetches, url) => {
          if (fetches.length > 1) {
            const patternKey = `dup-fetch-${url}`;
            if (replayAlertedPatterns.has(patternKey)) return;

            // Alert when second fetch becomes visible
            const secondFetch = fetches[1];
            if (secondFetch.createdAt <= replayTime &&
                secondFetch.createdAt > replayTime - alertWindow) {
              replayAlertedPatterns.add(patternKey);
              const shortUrl = url.length > 25 ? url.substring(0, 25) + '‚Ä¶' : url;
              replayLiveAlerts.push({
                type: 'duplicate-fetch',
                url: url,
                message: `üîç Duplicate: ${shortUrl}`,
                color: '#cc66ff',
                expireTime: replayTime + duration * 0.2
              });
            }
          }
        });

        // Check for promise flood - many promises created in a short window
        const promiseWindow = 1e6;  // 1ms in nanoseconds
        const recentPromises = traceData.resources.filter(r =>
          r.type === 'js-promise' &&
          r.createdAt > replayTime - promiseWindow &&
          r.createdAt <= replayTime
        );
        if (recentPromises.length >= 8) {
          // Use time bucket as pattern key to allow re-alerting for different bursts
          const bucket = Math.floor(replayTime / promiseWindow);
          const patternKey = `promise-flood-${bucket}`;
          if (!replayAlertedPatterns.has(patternKey)) {
            replayAlertedPatterns.add(patternKey);
            replayLiveAlerts.push({
              type: 'promise-flood',
              message: `üîç Promise burst: ${recentPromises.length} in 1ms`,
              color: '#cc66ff',
              expireTime: replayTime + duration * 0.2
            });
          }
        }

        // Check for long sync execution (event loop blocking)
        visibleResources.forEach(r => {
          if (r.callbackStartedAt <= 0 || r.callbackEndedAt <= 0) return;
          if (r.callbackEndedAt > replayTime) return;  // Not finished yet

          const syncTime = r.callbackEndedAt - r.callbackStartedAt;
          if (syncTime > 50e6) {  // > 50ms
            const patternKey = `long-sync-${r.asyncId}`;
            if (replayAlertedPatterns.has(patternKey)) return;

            // Alert when callback ends
            if (r.callbackEndedAt > replayTime - alertWindow) {
              replayAlertedPatterns.add(patternKey);
              replayLiveAlerts.push({
                type: 'long-sync',
                message: `‚ö†Ô∏è Long sync: ${r.type} took ${(syncTime/1e6).toFixed(0)}ms`,
                color: '#ffd700',
                expireTime: replayTime + duration * 0.2
              });
            }
          }
        });
      }

      // Expire old alerts
      replayLiveAlerts = replayLiveAlerts.filter(a => a.expireTime > replayTime);

      // ===== SIDEBAR PANELS =====
      const sbPadding = 8;
      const sbContentWidth = sidebarWidth - sbPadding * 2;
      let sbY = 18;  // Top padding for sidebar content

      // Track section header hit areas for click handling
      const sectionHeaders = [];

      // Helper to draw collapsible section header (styled like main sidebar)
      const drawSectionHeader = (title, sectionKey, color = '#aaa') => {
        const headerY = sbY;
        const isCollapsed = replaySidebarCollapsed[sectionKey];

        // Draw header text
        ctx.fillStyle = color;
        ctx.font = 'bold 10px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(title, sbPadding, sbY);

        // Draw collapse arrow
        ctx.font = '8px sans-serif';
        ctx.textAlign = 'right';
        ctx.fillStyle = '#666';
        ctx.fillText(isCollapsed ? '‚ñ∂' : '‚ñº', sidebarWidth - sbPadding, sbY);
        ctx.textAlign = 'left';

        // Store hit area for click handling
        sectionHeaders.push({
          key: sectionKey,
          y: headerY - 10,
          height: 14
        });

        sbY += 4;

        // Draw separator line under header
        ctx.strokeStyle = '#0f3460';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(sbPadding, sbY);
        ctx.lineTo(sidebarWidth - sbPadding, sbY);
        ctx.stroke();
        sbY += 8;

        return !isCollapsed;  // Return true if section should show content
      };

      // Helper to draw stat line
      const drawStatLine = (label, value, color = '#aaa') => {
        ctx.fillStyle = color;
        ctx.font = '10px sans-serif';
        ctx.fillText(`${label}: ${value}`, sbPadding, sbY);
        sbY += 14;
      };

      // Helper to draw section bottom margin
      const drawSectionEnd = () => {
        sbY += 8;
      };

      // ----- Live Metrics Section -----
      if (drawSectionHeader('Live Metrics', 'metrics')) {
        drawStatLine('Created', visibleResources.length);
        drawStatLine('Parallelism', currentParallelism,
          currentParallelism > 1 ? '#50c878' : (currentParallelism === 1 ? '#ffd700' : '#888'));
        drawStatLine('Peak', replayPeakParallelism, '#7ec8e3');
        drawStatLine('Sync', `${(accumulatedSync / 1e6).toFixed(1)}ms`);
        drawStatLine('Async', `${(accumulatedAsync / 1e6).toFixed(1)}ms`);
        drawStatLine('Promises', promisesAlive, promisesAlive > 10 ? '#ffd700' : '#aaa');
      }
      drawSectionEnd();

      // ----- Runtime Overhead Section -----
      if (drawSectionHeader('User vs Runtime', 'overhead')) {
        const accTotalTime = accUserTime + accRuntimeTime;
        if (accTotalTime > 0) {
          // Draw horizontal bar chart
          const barWidth = sbContentWidth;
          const barHeight = 12;
          const userPct = accUserTime / accTotalTime;
          const runtimePct = accRuntimeTime / accTotalTime;
          const userBarWidth = barWidth * userPct;
          const runtimeBarWidth = barWidth * runtimePct;

          // User portion (green)
          ctx.fillStyle = '#50c878';
          ctx.fillRect(sbPadding, sbY, userBarWidth, barHeight);

          // Runtime portion (orange)
          ctx.fillStyle = '#ff8c00';
          ctx.fillRect(sbPadding + userBarWidth, sbY, runtimeBarWidth, barHeight);

          // Border
          ctx.strokeStyle = '#333';
          ctx.lineWidth = 1;
          ctx.strokeRect(sbPadding, sbY, barWidth, barHeight);

          sbY += barHeight + 6;

          // Percentage labels
          ctx.font = '9px sans-serif';
          ctx.fillStyle = '#50c878';
          ctx.fillText(`User ${(userPct * 100).toFixed(0)}%`, sbPadding, sbY);
          ctx.fillStyle = '#ff8c00';
          ctx.textAlign = 'right';
          ctx.fillText(`${(runtimePct * 100).toFixed(0)}% Runtime`, sbPadding + barWidth, sbY);
          ctx.textAlign = 'left';
          sbY += 12;

          // Time values
          ctx.fillStyle = '#666';
          ctx.font = '8px sans-serif';
          ctx.fillText(`${(accUserTime / 1e6).toFixed(1)}ms / ${(accRuntimeTime / 1e6).toFixed(1)}ms`, sbPadding, sbY);
          sbY += 4;
        } else {
          ctx.fillStyle = '#666';
          ctx.font = '9px sans-serif';
          ctx.fillText('No timing data yet', sbPadding, sbY);
          sbY += 14;
        }
      }
      drawSectionEnd();

      // ----- Critical Path Section -----
      if (showCriticalPath && criticalPathInfo && criticalPathInfo.path.length > 0) {
        if (drawSectionHeader('Critical Path', 'criticalPath', '#ff6432')) {
          // Find current position on critical path
          let cpCompleted = 0;
          criticalPathInfo.path.forEach(r => {
            const endTime = r.callbackEndedAt > 0 ? r.callbackEndedAt :
                           (r.destroyedAt > 0 ? r.destroyedAt : 0);
            if (endTime > 0 && endTime <= replayTime) {
              cpCompleted++;
            } else if (r.callbackStartedAt > 0 && r.callbackStartedAt <= replayTime) {
              cpCompleted += 0.5;
            } else if (r.createdAt > 0 && r.createdAt <= replayTime && r.callbackStartedAt === 0) {
              cpCompleted += 0.1;
            }
          });
          cpCompleted = Math.floor(cpCompleted);

          ctx.fillStyle = '#ff8c5a';
          ctx.font = '10px sans-serif';
          ctx.fillText(`Step ${cpCompleted} of ${criticalPathInfo.path.length}`, sbPadding, sbY);
          sbY += 12;

          // Progress bar
          const cpProgress = cpCompleted / criticalPathInfo.path.length;
          ctx.fillStyle = '#333';
          ctx.fillRect(sbPadding, sbY, sbContentWidth, 6);
          ctx.fillStyle = '#ff6432';
          ctx.fillRect(sbPadding, sbY, sbContentWidth * cpProgress, 6);
          sbY += 10;
        }
        drawSectionEnd();
      }

      // ----- Pattern Alerts Section -----
      if (replayLiveAlerts.length > 0) {
        if (drawSectionHeader('Alerts', 'alerts', '#cc66ff')) {
          replayLiveAlerts.slice(0, 4).forEach(alert => {
            const remaining = (alert.expireTime - replayTime) / (duration * 0.15);
            ctx.globalAlpha = Math.min(1, Math.max(0.3, remaining));
            ctx.fillStyle = alert.color;
            ctx.font = '9px sans-serif';
            // Wrap long messages to multiple lines
            const maxChars = 28;
            const msg = alert.message;
            if (msg.length <= maxChars) {
              ctx.fillText(msg, sbPadding, sbY);
              sbY += 13;
            } else {
              // Split into two lines
              const line1 = msg.substring(0, maxChars);
              const line2 = msg.substring(maxChars, maxChars * 2);
              ctx.fillText(line1, sbPadding, sbY);
              sbY += 11;
              ctx.fillText(line2 + (msg.length > maxChars * 2 ? '‚Ä¶' : ''), sbPadding, sbY);
              sbY += 13;
            }
          });
          ctx.globalAlpha = 1;
        }
        drawSectionEnd();
      }

      // ----- Event Feed Section -----
      if (drawSectionHeader('Event Feed', 'eventFeed')) {
        if (replayEventLog.length === 0) {
          ctx.fillStyle = '#666';
          ctx.font = '9px sans-serif';
          ctx.fillText('Press Play to start', sbPadding, sbY);
          sbY += 14;
        } else {
          // Show recent events (newest at top)
          const maxEvents = Math.min(8, Math.floor((height - sbY - 10) / 13));
          const recentEvents = replayEventLog.slice(-maxEvents).reverse();
          ctx.font = '9px monospace';
          recentEvents.forEach((event, idx) => {
            const alpha = 1 - (idx * 0.08);
            ctx.globalAlpha = alpha;
            ctx.fillStyle = event.color;
            const timeStr = (event.time / 1e6).toFixed(1).padStart(5);
            const msgTrunc = event.message.length > 15 ? event.message.substring(0, 15) + '‚Ä¶' : event.message;
            ctx.fillText(`${timeStr} ${msgTrunc}`, sbPadding, sbY);
            sbY += 13;
          });
          ctx.globalAlpha = 1;
        }
      }

      // Store section headers for click handling
      canvas._sidebarHeaders = sectionHeaders;

      ctx.textAlign = 'left';  // Reset

      // Handle click events for controls
      canvas.onclick = (e) => {
        const rect = canvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;

        // Check sidebar section header clicks
        if (clickX >= 0 && clickX <= sidebarWidth && canvas._sidebarHeaders) {
          for (const header of canvas._sidebarHeaders) {
            if (clickY >= header.y && clickY <= header.y + header.height) {
              replaySidebarCollapsed[header.key] = !replaySidebarCollapsed[header.key];
              renderReplayFrame();
              return;
            }
          }
        }

        // Check play/pause button (centered in main area)
        const playBtnX = mainX + (mainWidth - totalBtnWidth) / 2;
        if (clickX >= playBtnX && clickX <= playBtnX + btnWidth &&
            clickY >= btnY && clickY <= btnY + btnHeight) {
          if (replayPlaying) {
            stopReplayAnimation();
          } else {
            if (replayTime >= duration) {
              replayTime = 0;
              replayTrail = [];
            }
            startReplayAnimation();
          }
          renderReplayFrame();
          return;
        }

        // Check reset button
        const resetBtnX = playBtnX + btnWidth + btnSpacing;
        if (clickX >= resetBtnX && clickX <= resetBtnX + btnWidth &&
            clickY >= btnY && clickY <= btnY + btnHeight) {
          stopReplayAnimation();
          replayTime = 0;
          replayPeakParallelism = 0;
          replayEventLog = [];
          replayLastEventTime = 0;
          replayLiveAlerts = [];
          replayAlertedPatterns = new Set();
          replayTrail = [];
          renderReplayFrame();
          return;
        }

        // Check speed buttons
        let speedBtnX = resetBtnX + btnWidth + btnSpacing;
        // Speed buttons (compact layout)
        speeds.forEach(speed => {
          const speedWidth = speed === 0.25 ? 32 : 28;
          if (clickX >= speedBtnX && clickX <= speedBtnX + speedWidth &&
              clickY >= btnY && clickY <= btnY + btnHeight) {
            replaySpeed = speed;
            saveSettings();
            renderReplayFrame();
          }
          speedBtnX += speedWidth + 3;
        });

        // Check loop button (compact: icon only)
        const loopBtnX = speedBtnX + 3;
        if (clickX >= loopBtnX && clickX <= loopBtnX + 38 &&
            clickY >= btnY && clickY <= btnY + btnHeight) {
          replayLoop = !replayLoop;
          saveSettings();
          renderReplayFrame();
          return;
        }

        // Check ghost button (compact: icon only)
        const ghostBtnX = loopBtnX + 41;
        if (clickX >= ghostBtnX && clickX <= ghostBtnX + 38 &&
            clickY >= btnY && clickY <= btnY + btnHeight) {
          replayGhostMode = !replayGhostMode;
          saveSettings();
          renderReplayFrame();
          return;
        }

        // Check layout buttons (compact: icons only, 28px each)
        const layoutBtnStartX = ghostBtnX + 41 + 5;
        const layoutBtnWidth = 28;
        const layoutBtnSpacing = 31;  // 28 + 3
        const layoutModes = ['grid', 'bubble', 'rings'];
        layoutModes.forEach((mode, idx) => {
          const btnX = layoutBtnStartX + idx * layoutBtnSpacing;
          if (clickX >= btnX && clickX <= btnX + layoutBtnWidth &&
              clickY >= btnY && clickY <= btnY + btnHeight) {
            replayLayoutMode = mode;
            replayBubbleNodes.clear();
            replayBubbleViewport = { x: 0, y: 0, scale: 1 };
            saveSettings();
            renderReplayFrame();
            return;
          }
        });

        // Check progress bar click (in main area)
        if (clickY >= progressY && clickY <= progressY + 8 &&
            clickX >= progressX && clickX <= progressX + chartWidth) {
          const clickProgress = (clickX - progressX) / chartWidth;
          replayTime = clickProgress * duration;
          renderReplayFrame();
          return;
        }

        // Check resource circle clicks
        if (canvas._replayPositionMap) {
          for (const [asyncId, pos] of canvas._replayPositionMap) {
            const radius = pos.radius || canvas._replayCircleRadius || 28;
            const dx = clickX - pos.x;
            const dy = clickY - pos.y;
            if (Math.sqrt(dx * dx + dy * dy) <= radius) {
              selectResource(pos.resource);
              if (clickToFilterEnabled) {
                applyClickFilter(pos.resource.asyncId);
              }
              return;
            }
          }
        }
      };

      // Show pointer cursor over clickable elements
      canvas.onmousemove = (e) => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // Check if over sidebar section header
        if (mouseX >= 0 && mouseX <= sidebarWidth && canvas._sidebarHeaders) {
          for (const header of canvas._sidebarHeaders) {
            if (mouseY >= header.y && mouseY <= header.y + header.height) {
              canvas.style.cursor = 'pointer';
              return;
            }
          }
        }

        // Check if over control buttons or progress bar
        if (mouseY >= btnY && mouseY <= btnY + btnHeight) {
          canvas.style.cursor = 'pointer';
          return;
        }
        if (mouseY >= progressY && mouseY <= progressY + 8 &&
            mouseX >= progressX && mouseX <= progressX + chartWidth) {
          canvas.style.cursor = 'pointer';
          return;
        }

        // Check if over resource circles
        if (canvas._replayPositionMap) {
          for (const [asyncId, pos] of canvas._replayPositionMap) {
            const radius = pos.radius || canvas._replayCircleRadius || 28;
            const dx = mouseX - pos.x;
            const dy = mouseY - pos.y;
            if (Math.sqrt(dx * dx + dy * dy) <= radius) {
              canvas.style.cursor = 'pointer';
              return;
            }
          }
        }

        canvas.style.cursor = 'default';
      };
    }

    // ==================== HEATMAP VIEW ====================
    function renderHeatmap() {
      const container = document.getElementById('heatmap-view');
      const canvas = document.getElementById('heatmap-canvas');
      const ctx = canvas.getContext('2d');

      // Account for controls height
      const controls = document.getElementById('heatmap-controls');
      const controlsHeight = controls ? controls.offsetHeight : 0;
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight - controlsHeight;

      const width = canvas.width;
      const height = canvas.height;
      const padding = { top: 60, right: 30, bottom: 60, left: 120 };
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;

      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, width, height);

      if (!traceData) return;

      // Get filtered resources
      let resources = traceData.resources.filter(r => {
        if (hideInternal && r._classification === 'internal') return false;
        return true;
      });

      // Apply click-to-filter
      if (clickToFilterEnabled && clickFilterResourceId !== null) {
        resources = resources.filter(r => isResourceVisible(r.asyncId));
      }

      const duration = traceData.requestDurationNs;

      // Get unique resource types
      let types = Array.from(new Set(resources.map(r => r.type)));
      if (types.length === 0) {
        ctx.fillStyle = '#666';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('No resources to display', width / 2, height / 2);
        return;
      }

      // Compute type metrics for sorting
      const typeMetrics = new Map();
      types.forEach(t => typeMetrics.set(t, { activity: 0, peak: 0, first: duration }));
      resources.forEach(r => {
        const m = typeMetrics.get(r.type);
        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          m.activity += r.callbackEndedAt - r.callbackStartedAt;
        }
        if (r.createdAt > 0 && r.createdAt < m.first) {
          m.first = r.createdAt;
        }
      });

      // Sort types based on selected mode
      switch (heatmapSortMode) {
        case 'alpha':
          types.sort((a, b) => a.localeCompare(b));
          break;
        case 'peak':
          // Will be computed after bucket data
          break;
        case 'first':
          types.sort((a, b) => typeMetrics.get(a).first - typeMetrics.get(b).first);
          break;
        case 'activity':
        default:
          types.sort((a, b) => typeMetrics.get(b).activity - typeMetrics.get(a).activity);
          break;
      }

      // Define time buckets
      const autoBuckets = Math.min(80, Math.floor(chartWidth / 8));
      const numBuckets = heatmapBucketCount > 0 ? heatmapBucketCount : autoBuckets;
      const bucketWidth = duration / numBuckets;
      const rowHeight = Math.min(30, chartHeight / types.length);

      // Build heatmap data: [type][bucket] = {sync, async, count, resources}
      const heatmapDataMap = new Map();
      types.forEach(type => {
        heatmapDataMap.set(type, new Array(numBuckets).fill(null).map(() => ({
          sync: 0, async: 0, count: 0, resources: []
        })));
      });

      // Fill heatmap with activity
      resources.forEach(r => {
        const typeData = heatmapDataMap.get(r.type);
        if (!typeData) return;

        // Add activity during callback execution (sync)
        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          const startBucket = Math.floor(r.callbackStartedAt / bucketWidth);
          const endBucket = Math.floor(r.callbackEndedAt / bucketWidth);
          for (let b = Math.max(0, startBucket); b <= Math.min(numBuckets - 1, endBucket); b++) {
            typeData[b].sync += 1;
            typeData[b].count += 1;
            if (!typeData[b].resources.includes(r)) typeData[b].resources.push(r);
          }
        }

        // Async waiting time
        if (r.createdAt > 0) {
          const waitEnd = r.callbackStartedAt > 0 ? r.callbackStartedAt :
                         (r.destroyedAt > 0 ? r.destroyedAt : duration);
          if (waitEnd > r.createdAt) {
            const startBucket = Math.floor(r.createdAt / bucketWidth);
            const endBucket = Math.floor(waitEnd / bucketWidth);
            for (let b = Math.max(0, startBucket); b <= Math.min(numBuckets - 1, endBucket); b++) {
              typeData[b].async += 1;
              if (!typeData[b].resources.includes(r)) typeData[b].resources.push(r);
            }
          }
        }
      });

      // For peak sorting, compute peak intensity per type
      if (heatmapSortMode === 'peak') {
        types.forEach(type => {
          const typeData = heatmapDataMap.get(type);
          let peak = 0;
          typeData.forEach(cell => {
            const val = cell.sync + cell.async * 0.3;
            if (val > peak) peak = val;
          });
          typeMetrics.get(type).peak = peak;
        });
        types.sort((a, b) => typeMetrics.get(b).peak - typeMetrics.get(a).peak);
      }

      // Compute intensity based on activity mode
      const getIntensity = (cell) => {
        switch (heatmapActivityMode) {
          case 'sync': return cell.sync;
          case 'async': return cell.async;
          case 'count': return cell.count;
          case 'combined':
          default: return cell.sync + cell.async * 0.3;
        }
      };

      // Find max intensity for normalization
      let maxIntensity = 0;
      heatmapDataMap.forEach(typeData => {
        typeData.forEach(cell => {
          const v = getIntensity(cell);
          if (v > maxIntensity) maxIntensity = v;
        });
      });
      if (maxIntensity === 0) maxIntensity = 1;

      // Store for hover detection
      heatmapData = { types, dataMap: heatmapDataMap, bucketWidth, numBuckets };
      heatmapRenderParams = { padding, chartWidth, chartHeight, rowHeight, cellWidth: chartWidth / numBuckets, duration, height };

      // Check which types are on critical path
      const criticalTypes = new Set();
      if (showCriticalPath) {
        resources.forEach(r => {
          if (criticalPathSet.has(r.asyncId)) {
            criticalTypes.add(r.type);
          }
        });
      }

      // Draw title
      ctx.fillStyle = '#e94560';
      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'center';
      const modeLabels = { combined: 'Combined', sync: 'Sync Only', async: 'Async Only', count: 'Resource Count' };
      ctx.fillText(`Activity Heatmap - ${modeLabels[heatmapActivityMode]}`, width / 2, 25);

      ctx.fillStyle = '#888';
      ctx.font = '11px sans-serif';
      ctx.fillText('Brighter = more activity in that time window', width / 2, 42);

      // Color scheme helpers
      const getHeatColor = (normalizedIntensity) => {
        // Blue -> Cyan -> Yellow -> Red
        if (normalizedIntensity < 0.33) {
          const t = normalizedIntensity / 0.33;
          return `rgb(${Math.floor(30 * (1 - t))}, ${Math.floor(100 * t + 30)}, ${Math.floor(200 * t + 50)})`;
        } else if (normalizedIntensity < 0.66) {
          const t = (normalizedIntensity - 0.33) / 0.33;
          return `rgb(${Math.floor(255 * t)}, ${Math.floor(200 + 55 * t)}, ${Math.floor(250 * (1 - t))})`;
        } else {
          const t = (normalizedIntensity - 0.66) / 0.34;
          return `rgb(255, ${Math.floor(255 * (1 - t))}, ${Math.floor(50 * (1 - t))})`;
        }
      };

      const getMonoColor = (normalizedIntensity) => {
        const v = Math.floor(normalizedIntensity * 200 + 30);
        return `rgb(${v}, ${v}, ${v})`;
      };

      // Draw heatmap cells
      const cellWidth = chartWidth / numBuckets;
      types.forEach((type, typeIdx) => {
        const y = padding.top + typeIdx * rowHeight;
        const typeData = heatmapDataMap.get(type);
        const baseColor = TYPE_COLORS[type] || '#808080';
        const isOnCriticalPath = criticalTypes.has(type);

        // Parse base color to RGB for 'type' scheme
        const hex = baseColor.replace('#', '');
        const baseR = parseInt(hex.substr(0, 2), 16);
        const baseG = parseInt(hex.substr(2, 2), 16);
        const baseB = parseInt(hex.substr(4, 2), 16);

        typeData.forEach((cell, bucket) => {
          const x = padding.left + bucket * cellWidth;
          const intensity = getIntensity(cell);
          const normalizedIntensity = intensity / maxIntensity;
          const isHovered = heatmapHoverCell && heatmapHoverCell.typeIdx === typeIdx && heatmapHoverCell.bucket === bucket;

          // Determine cell color based on scheme
          let fillColor;
          switch (heatmapColorScheme) {
            case 'heat':
              fillColor = normalizedIntensity > 0.01 ? getHeatColor(normalizedIntensity) : 'rgba(30, 30, 50, 0.5)';
              break;
            case 'mono':
              fillColor = normalizedIntensity > 0.01 ? getMonoColor(normalizedIntensity) : 'rgba(30, 30, 50, 0.5)';
              break;
            case 'type':
            default:
              const alpha = Math.min(1, normalizedIntensity * 1.5);
              fillColor = normalizedIntensity > 0.01 ? `rgba(${baseR}, ${baseG}, ${baseB}, ${alpha * 0.9})` : 'rgba(30, 30, 50, 0.3)';
              break;
          }

          ctx.fillStyle = fillColor;
          ctx.fillRect(x, y, cellWidth + 0.5, rowHeight - 1);

          // Add brighter highlight for high intensity
          if (normalizedIntensity > 0.7 && heatmapColorScheme === 'type') {
            ctx.fillStyle = `rgba(255, 255, 255, ${(normalizedIntensity - 0.7) * 0.5})`;
            ctx.fillRect(x, y, cellWidth + 0.5, rowHeight - 1);
          }

          // Hover highlight
          if (isHovered) {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(x + 1, y + 1, cellWidth - 2, rowHeight - 3);
          }
        });

        // Critical path indicator on row
        if (showCriticalPath && isOnCriticalPath) {
          ctx.strokeStyle = '#ff6600';
          ctx.lineWidth = 2;
          ctx.setLineDash([4, 2]);
          ctx.strokeRect(padding.left - 2, y - 1, chartWidth + 4, rowHeight + 1);
          ctx.setLineDash([]);
        }

        // Type label
        ctx.fillStyle = TYPE_COLORS[type] || '#888';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        const label = type.replace('js-', '').replace('cache-', 'c:');
        const critBadge = showCriticalPath && isOnCriticalPath ? ' üî•' : '';
        ctx.fillText(label + critBadge, padding.left - 8, y + rowHeight / 2);
      });

      // Draw time axis
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding.left, padding.top + types.length * rowHeight);
      ctx.lineTo(padding.left + chartWidth, padding.top + types.length * rowHeight);
      ctx.stroke();

      // Time labels
      ctx.fillStyle = '#888';
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      const numLabels = Math.min(10, numBuckets);
      for (let i = 0; i <= numLabels; i++) {
        const x = padding.left + (i / numLabels) * chartWidth;
        const time = (i / numLabels) * duration / 1e6;
        ctx.fillText(`${time.toFixed(1)}ms`, x, padding.top + types.length * rowHeight + 5);

        // Grid line
        if (i > 0 && i < numLabels) {
          ctx.strokeStyle = 'rgba(68, 68, 68, 0.3)';
          ctx.beginPath();
          ctx.moveTo(x, padding.top);
          ctx.lineTo(x, padding.top + types.length * rowHeight);
          ctx.stroke();
        }
      }

      // Legend
      const legendY = height - 30;
      ctx.fillStyle = '#888';
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText('Intensity:', padding.left, legendY);

      const gradientWidth = 100;
      const gradientX = padding.left + 60;
      for (let i = 0; i < gradientWidth; i++) {
        const intensity = i / gradientWidth;
        switch (heatmapColorScheme) {
          case 'heat':
            ctx.fillStyle = getHeatColor(intensity);
            break;
          case 'mono':
            ctx.fillStyle = getMonoColor(intensity);
            break;
          case 'type':
          default:
            ctx.fillStyle = `rgba(233, 69, 96, ${intensity})`;
            break;
        }
        ctx.fillRect(gradientX + i, legendY - 5, 1, 10);
      }
      ctx.fillStyle = '#888';
      ctx.fillText('Low', gradientX - 25, legendY);
      ctx.fillText('High', gradientX + gradientWidth + 5, legendY);

      // Setup event handlers (once)
      if (!canvas._heatmapHandlersSet) {
        canvas._heatmapHandlersSet = true;
        setupHeatmapEventHandlers(canvas);
      }
    }

    function setupHeatmapEventHandlers(canvas) {
      // Control handlers
      document.getElementById('heatmap-bucket-slider').addEventListener('input', (e) => {
        heatmapBucketCount = parseInt(e.target.value);
        document.getElementById('heatmap-bucket-value').textContent = heatmapBucketCount;
        renderHeatmap();
      });

      document.getElementById('heatmap-color-select').addEventListener('change', (e) => {
        heatmapColorScheme = e.target.value;
        renderHeatmap();
      });

      document.getElementById('heatmap-activity-select').addEventListener('change', (e) => {
        heatmapActivityMode = e.target.value;
        renderHeatmap();
      });

      document.getElementById('heatmap-sort-select').addEventListener('change', (e) => {
        heatmapSortMode = e.target.value;
        renderHeatmap();
      });

      // Hover handler
      canvas.addEventListener('mousemove', (e) => {
        if (currentView !== 'heatmap' || !heatmapRenderParams || !heatmapData) {
          canvas.style.cursor = 'default';
          return;
        }

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const { padding, rowHeight, cellWidth, height } = heatmapRenderParams;
        const { types, numBuckets } = heatmapData;

        let hoveredCell = null;
        if (x >= padding.left && x <= padding.left + cellWidth * numBuckets &&
            y >= padding.top && y <= padding.top + types.length * rowHeight) {
          const bucket = Math.floor((x - padding.left) / cellWidth);
          const typeIdx = Math.floor((y - padding.top) / rowHeight);
          if (bucket >= 0 && bucket < numBuckets && typeIdx >= 0 && typeIdx < types.length) {
            hoveredCell = { typeIdx, bucket };
          }
        }

        canvas.style.cursor = hoveredCell ? 'pointer' : 'default';

        const cellChanged = !heatmapHoverCell && hoveredCell ||
                           heatmapHoverCell && !hoveredCell ||
                           (heatmapHoverCell && hoveredCell &&
                            (heatmapHoverCell.typeIdx !== hoveredCell.typeIdx ||
                             heatmapHoverCell.bucket !== hoveredCell.bucket));

        if (cellChanged) {
          heatmapHoverCell = hoveredCell;
          renderHeatmap();
          if (hoveredCell) {
            showHeatmapTooltip(e, hoveredCell);
          } else {
            hideHeatmapTooltip();
          }
        } else if (hoveredCell) {
          updateHeatmapTooltipPosition(e);
        }
      });

      canvas.addEventListener('mouseleave', () => {
        if (heatmapHoverCell) {
          heatmapHoverCell = null;
          hideHeatmapTooltip();
          if (currentView === 'heatmap') renderHeatmap();
        }
      });

      // Click handler
      canvas.addEventListener('click', (e) => {
        if (currentView !== 'heatmap' || !heatmapHoverCell || !heatmapData) return;
        showHeatmapCellDetails(heatmapHoverCell);
      });
    }

    function showHeatmapTooltip(e, cell) {
      if (!heatmapTooltip) {
        heatmapTooltip = document.createElement('div');
        heatmapTooltip.style.cssText = `
          position: fixed; background: rgba(22, 33, 62, 0.95); border: 1px solid #0f3460;
          padding: 10px 14px; border-radius: 4px; font-size: 11px; color: #e0e0e0;
          pointer-events: none; z-index: 1000; max-width: 280px;
        `;
        document.body.appendChild(heatmapTooltip);
      }

      const { types, dataMap, bucketWidth } = heatmapData;
      const type = types[cell.typeIdx];
      const cellData = dataMap.get(type)[cell.bucket];
      const timeStart = (cell.bucket * bucketWidth / 1e6).toFixed(2);
      const timeEnd = ((cell.bucket + 1) * bucketWidth / 1e6).toFixed(2);

      let html = `<div style="font-weight: bold; color: ${TYPE_COLORS[type] || '#888'}; margin-bottom: 6px;">${type}</div>`;
      html += `<div style="display: grid; grid-template-columns: auto auto; gap: 2px 12px;">`;
      html += `<span style="color: #888;">Time:</span><span>${timeStart}ms - ${timeEnd}ms</span>`;
      html += `<span style="color: #888;">Sync ops:</span><span>${cellData.sync}</span>`;
      html += `<span style="color: #888;">Async ops:</span><span>${cellData.async}</span>`;
      html += `<span style="color: #888;">Resources:</span><span>${cellData.resources.length}</span>`;
      html += `</div>`;

      // Show critical path info if applicable
      if (showCriticalPath && cellData.resources.some(r => criticalPathSet.has(r.asyncId))) {
        const critCount = cellData.resources.filter(r => criticalPathSet.has(r.asyncId)).length;
        html += `<div style="margin-top: 6px; color: #ff6600;">üî• ${critCount} on critical path</div>`;
      }

      html += `<div style="color: #7ec8e3; margin-top: 6px; font-size: 10px;">Click for details</div>`;

      heatmapTooltip.innerHTML = html;
      heatmapTooltip.style.left = (e.clientX + 15) + 'px';
      heatmapTooltip.style.top = (e.clientY + 15) + 'px';
      heatmapTooltip.style.display = 'block';
    }

    function updateHeatmapTooltipPosition(e) {
      if (heatmapTooltip) {
        heatmapTooltip.style.left = (e.clientX + 15) + 'px';
        heatmapTooltip.style.top = (e.clientY + 15) + 'px';
      }
    }

    function hideHeatmapTooltip() {
      if (heatmapTooltip) {
        heatmapTooltip.style.display = 'none';
      }
    }

    function showHeatmapCellDetails(cell) {
      const { types, dataMap, bucketWidth } = heatmapData;
      const type = types[cell.typeIdx];
      const cellData = dataMap.get(type)[cell.bucket];
      const timeStart = (cell.bucket * bucketWidth / 1e6).toFixed(2);
      const timeEnd = ((cell.bucket + 1) * bucketWidth / 1e6).toFixed(2);

      const detailsEl = document.getElementById('selected-details');
      let html = `<div class="detail-item"><strong>Type:</strong> <span style="color: ${TYPE_COLORS[type] || '#888'};">${type}</span></div>`;
      html += `<div class="detail-item"><strong>Time:</strong> ${timeStart}ms - ${timeEnd}ms</div>`;
      html += `<div class="detail-item"><strong>Sync:</strong> ${cellData.sync} | <strong>Async:</strong> ${cellData.async}</div>`;

      if (cellData.resources.length > 0) {
        html += `<div class="detail-item" style="margin-top: 8px;"><strong>Resources (${cellData.resources.length}):</strong></div>`;
        cellData.resources.slice(0, 10).forEach(r => {
          const critBadge = showCriticalPath && criticalPathSet.has(r.asyncId) ? ' üî•' : '';
          html += `<div class="detail-item" style="font-size: 0.7rem; padding-left: 8px;">`;
          html += `#${r.asyncId}${critBadge} - `;
          if (r.callbackStartedAt > 0) {
            html += `${(r.callbackStartedAt / 1e6).toFixed(2)}ms`;
          } else {
            html += `created ${(r.createdAt / 1e6).toFixed(2)}ms`;
          }
          html += `</div>`;
        });
        if (cellData.resources.length > 10) {
          html += `<div class="detail-item" style="font-size: 0.7rem; color: #888;">... and ${cellData.resources.length - 10} more</div>`;
        }
      }

      detailsEl.innerHTML = html;
    }

    // ==================== SELECTION ====================
    function selectResource(r) {
      selectedResource = r;
      highlightedChain.clear();

      let current = r;
      while (current) {
        highlightedChain.add(current.asyncId);
        if (current.triggerId === 0) break;
        current = traceData.resourceMap.get(current.triggerId);
      }

      (traceData.childrenMap.get(r.asyncId) || []).forEach(id => highlightedChain.add(id));

      render();
      updateSelectedDetails();
    }

    function updateSelectedDetails() {
      const r = selectedResource;
      if (!r) return;

      document.getElementById('nav-parent').disabled = r.triggerId === 0;
      const children = traceData.childrenMap.get(r.asyncId) || [];
      document.getElementById('nav-children').disabled = children.length === 0;

      const endTime = r.callbackEndedAt > 0 ? r.callbackEndedAt : (r.destroyedAt > 0 ? r.destroyedAt : traceData.requestDurationNs);
      const totalDuration = endTime - r.createdAt;
      const asyncWait = r.callbackStartedAt > 0 ? r.callbackStartedAt - r.createdAt : 0;
      const syncTime = (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) ? r.callbackEndedAt - r.callbackStartedAt : 0;

      const classColors = { typed: '#50c878', user: '#7ec8e3', internal: '#888' };
      const classLabels = { typed: 'API call', user: 'User code', internal: 'Runtime' };

      document.getElementById('selected-details').innerHTML = `
        <div class="detail-item"><strong>ID:</strong> #${r.asyncId} ‚Üí #${r.triggerId || 'root'}</div>
        <div class="detail-item"><strong>Type:</strong> ${r.type} <span style="color: ${classColors[r._classification]}; font-size: 0.7rem;">(${classLabels[r._classification]})</span></div>
        <div class="detail-item"><strong>Created:</strong> ${(r.createdAt / 1e6).toFixed(3)}ms</div>
        ${r.callbackStartedAt > 0 ? `<div class="detail-item"><strong>Callback:</strong> ${(r.callbackStartedAt / 1e6).toFixed(3)} ‚Üí ${(r.callbackEndedAt / 1e6).toFixed(3)}ms</div>` : ''}
        ${children.length > 0 ? `<div class="detail-item"><strong>Children:</strong> ${children.length}</div>` : ''}
      `;

      const breakdownDiv = document.getElementById('timing-breakdown');
      if (asyncWait > 0 || syncTime > 0) {
        const total = asyncWait + syncTime;
        const asyncPct = total > 0 ? (asyncWait / total) * 100 : 0;
        const syncPct = total > 0 ? (syncTime / total) * 100 : 0;
        breakdownDiv.innerHTML = `
          <div class="timing-bar">
            ${asyncWait > 0 ? `<div class="segment" style="width: ${asyncPct}%; background: rgba(233,69,96,0.4);">‚è≥${(asyncWait/1e6).toFixed(1)}</div>` : ''}
            ${syncTime > 0 ? `<div class="segment" style="width: ${syncPct}%; background: ${TYPE_COLORS[r.type]};">‚ö°${(syncTime/1e6).toFixed(1)}</div>` : ''}
          </div>
          <div class="detail-item"><strong>Wait:</strong> ${(asyncWait / 1e6).toFixed(3)}ms (${asyncPct.toFixed(0)}%)</div>
          <div class="detail-item"><strong>Sync:</strong> ${(syncTime / 1e6).toFixed(3)}ms (${syncPct.toFixed(0)}%)</div>
        `;
      } else {
        breakdownDiv.innerHTML = `<div class="detail-item"><strong>Total:</strong> ${(totalDuration / 1e6).toFixed(3)}ms</div>`;
      }

      const st = traceData.stackTraceMap.get(r.stackTraceId);
      document.getElementById('stack-trace').innerHTML = (st && st.frames.length > 0) ?
        st.frames.map((f, i) => `<div class="stack-frame">${i === 0 ? '‚Üí ' : '  '}${f}</div>`).join('') :
        '<div class="stack-empty">No stack trace (internal runtime)</div>';

      const anns = traceData.annotationMap.get(r.asyncId);
      document.getElementById('annotations').innerHTML = (anns && anns.length > 0) ?
        anns.map(a => `<div class="detail-item"><strong>${a.key}:</strong> ${a.value}</div>`).join('') :
        '<div class="detail-item" style="color: #666;">-</div>';
    }

    function navigateToParent() {
      if (!selectedResource || selectedResource.triggerId === 0) return;
      const parent = traceData.resourceMap.get(selectedResource.triggerId);
      if (parent) selectResource(parent);
    }

    function navigateToChildren() {
      if (!selectedResource) return;
      const children = traceData.childrenMap.get(selectedResource.asyncId) || [];
      if (children.length > 0) {
        const child = traceData.resourceMap.get(children[0]);
        if (child) selectResource(child);
      }
    }

    function openAIAnalysis() {
      if (!traceData) {
        alert('Please load a trace first');
        return;
      }

      const prompt = generateAnalysisPrompt();
      document.getElementById('ai-prompt').value = prompt;

      // Generate Claude link (URL-encoded prompt)
      const claudeUrl = 'https://claude.ai/new?q=' + encodeURIComponent(prompt.substring(0, 8000));
      document.getElementById('ai-claude-link').href = claudeUrl;

      document.getElementById('ai-modal').style.display = 'flex';
    }

    function generateAnalysisPrompt() {
      const duration = traceData.requestDurationNs / 1e6;
      const resourceCount = traceData.resources.length;

      // Calculate timing stats
      let totalSync = 0, totalAsync = 0;
      traceData.resources.forEach(r => {
        if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
          totalSync += r.callbackEndedAt - r.callbackStartedAt;
        }
        if (r.callbackStartedAt > 0 && r.createdAt > 0) {
          totalAsync += r.callbackStartedAt - r.createdAt;
        }
      });

      // Count by type and classification
      const typeCounts = {};
      const classCounts = { typed: 0, user: 0, internal: 0 };
      traceData.resources.forEach(r => {
        typeCounts[r.type] = (typeCounts[r.type] || 0) + 1;
        classCounts[r._classification]++;
      });

      // Find critical path (longest chain)
      let maxDepth = 0;
      let deepestResource = null;
      traceData.resources.forEach(r => {
        const depth = traceData.depthMap.get(r.asyncId) || 0;
        if (depth > maxDepth) {
          maxDepth = depth;
          deepestResource = r;
        }
      });

      // Build critical path
      const criticalPath = [];
      let current = deepestResource;
      while (current) {
        criticalPath.unshift(current);
        if (current.triggerId === 0) break;
        current = traceData.resourceMap.get(current.triggerId);
      }

      // Find high-latency edges (>1ms)
      const highLatencyEdges = [];
      traceData.resources.forEach(r => {
        if (r.triggerId !== 0) {
          const parent = traceData.resourceMap.get(r.triggerId);
          if (parent) {
            const parentEnd = parent.callbackEndedAt > 0 ? parent.callbackEndedAt : parent.createdAt;
            const latency = (r.createdAt - parentEnd) / 1e6;
            if (latency > 1) {
              highLatencyEdges.push({
                from: parent,
                to: r,
                latencyMs: latency
              });
            }
          }
        }
      });
      highLatencyEdges.sort((a, b) => b.latencyMs - a.latencyMs);

      // Get annotations summary
      const annotationsSummary = [];
      const seenUrls = new Set();
      traceData.annotations.forEach(a => {
        if (a.key === 'url' && !seenUrls.has(a.value)) {
          seenUrls.add(a.value);
          annotationsSummary.push(`  - ${a.value}`);
        }
      });

      // Get unique stack traces with counts
      const stackCounts = {};
      traceData.resources.forEach(r => {
        const st = traceData.stackTraceMap.get(r.stackTraceId);
        if (st && st.frames.length > 0) {
          const key = st.frames[0];
          stackCounts[key] = (stackCounts[key] || 0) + 1;
        }
      });
      const topStacks = Object.entries(stackCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);

      // Generate the prompt
      let prompt = `Please analyze this Cloudflare Worker async trace and provide specific optimization recommendations.

## Trace Summary

- **Total Duration:** ${duration.toFixed(2)}ms
- **Resources:** ${resourceCount} total
  - Typed (API calls): ${classCounts.typed}
  - User code promises: ${classCounts.user}
  - Internal runtime: ${classCounts.internal}
- **Sync Time:** ${(totalSync / 1e6).toFixed(2)}ms (${((totalSync / (totalSync + totalAsync)) * 100 || 0).toFixed(0)}%)
- **Async Wait:** ${(totalAsync / 1e6).toFixed(2)}ms (${((totalAsync / (totalSync + totalAsync)) * 100 || 0).toFixed(0)}%)
- **Max Depth:** ${maxDepth} levels

## Resource Types

`;
      Object.entries(typeCounts)
        .sort((a, b) => b[1] - a[1])
        .forEach(([type, count]) => {
          prompt += `- ${type}: ${count}\n`;
        });

      prompt += `
## Critical Path (${criticalPath.length} resources, depth ${maxDepth})

`;
      criticalPath.forEach((r, i) => {
        const st = traceData.stackTraceMap.get(r.stackTraceId);
        const frame = st && st.frames.length > 0 ? st.frames[0] : '(no stack)';
        const latency = i > 0 ? ((r.createdAt - criticalPath[i-1].createdAt) / 1e6).toFixed(2) : '0.00';
        prompt += `${i + 1}. [${r.type}] ${frame} (+${latency}ms)\n`;
      });

      if (highLatencyEdges.length > 0) {
        prompt += `
## High Latency Edges (>1ms)

`;
        highLatencyEdges.slice(0, 10).forEach(edge => {
          const fromSt = traceData.stackTraceMap.get(edge.from.stackTraceId);
          const toSt = traceData.stackTraceMap.get(edge.to.stackTraceId);
          const fromFrame = fromSt && fromSt.frames.length > 0 ? fromSt.frames[0] : edge.from.type;
          const toFrame = toSt && toSt.frames.length > 0 ? toSt.frames[0] : edge.to.type;
          prompt += `- ${edge.latencyMs.toFixed(2)}ms: ${fromFrame} ‚Üí ${toFrame}\n`;
        });
      }

      if (annotationsSummary.length > 0) {
        prompt += `
## URLs/Endpoints Referenced

${annotationsSummary.slice(0, 15).join('\n')}
`;
      }

      if (topStacks.length > 0) {
        prompt += `
## Top Stack Locations (by frequency)

`;
        topStacks.forEach(([stack, count]) => {
          prompt += `- ${count}x: ${stack}\n`;
        });
      }

      // Add detected patterns (from pattern detection analysis)
      // We need to run pattern detection first
      const savedShowPatterns = showPatterns;
      showPatterns = true;
      detectPatterns();
      showPatterns = savedShowPatterns;

      if (detectedPatterns.length > 0) {
        prompt += `
## Detected Issues (by severity)

`;
        // Group patterns by severity
        const bySeverity = { high: [], medium: [], low: [] };
        detectedPatterns.forEach(p => {
          bySeverity[p.severity || 'medium'].push(p);
        });

        if (bySeverity.high.length > 0) {
          prompt += `### üî¥ High Severity (${bySeverity.high.length})\n`;
          bySeverity.high.forEach(p => {
            prompt += `- **[${p.type}]** ${p.message}\n`;
          });
          prompt += `\n`;
        }

        if (bySeverity.medium.length > 0) {
          prompt += `### üü° Medium Severity (${bySeverity.medium.length})\n`;
          bySeverity.medium.forEach(p => {
            prompt += `- **[${p.type}]** ${p.message}\n`;
          });
          prompt += `\n`;
        }

        if (bySeverity.low.length > 0) {
          prompt += `### üü¢ Low Severity (${bySeverity.low.length})\n`;
          bySeverity.low.forEach(p => {
            prompt += `- **[${p.type}]** ${p.message}\n`;
          });
          prompt += `\n`;
        }

        // Pattern type legend
        prompt += `**Pattern Types:**
- \`sequential-await\`: Fetches that could use Promise.all()
- \`duplicate-fetch\`: Same URL fetched multiple times
- \`waterfall-fetch\`: Fetches chained in sequence
- \`deep-chain\`: Deeply nested promise chains
- \`unresolved-promise\`: Promises never resolved
- \`long-async-gap\`: Operations waiting too long
- \`redundant-timers\`: Duplicate timers
- \`cache-miss\`: Slow cache operations (likely misses)
- \`sync-flood\`: Long sync execution blocking event loop
- \`promise-flood\`: Many promises created in short window
- \`callback-storm\`: Many callbacks firing simultaneously
- \`unbatched-ops\`: KV/DO operations that could be batched
- \`fetch-flood\`: Too many concurrent fetches
- \`hot-callback\`: Single callback spawning many children
`;
      }

      // Add stream operations summary
      const streamTypes = ['stream-read', 'stream-write', 'stream-pipe-to', 'stream-pipe-through'];
      const streamCounts = {};
      streamTypes.forEach(type => {
        const count = typeCounts[type] || 0;
        if (count > 0) streamCounts[type] = count;
      });

      if (Object.keys(streamCounts).length > 0) {
        prompt += `
## Stream Operations

`;
        Object.entries(streamCounts).forEach(([type, count]) => {
          prompt += `- ${type}: ${count}\n`;
        });
      }

      // Add KJ‚ÜîJS bridge analysis
      const kjToJsCount = typeCounts['kj-to-js'] || 0;
      const jsToKjCount = typeCounts['js-to-kj'] || 0;

      if (kjToJsCount > 0 || jsToKjCount > 0) {
        prompt += `
## KJ‚ÜîJS Bridge Transitions

`;
        if (kjToJsCount > 0) prompt += `- KJ‚ÜíJS transitions: ${kjToJsCount} (KJ promises resolving to JS)\n`;
        if (jsToKjCount > 0) prompt += `- JS‚ÜíKJ transitions: ${jsToKjCount} (JS promises awaiting KJ)\n`;
        prompt += `\nThese represent cross-boundary calls between the JavaScript runtime and the C++ I/O layer.\n`;
      }

      // Add temporal edges analysis
      const savedShowTemporalEdges = showTemporalEdges;
      showTemporalEdges = true;
      computeTemporalEdges();
      showTemporalEdges = savedShowTemporalEdges;

      if (temporalEdges.length > 0) {
        // Find resources that spawn many temporal children
        const temporalParents = {};
        temporalEdges.forEach(edge => {
          temporalParents[edge.from] = (temporalParents[edge.from] || 0) + 1;
        });

        const topTemporalParents = Object.entries(temporalParents)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 5);

        if (topTemporalParents.some(([_, count]) => count > 2)) {
          prompt += `
## Temporal Execution Patterns

`;
          prompt += `Found ${temporalEdges.length} timing-based relationships (callbacks starting during other callbacks).\n\n`;
          prompt += `Top spawning callbacks:\n`;
          topTemporalParents.forEach(([id, count]) => {
            if (count > 1) {
              const r = traceData.resourceMap.get(parseInt(id));
              if (r) {
                const st = traceData.stackTraceMap.get(r.stackTraceId);
                const frame = st && st.frames.length > 0 ? st.frames[0] : '(no stack)';
                prompt += `- [${r.type}] ${frame}: spawns ${count} callbacks\n`;
              }
            }
          });
        }
      }

      // Add bottleneck details
      const savedShowBottlenecks = showBottlenecks;
      showBottlenecks = true;
      detectBottlenecks();
      showBottlenecks = savedShowBottlenecks;

      if (detectedBottlenecks.length > 0) {
        prompt += `
## Top Bottlenecks (by time)

`;
        detectedBottlenecks.forEach((id, i) => {
          const r = traceData.resourceMap.get(id);
          if (r) {
            const st = traceData.stackTraceMap.get(r.stackTraceId);
            const frame = st && st.frames.length > 0 ? st.frames[0] : '(no stack)';
            let syncTime = 0, asyncWait = 0;
            if (r.callbackStartedAt > 0 && r.callbackEndedAt > 0) {
              syncTime = (r.callbackEndedAt - r.callbackStartedAt) / 1e6;
            }
            if (r.callbackStartedAt > 0 && r.createdAt > 0) {
              asyncWait = (r.callbackStartedAt - r.createdAt) / 1e6;
            }
            prompt += `${i + 1}. [${r.type}] ${frame}\n`;
            prompt += `   - Sync execution: ${syncTime.toFixed(2)}ms\n`;
            prompt += `   - Async wait: ${asyncWait.toFixed(2)}ms\n`;
          }
        });
      }

      prompt += `
## Analysis Request

Based on this trace data, please analyze starting with **high severity issues first**:

1. **Address high severity issues first** - Focus on patterns marked with üî¥. These have the biggest impact:
   - \`sync-flood\`: Event loop blockers preventing other callbacks from running
   - \`sequential-await\`: Opportunities to use Promise.all()
   - \`unbatched-ops\`: KV/DO operations that could use batch APIs

2. **Check for serialization issues** - Are there operations that could run in parallel but are running sequentially? Pay special attention to any detected sequential-await or waterfall patterns.

3. **Evaluate event loop health** - Is sync execution blocking the event loop? Are there operations that should be async but are running synchronously?

4. **Check for memory pressure risks** - Are there promise-flood or callback-storm patterns that could cause memory issues under load?

5. **Look for redundant operations** - Are there duplicate fetches or unnecessary API calls? Check the detected patterns section for duplicates.

6. **Assess fetch concurrency** - If fetch-flood is detected, could this hit connection limits? Consider request coalescing or batching.

7. **Analyze stream operations** - If streams are involved, are they being used efficiently? Are there opportunities to pipeline or parallelize stream processing?

8. **Review KJ‚ÜîJS transitions** - Are there excessive bridge transitions that could indicate inefficient async patterns?

9. **Provide specific code recommendations** - Give concrete code examples showing how to improve the most impactful issues. Prioritize high severity patterns.

10. **Estimate potential improvement** - If your recommendations are implemented, roughly how much latency reduction might be achieved?

Please be specific and actionable in your recommendations. Address issues in severity order (high ‚Üí medium ‚Üí low). Reference specific resource types, stack locations, and timing data from the trace.`;

      return prompt;
    }
  </script>
</body>
</html>
